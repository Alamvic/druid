Class {
	#name : #DruidTestRTLCompiler,
	#superclass : #DruidJIT,
	#category : #'Druid-Tests'
}

{ #category : #'class initialization' }
DruidTestRTLCompiler class >> bytecodeTable [

	<generated>
	^ {
		  { 1. 0. 0. #gen_BytecodeWithNoFrameInstVarRefAnnotation.
		  #isInstVarRef. #needsFrameNever:. 1 }.
		  { 1. 77. 77. #gen_BytecodeWithNoFrameInstVarRefAnnotation }.
		  { 1. 90. 90. #gen_BytecodeWithNoFrameInstVarRefAnnotation }.
		  { 1. 91. 91. #gen_BytecodeWithNoFrameInstVarRefAnnotation }.
		  { 1. 176. 176. #gen_BytecodeWithNoFrameInstVarRefAnnotation }.
		  { 1. 184. 184. #gen_BytecodeWithNoFrameInstVarRefAnnotation }.
		  { 1. 192. 192. #gen_BytecodeWithNoFrameInstVarRefAnnotation } }
]

{ #category : #'class initialization' }
DruidTestRTLCompiler class >> initializeBytecodeTableForSistaV1 [

	<generated>
	numPushNilsFunction := #sistaV1:Num:Push:Nils:.
	pushNilSizeFunction := #sistaV1PushNilSize:numInitialNils:.
	BytecodeSetHasDirectedSuperSend := true.
	BytecodeSetHasExtensions := true.
	FirstSpecialSelector := 96.
	NumSpecialSelectors := 32.
	self generatorTableFrom: self bytecodeTable
]

{ #category : #'class initialization' }
DruidTestRTLCompiler class >> initializePrimitiveTable [

	<generated>
	MaxCompiledPrimitiveIndex := 0.
	primitiveTable := CArrayAccessor on:
		                  (Array new: MaxCompiledPrimitiveIndex + 1).
	self table: primitiveTable from: self primitiveTableArray.
	^ primitiveTable
]

{ #category : #'class initialization' }
DruidTestRTLCompiler class >> primitiveTableArray [

	<generated>
	^ {  }
]

{ #category : #deployment }
DruidTestRTLCompiler class >> replaceMethodOnJIT: selector [

| druidMethod cogMethod |
druidMethod := DruidTestRTLCompiler lookupSelector: (#gen_, selector).
cogMethod := druidMethod ast copy.

"Change selector"
cogMethod selector: (#gen, selector capitalized).

"Replace self by cogit variable"
cogMethod nodesDo: [ :n | n isSelfVariable ifTrue: [ n replaceWith: (RBVariableNode named: 'cogit') ] ].

"Add type anotations"
cogMethod pragmas: { }.
cogMethod temporaries do: [ :temp | |args|	
	args := {temp name. #'AbstractInstruction *'} collect: [ :arg | RBLiteralNode value: arg ].
	cogMethod addPragma: (RBPragmaNode selector: #var:type: arguments: args).	
].


CogObjectRepresentation compile: cogMethod formattedCode classified: 'primitive generators'
]

{ #category : #compiling }
DruidTestRTLCompiler >> compileAbort [
	"Fake method"

	stackOverflowCall := self Nop
]

{ #category : #compiling }
DruidTestRTLCompiler >> compileEntry [
	"Fake method"

	
]

{ #category : #accessing }
DruidTestRTLCompiler >> deadCode [

	^ deadCode
]

{ #category : #accessing }
DruidTestRTLCompiler >> extA [

	<doNotGenerate>
	^ extA
]

{ #category : #accessing }
DruidTestRTLCompiler >> extA: anObject [

	<doNotGenerate>
	^ extA := anObject
]

{ #category : #accessing }
DruidTestRTLCompiler >> extB [

	<doNotGenerate>
	^ extB
]

{ #category : #accessing }
DruidTestRTLCompiler >> extB: anObject [

	<doNotGenerate>
	^ extB := anObject
]

{ #category : #'primitive generators' }
DruidTestRTLCompiler >> genPrimReturn [

	self RetN: 0
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_BytecodeWithNoFrameInstVarRefAnnotation [
	"AutoGenerated by Druid"

	| live currentBlock |
	live := 0.
	^ 0
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_BytecodeWithNoFrameInstVarRefAnnotation0 [
	"AutoGenerated by Druid"

	| live currentBlock |
	live := 0.
	^ 0
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_BytecodeWithNoFrameInstVarRefAnnotation1 [
	"AutoGenerated by Druid"

	| live currentBlock |
	live := 0.
	^ 0
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_BytecodeWithNoFrameInstVarRefAnnotation2 [
	"AutoGenerated by Druid"

	| live currentBlock |
	live := 0.
	^ 0
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_BytecodeWithNoFrameInstVarRefAnnotation3 [
	"AutoGenerated by Druid"

	| live currentBlock |
	live := 0.
	^ 0
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_PrimitiveAdd [
	"AutoGenerated by Druid"

	| jump1 jump2 currentBlock |
	self mclassIsSmallInteger ifFalse: [ ^ UnimplementedPrimitive ].
	self MoveR: ReceiverResultReg R: TempReg.
	self MoveR: Arg0Reg R: ClassReg.
	self TstCq: 1 R: ClassReg.
	jump1 := self JumpZero: 0.
	self AddCq:  -1 R: ClassReg.
	self AddR: TempReg R: ClassReg.
	jump2 := self JumpOverflow: 0.
	self MoveR: ClassReg R: ReceiverResultReg.
	self genPrimReturn.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	jump2 jmpTarget: currentBlock.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_PushReceiverVariableBytecode [
	"AutoGenerated by Druid"

	| live currentBlock t0 |
	live := 0.
	self ensureReceiverResultRegContainsSelf.
	t0 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t0).
	self MoveR: ReceiverResultReg R: t0.
	self ssPushBase: t0 offset: 8.
	^ 0
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_ReturnTopFromMethod [
	"AutoGenerated by Druid"

	| live currentBlock t0 |
	live := 0.
	t0 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t0).
	(self ssValue: 0) copyToReg: t0.
	self ssPop: 1.
	self MoveR: t0 R: ReceiverResultReg.
	self genUpArrowReturn.
	^ 0
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_StoreAndPopReceiverVariableBytecode0 [
	"AutoGenerated by Druid"

	| jump1 jump7 jumpNext t1 jump6 jump3 jump9 currentBlock t0 jump5 jump2 jumpTrue jump8 live t2 jump4 |
	live := 0.
	self annotateBytecode: self Label.
	self ensureReceiverResultRegContainsSelf.
	t0 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t0).
	self MoveR: ReceiverResultReg R: t0.
	t1 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t1).
	(self ssValue: 0) copyToReg: t1.
	t2 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t2).
	self MoveM64: 0 r: t0 R: t2.
	self ArithmeticShiftRightCq: 23 R: t2.
	self AndCq: 1 R: t2.
	self ssFlushStack.
	self CmpCq: 0 R: t2.
	jump1 := self JumpZero: 0.
	self deoptimize.
	jump2 := self Jump: 0.
	deadCode := false.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	self ssPop: 1.
	self MoveR: t0 R: t2.
	self AndCq: 7 R: t2.
	self CmpCq: 0 R: t2.
	jump1 := self JumpNonZero: 0.
	self MoveR: t0 R: t2.
	self AndCq: objectMemory getMemoryMap getSpaceMaskToUse R: t2.
	self CmpCq: objectMemory getMemoryMap getOldSpaceMask R: t2.
	jump3 := self JumpNonZero: 0.
	self MoveR: t1 R: t2.
	self AndCq: 7 R: t2.
	self CmpCq: 0 R: t2.
	jump4 := self JumpNonZero: 0.
	self MoveR: t1 R: t2.
	self AndCq: objectMemory getMemoryMap getSpaceMaskToUse R: t2.
	self CmpCq: objectMemory getMemoryMap getNewSpaceMask R: t2.
	jump5 := self JumpNonZero: 0.
	self MoveR: t1 R: t2.
	self CmpCq: objectMemory getMemoryMap getNewSpaceStart R: t2.
	jumpTrue := self JumpAboveOrEqual: 0.
	self MoveCq: 0 R: t2.
	jumpNext := self Jump: 0.
	jumpTrue jmpTarget: self Label.
	self MoveCq: 1 R: t2.
	jumpNext jmpTarget: self Label.
	self CmpCq: 1 R: t2.
	jump6 := self JumpNonZero: 0.
	self MoveM64: 0 r: t0 R: t2.
	self ArithmeticShiftRightCq: 29 R: t2.
	self AndCq: 1 R: t2.
	self CmpCq: 0 R: t2.
	jump7 := self JumpNonZero: 0.
	self MoveR: t0 R: TempReg.
	backEnd saveAndRestoreLinkRegAround: [
		self CallRT: ceStoreCheckTrampoline ].
	self TstCq: 7 R: t1.
	jump8 := self JumpNonZero: 0.
	jump9 := self JumpZero: 0.
	currentBlock := self Label.
	jump5 jmpTarget: currentBlock.
	self MoveCq: 0 R: t2.
	currentBlock := self Label.
	jump6 jmpTarget: currentBlock.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	jump3 jmpTarget: currentBlock.
	jump4 jmpTarget: currentBlock.
	jump7 jmpTarget: currentBlock.
	self TstCq: 7 R: t1.
	jump7 := self JumpNonZero: 0.
	currentBlock := self Label.
	jump9 jmpTarget: currentBlock.
	self CmpCq: objectMemory nilObject R: t1.
	jump9 := self JumpBelow: 0.
	self MoveR: t1 R: t2.
	self CmpCq: objectMemory trueObject R: t2.
	jumpTrue := self JumpBelowOrEqual: 0.
	self MoveCq: 0 R: t2.
	jumpNext := self Jump: 0.
	jumpTrue jmpTarget: self Label.
	self MoveCq: 1 R: t2.
	jumpNext jmpTarget: self Label.
	jump4 := self Jump: 0.
	currentBlock := self Label.
	jump9 jmpTarget: currentBlock.
	self MoveCq: 0 R: t2.
	currentBlock := self Label.
	jump4 jmpTarget: currentBlock.
	self CmpCq: 1 R: t2.
	jump4 := self JumpZero: 0.
	self CmpCq: objectMemory getMemoryMap getNewSpaceStart R: t1.
	jump9 := self JumpBelow: 0.
	self MoveM64: 0 r: t0 R: t2.
	self ArithmeticShiftRightCq: 29 R: t2.
	self AndCq: 1 R: t2.
	self CmpCq: 0 R: t2.
	jump3 := self JumpNonZero: 0.
	self MoveR: t0 R: t2.
	self AndCq: 7 R: t2.
	self CmpCq: 0 R: t2.
	jump1 := self JumpNonZero: 0.
	self MoveR: t0 R: t2.
	self AndCq: objectMemory getMemoryMap getSpaceMaskToUse R: t2.
	self CmpCq: objectMemory getMemoryMap getPermSpaceMask R: t2.
	jumpTrue := self JumpZero: 0.
	self MoveCq: 0 R: t2.
	jumpNext := self Jump: 0.
	jumpTrue jmpTarget: self Label.
	self MoveCq: 1 R: t2.
	jumpNext jmpTarget: self Label.
	jump6 := self Jump: 0.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	self MoveCq: 0 R: t2.
	currentBlock := self Label.
	jump6 jmpTarget: currentBlock.
	self CmpCq: 1 R: t2.
	jump6 := self JumpNonZero: 0.
	self MoveR: t1 R: t2.
	self AndCq: objectMemory getMemoryMap getSpaceMaskToUse R: t2.
	self CmpCq: objectMemory getMemoryMap getPermSpaceMask R: t2.
	jump1 := self JumpZero: 0.
	self MoveR: t0 R: TempReg.
	backEnd saveAndRestoreLinkRegAround: [
		self CallRT: ceStoreCheckTrampoline ].
	currentBlock := self Label.
	jump8 jmpTarget: currentBlock.
	jump7 jmpTarget: currentBlock.
	jump4 jmpTarget: currentBlock.
	jump9 jmpTarget: currentBlock.
	jump3 jmpTarget: currentBlock.
	jump6 jmpTarget: currentBlock.
	jump1 jmpTarget: currentBlock.
	self MoveR: t1 M64: 8 r: t0.
	currentBlock := self Label.
	jump2 jmpTarget: currentBlock.
	^ 0
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_StoreAndPopReceiverVariableBytecode1 [
	"AutoGenerated by Druid"

	| jump1 jump7 jumpNext t1 jump6 jump3 jump9 currentBlock t0 jump5 jump2 jumpTrue jump8 live t2 jump4 |
	live := 0.
	self annotateBytecode: self Label.
	self ensureReceiverResultRegContainsSelf.
	t0 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t0).
	self MoveR: ReceiverResultReg R: t0.
	t1 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t1).
	(self ssValue: 0) copyToReg: t1.
	t2 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t2).
	self MoveM64: 0 r: t0 R: t2.
	self ArithmeticShiftRightCq: 23 R: t2.
	self AndCq: 1 R: t2.
	self ssFlushStack.
	self CmpCq: 0 R: t2.
	jump1 := self JumpZero: 0.
	self deoptimize.
	jump2 := self Jump: 0.
	deadCode := false.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	self ssPop: 1.
	self MoveR: t0 R: t2.
	self AndCq: 7 R: t2.
	self CmpCq: 0 R: t2.
	jump1 := self JumpNonZero: 0.
	self MoveR: t0 R: t2.
	self AndCq: objectMemory getMemoryMap getSpaceMaskToUse R: t2.
	self CmpCq: objectMemory getMemoryMap getOldSpaceMask R: t2.
	jump3 := self JumpNonZero: 0.
	self MoveR: t1 R: t2.
	self AndCq: 7 R: t2.
	self CmpCq: 0 R: t2.
	jump4 := self JumpNonZero: 0.
	self MoveR: t1 R: t2.
	self AndCq: objectMemory getMemoryMap getSpaceMaskToUse R: t2.
	self CmpCq: objectMemory getMemoryMap getNewSpaceMask R: t2.
	jump5 := self JumpNonZero: 0.
	self MoveR: t1 R: t2.
	self CmpCq: objectMemory getMemoryMap getNewSpaceStart R: t2.
	jumpTrue := self JumpAboveOrEqual: 0.
	self MoveCq: 0 R: t2.
	jumpNext := self Jump: 0.
	jumpTrue jmpTarget: self Label.
	self MoveCq: 1 R: t2.
	jumpNext jmpTarget: self Label.
	self CmpCq: 1 R: t2.
	jump6 := self JumpNonZero: 0.
	self MoveM64: 0 r: t0 R: t2.
	self ArithmeticShiftRightCq: 29 R: t2.
	self AndCq: 1 R: t2.
	self CmpCq: 0 R: t2.
	jump7 := self JumpNonZero: 0.
	self MoveR: t0 R: TempReg.
	backEnd saveAndRestoreLinkRegAround: [
		self CallRT: ceStoreCheckTrampoline ].
	self TstCq: 7 R: t1.
	jump8 := self JumpNonZero: 0.
	jump9 := self JumpZero: 0.
	currentBlock := self Label.
	jump5 jmpTarget: currentBlock.
	self MoveCq: 0 R: t2.
	currentBlock := self Label.
	jump6 jmpTarget: currentBlock.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	jump3 jmpTarget: currentBlock.
	jump4 jmpTarget: currentBlock.
	jump7 jmpTarget: currentBlock.
	self TstCq: 7 R: t1.
	jump7 := self JumpNonZero: 0.
	currentBlock := self Label.
	jump9 jmpTarget: currentBlock.
	self CmpCq: objectMemory nilObject R: t1.
	jump9 := self JumpBelow: 0.
	self MoveR: t1 R: t2.
	self CmpCq: objectMemory trueObject R: t2.
	jumpTrue := self JumpBelowOrEqual: 0.
	self MoveCq: 0 R: t2.
	jumpNext := self Jump: 0.
	jumpTrue jmpTarget: self Label.
	self MoveCq: 1 R: t2.
	jumpNext jmpTarget: self Label.
	jump4 := self Jump: 0.
	currentBlock := self Label.
	jump9 jmpTarget: currentBlock.
	self MoveCq: 0 R: t2.
	currentBlock := self Label.
	jump4 jmpTarget: currentBlock.
	self CmpCq: 1 R: t2.
	jump4 := self JumpZero: 0.
	self CmpCq: objectMemory getMemoryMap getNewSpaceStart R: t1.
	jump9 := self JumpBelow: 0.
	self MoveM64: 0 r: t0 R: t2.
	self ArithmeticShiftRightCq: 29 R: t2.
	self AndCq: 1 R: t2.
	self CmpCq: 0 R: t2.
	jump3 := self JumpNonZero: 0.
	self MoveR: t0 R: t2.
	self AndCq: 7 R: t2.
	self CmpCq: 0 R: t2.
	jump1 := self JumpNonZero: 0.
	self MoveR: t0 R: t2.
	self AndCq: objectMemory getMemoryMap getSpaceMaskToUse R: t2.
	self CmpCq: objectMemory getMemoryMap getPermSpaceMask R: t2.
	jumpTrue := self JumpZero: 0.
	self MoveCq: 0 R: t2.
	jumpNext := self Jump: 0.
	jumpTrue jmpTarget: self Label.
	self MoveCq: 1 R: t2.
	jumpNext jmpTarget: self Label.
	jump6 := self Jump: 0.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	self MoveCq: 0 R: t2.
	currentBlock := self Label.
	jump6 jmpTarget: currentBlock.
	self CmpCq: 1 R: t2.
	jump6 := self JumpNonZero: 0.
	self MoveR: t1 R: t2.
	self AndCq: objectMemory getMemoryMap getSpaceMaskToUse R: t2.
	self CmpCq: objectMemory getMemoryMap getPermSpaceMask R: t2.
	jump1 := self JumpZero: 0.
	self MoveR: t0 R: TempReg.
	backEnd saveAndRestoreLinkRegAround: [
		self CallRT: ceStoreCheckTrampoline ].
	currentBlock := self Label.
	jump8 jmpTarget: currentBlock.
	jump7 jmpTarget: currentBlock.
	jump4 jmpTarget: currentBlock.
	jump9 jmpTarget: currentBlock.
	jump3 jmpTarget: currentBlock.
	jump6 jmpTarget: currentBlock.
	jump1 jmpTarget: currentBlock.
	self MoveR: t1 M64: 16 r: t0.
	currentBlock := self Label.
	jump2 jmpTarget: currentBlock.
	^ 0
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_StoreAndPopReceiverVariableBytecode2 [
	"AutoGenerated by Druid"

	| jump1 jump7 jumpNext t1 jump6 jump3 jump9 currentBlock t0 jump5 jump2 jumpTrue jump8 live t2 jump4 |
	live := 0.
	self annotateBytecode: self Label.
	self ensureReceiverResultRegContainsSelf.
	t0 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t0).
	self MoveR: ReceiverResultReg R: t0.
	t1 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t1).
	(self ssValue: 0) copyToReg: t1.
	t2 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t2).
	self MoveM64: 0 r: t0 R: t2.
	self ArithmeticShiftRightCq: 23 R: t2.
	self AndCq: 1 R: t2.
	self ssFlushStack.
	self CmpCq: 0 R: t2.
	jump1 := self JumpZero: 0.
	self deoptimize.
	jump2 := self Jump: 0.
	deadCode := false.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	self ssPop: 1.
	self MoveR: t0 R: t2.
	self AndCq: 7 R: t2.
	self CmpCq: 0 R: t2.
	jump1 := self JumpNonZero: 0.
	self MoveR: t0 R: t2.
	self AndCq: objectMemory getMemoryMap getSpaceMaskToUse R: t2.
	self CmpCq: objectMemory getMemoryMap getOldSpaceMask R: t2.
	jump3 := self JumpNonZero: 0.
	self MoveR: t1 R: t2.
	self AndCq: 7 R: t2.
	self CmpCq: 0 R: t2.
	jump4 := self JumpNonZero: 0.
	self MoveR: t1 R: t2.
	self AndCq: objectMemory getMemoryMap getSpaceMaskToUse R: t2.
	self CmpCq: objectMemory getMemoryMap getNewSpaceMask R: t2.
	jump5 := self JumpNonZero: 0.
	self MoveR: t1 R: t2.
	self CmpCq: objectMemory getMemoryMap getNewSpaceStart R: t2.
	jumpTrue := self JumpAboveOrEqual: 0.
	self MoveCq: 0 R: t2.
	jumpNext := self Jump: 0.
	jumpTrue jmpTarget: self Label.
	self MoveCq: 1 R: t2.
	jumpNext jmpTarget: self Label.
	self CmpCq: 1 R: t2.
	jump6 := self JumpNonZero: 0.
	self MoveM64: 0 r: t0 R: t2.
	self ArithmeticShiftRightCq: 29 R: t2.
	self AndCq: 1 R: t2.
	self CmpCq: 0 R: t2.
	jump7 := self JumpNonZero: 0.
	self MoveR: t0 R: TempReg.
	backEnd saveAndRestoreLinkRegAround: [
		self CallRT: ceStoreCheckTrampoline ].
	self TstCq: 7 R: t1.
	jump8 := self JumpNonZero: 0.
	jump9 := self JumpZero: 0.
	currentBlock := self Label.
	jump5 jmpTarget: currentBlock.
	self MoveCq: 0 R: t2.
	currentBlock := self Label.
	jump6 jmpTarget: currentBlock.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	jump3 jmpTarget: currentBlock.
	jump4 jmpTarget: currentBlock.
	jump7 jmpTarget: currentBlock.
	self TstCq: 7 R: t1.
	jump7 := self JumpNonZero: 0.
	currentBlock := self Label.
	jump9 jmpTarget: currentBlock.
	self CmpCq: objectMemory nilObject R: t1.
	jump9 := self JumpBelow: 0.
	self MoveR: t1 R: t2.
	self CmpCq: objectMemory trueObject R: t2.
	jumpTrue := self JumpBelowOrEqual: 0.
	self MoveCq: 0 R: t2.
	jumpNext := self Jump: 0.
	jumpTrue jmpTarget: self Label.
	self MoveCq: 1 R: t2.
	jumpNext jmpTarget: self Label.
	jump4 := self Jump: 0.
	currentBlock := self Label.
	jump9 jmpTarget: currentBlock.
	self MoveCq: 0 R: t2.
	currentBlock := self Label.
	jump4 jmpTarget: currentBlock.
	self CmpCq: 1 R: t2.
	jump4 := self JumpZero: 0.
	self CmpCq: objectMemory getMemoryMap getNewSpaceStart R: t1.
	jump9 := self JumpBelow: 0.
	self MoveM64: 0 r: t0 R: t2.
	self ArithmeticShiftRightCq: 29 R: t2.
	self AndCq: 1 R: t2.
	self CmpCq: 0 R: t2.
	jump3 := self JumpNonZero: 0.
	self MoveR: t0 R: t2.
	self AndCq: 7 R: t2.
	self CmpCq: 0 R: t2.
	jump1 := self JumpNonZero: 0.
	self MoveR: t0 R: t2.
	self AndCq: objectMemory getMemoryMap getSpaceMaskToUse R: t2.
	self CmpCq: objectMemory getMemoryMap getPermSpaceMask R: t2.
	jumpTrue := self JumpZero: 0.
	self MoveCq: 0 R: t2.
	jumpNext := self Jump: 0.
	jumpTrue jmpTarget: self Label.
	self MoveCq: 1 R: t2.
	jumpNext jmpTarget: self Label.
	jump6 := self Jump: 0.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	self MoveCq: 0 R: t2.
	currentBlock := self Label.
	jump6 jmpTarget: currentBlock.
	self CmpCq: 1 R: t2.
	jump6 := self JumpNonZero: 0.
	self MoveR: t1 R: t2.
	self AndCq: objectMemory getMemoryMap getSpaceMaskToUse R: t2.
	self CmpCq: objectMemory getMemoryMap getPermSpaceMask R: t2.
	jump1 := self JumpZero: 0.
	self MoveR: t0 R: TempReg.
	backEnd saveAndRestoreLinkRegAround: [
		self CallRT: ceStoreCheckTrampoline ].
	currentBlock := self Label.
	jump8 jmpTarget: currentBlock.
	jump7 jmpTarget: currentBlock.
	jump4 jmpTarget: currentBlock.
	jump9 jmpTarget: currentBlock.
	jump3 jmpTarget: currentBlock.
	jump6 jmpTarget: currentBlock.
	jump1 jmpTarget: currentBlock.
	self MoveR: t1 M64: 24 r: t0.
	currentBlock := self Label.
	jump2 jmpTarget: currentBlock.
	^ 0
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_StoreAndPopReceiverVariableBytecode3 [
	"AutoGenerated by Druid"

	| jump1 jump7 jumpNext t1 jump6 jump3 jump9 currentBlock t0 jump5 jump2 jumpTrue jump8 live t2 jump4 |
	live := 0.
	self annotateBytecode: self Label.
	self ensureReceiverResultRegContainsSelf.
	t0 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t0).
	self MoveR: ReceiverResultReg R: t0.
	t1 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t1).
	(self ssValue: 0) copyToReg: t1.
	t2 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t2).
	self MoveM64: 0 r: t0 R: t2.
	self ArithmeticShiftRightCq: 23 R: t2.
	self AndCq: 1 R: t2.
	self ssFlushStack.
	self CmpCq: 0 R: t2.
	jump1 := self JumpZero: 0.
	self deoptimize.
	jump2 := self Jump: 0.
	deadCode := false.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	self ssPop: 1.
	self MoveR: t0 R: t2.
	self AndCq: 7 R: t2.
	self CmpCq: 0 R: t2.
	jump1 := self JumpNonZero: 0.
	self MoveR: t0 R: t2.
	self AndCq: objectMemory getMemoryMap getSpaceMaskToUse R: t2.
	self CmpCq: objectMemory getMemoryMap getOldSpaceMask R: t2.
	jump3 := self JumpNonZero: 0.
	self MoveR: t1 R: t2.
	self AndCq: 7 R: t2.
	self CmpCq: 0 R: t2.
	jump4 := self JumpNonZero: 0.
	self MoveR: t1 R: t2.
	self AndCq: objectMemory getMemoryMap getSpaceMaskToUse R: t2.
	self CmpCq: objectMemory getMemoryMap getNewSpaceMask R: t2.
	jump5 := self JumpNonZero: 0.
	self MoveR: t1 R: t2.
	self CmpCq: objectMemory getMemoryMap getNewSpaceStart R: t2.
	jumpTrue := self JumpAboveOrEqual: 0.
	self MoveCq: 0 R: t2.
	jumpNext := self Jump: 0.
	jumpTrue jmpTarget: self Label.
	self MoveCq: 1 R: t2.
	jumpNext jmpTarget: self Label.
	self CmpCq: 1 R: t2.
	jump6 := self JumpNonZero: 0.
	self MoveM64: 0 r: t0 R: t2.
	self ArithmeticShiftRightCq: 29 R: t2.
	self AndCq: 1 R: t2.
	self CmpCq: 0 R: t2.
	jump7 := self JumpNonZero: 0.
	self MoveR: t0 R: TempReg.
	backEnd saveAndRestoreLinkRegAround: [
		self CallRT: ceStoreCheckTrampoline ].
	self TstCq: 7 R: t1.
	jump8 := self JumpNonZero: 0.
	jump9 := self JumpZero: 0.
	currentBlock := self Label.
	jump5 jmpTarget: currentBlock.
	self MoveCq: 0 R: t2.
	currentBlock := self Label.
	jump6 jmpTarget: currentBlock.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	jump3 jmpTarget: currentBlock.
	jump4 jmpTarget: currentBlock.
	jump7 jmpTarget: currentBlock.
	self TstCq: 7 R: t1.
	jump7 := self JumpNonZero: 0.
	currentBlock := self Label.
	jump9 jmpTarget: currentBlock.
	self CmpCq: objectMemory nilObject R: t1.
	jump9 := self JumpBelow: 0.
	self MoveR: t1 R: t2.
	self CmpCq: objectMemory trueObject R: t2.
	jumpTrue := self JumpBelowOrEqual: 0.
	self MoveCq: 0 R: t2.
	jumpNext := self Jump: 0.
	jumpTrue jmpTarget: self Label.
	self MoveCq: 1 R: t2.
	jumpNext jmpTarget: self Label.
	jump4 := self Jump: 0.
	currentBlock := self Label.
	jump9 jmpTarget: currentBlock.
	self MoveCq: 0 R: t2.
	currentBlock := self Label.
	jump4 jmpTarget: currentBlock.
	self CmpCq: 1 R: t2.
	jump4 := self JumpZero: 0.
	self CmpCq: objectMemory getMemoryMap getNewSpaceStart R: t1.
	jump9 := self JumpBelow: 0.
	self MoveM64: 0 r: t0 R: t2.
	self ArithmeticShiftRightCq: 29 R: t2.
	self AndCq: 1 R: t2.
	self CmpCq: 0 R: t2.
	jump3 := self JumpNonZero: 0.
	self MoveR: t0 R: t2.
	self AndCq: 7 R: t2.
	self CmpCq: 0 R: t2.
	jump1 := self JumpNonZero: 0.
	self MoveR: t0 R: t2.
	self AndCq: objectMemory getMemoryMap getSpaceMaskToUse R: t2.
	self CmpCq: objectMemory getMemoryMap getPermSpaceMask R: t2.
	jumpTrue := self JumpZero: 0.
	self MoveCq: 0 R: t2.
	jumpNext := self Jump: 0.
	jumpTrue jmpTarget: self Label.
	self MoveCq: 1 R: t2.
	jumpNext jmpTarget: self Label.
	jump6 := self Jump: 0.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	self MoveCq: 0 R: t2.
	currentBlock := self Label.
	jump6 jmpTarget: currentBlock.
	self CmpCq: 1 R: t2.
	jump6 := self JumpNonZero: 0.
	self MoveR: t1 R: t2.
	self AndCq: objectMemory getMemoryMap getSpaceMaskToUse R: t2.
	self CmpCq: objectMemory getMemoryMap getPermSpaceMask R: t2.
	jump1 := self JumpZero: 0.
	self MoveR: t0 R: TempReg.
	backEnd saveAndRestoreLinkRegAround: [
		self CallRT: ceStoreCheckTrampoline ].
	currentBlock := self Label.
	jump8 jmpTarget: currentBlock.
	jump7 jmpTarget: currentBlock.
	jump4 jmpTarget: currentBlock.
	jump9 jmpTarget: currentBlock.
	jump3 jmpTarget: currentBlock.
	jump6 jmpTarget: currentBlock.
	jump1 jmpTarget: currentBlock.
	self MoveR: t1 M64: 32 r: t0.
	currentBlock := self Label.
	jump2 jmpTarget: currentBlock.
	^ 0
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_assertIsIgnored [

	| currentBlock |
	self MoveCq: 17 R: ReceiverResultReg.
	self RetN: 1 * objectMemory wordSize.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_branchingWithAssigments [

	| currentBlock jump0 jump1 |
	self CmpCq: 0 R: ReceiverResultReg.
	jump0 := self JumpLessOrEqual: 0.
	self MoveCq: 17 R: ReceiverResultReg.
	jump1 := self Jump: 0.
	currentBlock := self Label.
	jump0 jmpTarget: currentBlock.
	self MoveCq: 42 R: ReceiverResultReg.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	self RetN: 1 * objectMemory wordSize.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_bytecodePopOnTwoBranches [
	"AutoGenerated by Druid"

	| t0 jump1 s2 currentBlock t1 jump2 live |
	live := 0.
	self annotateBytecode: self Label.
	t0 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t0).
	(self ssValue: 0) copyToReg: t0.
	self CmpCq: 0 R: t0.
	jump1 := self JumpLessOrEqual: 0.
	(self ssValue: 0) copyToReg: t0.
	self ssPop: 1.
	t1 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t1).
	self MoveR: t0 R: t1.
	jump2 := self Jump: 0.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	(self ssValue: 0) copyToReg: t1.
	self ssPop: 1.
	currentBlock := self Label.
	jump2 jmpTarget: currentBlock.
	self ssPushRegister: t1.
	^ 0
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_bytecodePrimAdd [
	"AutoGenerated by Druid"

	| live currentBlock |
	live := 0.
	self marshallSendArguments: 1.
	self
		genMarshalledSend: -1
		numArgs: 1
		sendTable: ordinarySendTrampolines.
	^ 0
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_bytecodePrimIdenticalSistaV1 [
	"AutoGenerated by Druid"

	| jump1 s57 s54 t1 jump6 jump3 currentBlock t0 jump5 jump2 b498 b502 live t2 jump4 |
	live := 0.
	t0 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t0).
	(self ssValue: 1) copyToReg: t0.
	t1 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t1).
	(self ssValue: 0) copyToReg: t1.
	t2 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t2).
	self MoveR: t0 R: t2.
	self AndCq: 7 R: t2.
	self CmpCq: 0 R: t2.
	jump1 := self JumpNonZero: 0.
	self MoveM64: 0 r: t0 R: t2.
	self AndCq: 16r3FFFF7 R: t2.
	self CmpCq: 0 R: t2.
	jump2 := self JumpNonZero: 0.
	self MoveM64: 8 r: t0 R: t2.
	b502 := self Label.
	self MoveR: t2 R: t0.
	self AndCq: 7 R: t0.
	self CmpCq: 0 R: t0.
	jump3 := self JumpNonZero: 0.
	self MoveM64: 0 r: t2 R: t0.
	self AndCq: 16r3FFFF7 R: t0.
	self CmpCq: 0 R: t0.
	jump4 := self JumpNonZero: 0.
	self MoveM64: 8 r: t2 R: t0.
	self MoveR: t0 R: t2.
	jump5 := self Jump: b502.
	currentBlock := self Label.
	jump3 jmpTarget: currentBlock.
	jump4 jmpTarget: currentBlock.
	self MoveR: t2 R: t0.
	jump4 := self Jump: 0.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	jump2 jmpTarget: currentBlock.
	currentBlock := self Label.
	jump4 jmpTarget: currentBlock.
	self MoveR: t1 R: t2.
	self AndCq: 7 R: t2.
	self CmpCq: 0 R: t2.
	jump4 := self JumpNonZero: 0.
	self MoveM64: 0 r: t1 R: t2.
	self AndCq: 16r3FFFF7 R: t2.
	self CmpCq: 0 R: t2.
	jump2 := self JumpNonZero: 0.
	self MoveM64: 8 r: t1 R: t2.
	b498 := self Label.
	self MoveR: t2 R: t1.
	self AndCq: 7 R: t1.
	self CmpCq: 0 R: t1.
	jump1 := self JumpNonZero: 0.
	self MoveM64: 0 r: t2 R: t1.
	self AndCq: 16r3FFFF7 R: t1.
	self CmpCq: 0 R: t1.
	jump3 := self JumpNonZero: 0.
	self MoveM64: 8 r: t2 R: t1.
	self MoveR: t1 R: t2.
	jump6 := self Jump: b498.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	jump3 jmpTarget: currentBlock.
	self MoveR: t2 R: t1.
	jump3 := self Jump: 0.
	currentBlock := self Label.
	jump4 jmpTarget: currentBlock.
	jump2 jmpTarget: currentBlock.
	currentBlock := self Label.
	jump3 jmpTarget: currentBlock.
	self ssPop: 2.
	self CmpR: t1 R: t0.
	jump3 := self JumpNonZero: 0.
	s54 := objectMemory trueObject.
	self MoveCq: s54 R: t1.
	jump2 := self Jump: 0.
	currentBlock := self Label.
	jump3 jmpTarget: currentBlock.
	s57 := objectMemory falseObject.
	self MoveCq: s57 R: t1.
	currentBlock := self Label.
	jump2 jmpTarget: currentBlock.
	self CmpCq: 0 R: t1.
	jump2 := self JumpNonZero: 0.
	jump3 := self Jump: 0.
	currentBlock := self Label.
	jump2 jmpTarget: currentBlock.
	self ssPushRegister: t1.
	currentBlock := self Label.
	jump3 jmpTarget: currentBlock.
	^ 0
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_bytecodePrimNotIdenticalSistaV1 [
	"AutoGenerated by Druid"

	| jump1 s57 s54 t1 jump6 jump3 currentBlock t0 jump5 jump2 b498 b502 live t2 jump4 |
	live := 0.
	t0 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t0).
	(self ssValue: 1) copyToReg: t0.
	t1 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t1).
	(self ssValue: 0) copyToReg: t1.
	t2 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t2).
	self MoveR: t0 R: t2.
	self AndCq: 7 R: t2.
	self CmpCq: 0 R: t2.
	jump1 := self JumpNonZero: 0.
	self MoveM64: 0 r: t0 R: t2.
	self AndCq: 16r3FFFF7 R: t2.
	self CmpCq: 0 R: t2.
	jump2 := self JumpNonZero: 0.
	self MoveM64: 8 r: t0 R: t2.
	b502 := self Label.
	self MoveR: t2 R: t0.
	self AndCq: 7 R: t0.
	self CmpCq: 0 R: t0.
	jump3 := self JumpNonZero: 0.
	self MoveM64: 0 r: t2 R: t0.
	self AndCq: 16r3FFFF7 R: t0.
	self CmpCq: 0 R: t0.
	jump4 := self JumpNonZero: 0.
	self MoveM64: 8 r: t2 R: t0.
	self MoveR: t0 R: t2.
	jump5 := self Jump: b502.
	currentBlock := self Label.
	jump3 jmpTarget: currentBlock.
	jump4 jmpTarget: currentBlock.
	self MoveR: t2 R: t0.
	jump4 := self Jump: 0.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	jump2 jmpTarget: currentBlock.
	currentBlock := self Label.
	jump4 jmpTarget: currentBlock.
	self MoveR: t1 R: t2.
	self AndCq: 7 R: t2.
	self CmpCq: 0 R: t2.
	jump4 := self JumpNonZero: 0.
	self MoveM64: 0 r: t1 R: t2.
	self AndCq: 16r3FFFF7 R: t2.
	self CmpCq: 0 R: t2.
	jump2 := self JumpNonZero: 0.
	self MoveM64: 8 r: t1 R: t2.
	b498 := self Label.
	self MoveR: t2 R: t1.
	self AndCq: 7 R: t1.
	self CmpCq: 0 R: t1.
	jump1 := self JumpNonZero: 0.
	self MoveM64: 0 r: t2 R: t1.
	self AndCq: 16r3FFFF7 R: t1.
	self CmpCq: 0 R: t1.
	jump3 := self JumpNonZero: 0.
	self MoveM64: 8 r: t2 R: t1.
	self MoveR: t1 R: t2.
	jump6 := self Jump: b498.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	jump3 jmpTarget: currentBlock.
	self MoveR: t2 R: t1.
	jump3 := self Jump: 0.
	currentBlock := self Label.
	jump4 jmpTarget: currentBlock.
	jump2 jmpTarget: currentBlock.
	currentBlock := self Label.
	jump3 jmpTarget: currentBlock.
	self ssPop: 2.
	self CmpR: t1 R: t0.
	jump3 := self JumpZero: 0.
	s54 := objectMemory trueObject.
	self MoveCq: s54 R: t1.
	jump2 := self Jump: 0.
	currentBlock := self Label.
	jump3 jmpTarget: currentBlock.
	s57 := objectMemory falseObject.
	self MoveCq: s57 R: t1.
	currentBlock := self Label.
	jump2 jmpTarget: currentBlock.
	self CmpCq: 0 R: t1.
	jump2 := self JumpNonZero: 0.
	jump3 := self Jump: 0.
	currentBlock := self Label.
	jump2 jmpTarget: currentBlock.
	self ssPushRegister: t1.
	currentBlock := self Label.
	jump3 jmpTarget: currentBlock.
	^ 0
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_bytecodePushOnTwoBranches [
	"AutoGenerated by Druid"

	| t0 jump1 s2 currentBlock jump2 live |
	live := 0.
	self annotateBytecode: self Label.
	t0 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t0).
	(self ssValue: 0) copyToReg: t0.
	self CmpCq: 0 R: t0.
	jump1 := self JumpLessOrEqual: 0.
	self ssPushConstant: 1.
	jump2 := self Jump: 0.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	self ssPushConstant: 2.
	currentBlock := self Label.
	jump2 jmpTarget: currentBlock.
	^ 0
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_bytecodeTwoPopOnTwoBranches [
	"AutoGenerated by Druid"

	| t0 jump1 s2 currentBlock t1 jump2 live t2 |
	live := 0.
	self annotateBytecode: self Label.
	t0 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t0).
	(self ssValue: 0) copyToReg: t0.
	self CmpCq: 0 R: t0.
	jump1 := self JumpLessOrEqual: 0.
	(self ssValue: 0) copyToReg: t0.
	self ssPop: 1.
	t1 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t1).
	(self ssValue: 0) copyToReg: t1.
	self ssPop: 1.
	t2 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t2).
	self MoveR: t0 R: t2.
	jump2 := self Jump: 0.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	(self ssValue: 0) copyToReg: t1.
	self ssPop: 1.
	(self ssValue: 0) copyToReg: t0.
	self ssPop: 1.
	self MoveR: t1 R: t2.
	self MoveR: t0 R: t1.
	currentBlock := self Label.
	jump2 jmpTarget: currentBlock.
	self AddR: t1 R: t2.
	self ssPushRegister: t2.
	^ 0
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_bytecodeTwoPushOnTwoBranches [
	"AutoGenerated by Druid"

	| t0 jump1 s2 currentBlock t1 jump2 live |
	live := 0.
	self annotateBytecode: self Label.
	t0 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t0).
	(self ssValue: 0) copyToReg: t0.
	self ssPop: 1.
	self CmpCq: 0 R: t0.
	jump1 := self JumpLessOrEqual: 0.
	self ssPushConstant: 1.
	self ssPushConstant: 2.
	jump2 := self Jump: 0.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	self ssPushConstant: 3.
	self ssPushConstant: 4.
	currentBlock := self Label.
	jump2 jmpTarget: currentBlock.
	t1 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t1).
	(self ssValue: 0) copyToReg: t1.
	self ssPop: 1.
	(self ssValue: 0) copyToReg: t0.
	self ssPop: 1.
	self AddR: t0 R: t1.
	self ssPushRegister: t1.
	^ 0
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_bytecodeWithDeoptimisation [
	"AutoGenerated by Druid"

	| live currentBlock |
	live := 0.
	self ssFlushStack.
	self deoptimize.
	^ 0
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_bytecodeWithFlushStackOnDominator [
	"AutoGenerated by Druid"

	| t0 jump1 s2 currentBlock jump2 live |
	live := 0.
	self annotateBytecode: self Label.
	t0 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t0).
	(self ssValue: 0) copyToReg: t0.
	self ssFlushStack.
	self CmpCq: 0 R: t0.
	jump1 := self JumpLessOrEqual: 0.
	self deoptimize.
	jump2 := self Jump: 0.
	deadCode := false.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	(self ssValue: 0) copyToReg: t0.
	self MoveR: t0 R: TempReg.
	self CallRT: ceSendMustBeBooleanTrampoline.
	currentBlock := self Label.
	jump2 jmpTarget: currentBlock.
	^ 0
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_bytecodeWithPop [
	"AutoGenerated by Druid"

	| live currentBlock |
	live := 0.
	self ssPop: 1.
	^ 0
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_bytecodeWithUnknownBytecodeSend [
	"AutoGenerated by Druid"

	| live currentBlock |
	live := 0.
	self deoptimize.
	^ 0
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_duplicateTopBytecode [
	"AutoGenerated by Druid"

	| live currentBlock t0 |
	live := 0.
	t0 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t0).
	(self ssValue: 0) copyToReg: t0.
	self ssPushRegister: t0.
	^ 0
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_emptyPrimitive [
	"AutoGenerated by Druid"

	| currentBlock |
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_emptyPrimitiveWithArguments [
	"AutoGenerated by Druid"

	| currentBlock |
	self MoveR: Arg0Reg R: ClassReg.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_extBBytecode [
	"AutoGenerated by Druid"

	| s6 s3 s16 s13 s22 s25 s8 s2 currentBlock s12 s21 s24 s4 s17 s14 live s20 s9 |
	live := 0.
	s2 := byte1.
	s3 := numExtB.
	s3 = 0 ifTrue: [
		s2 > 127 ifTrue: [
			s6 := s2 - 256.
			extB := s6.
			s8 := numExtB.
			s9 := s8 + 1.
			numExtB := s9.
			^ 0 ].
		s12 := extB.
		s13 := s12 << 8.
		s14 := s13 + s2.
		extB := s14.
		s16 := numExtB.
		s17 := s16 + 1.
		numExtB := s17.
		^ 0 ].
	s20 := extB.
	s21 := s20 << 8.
	s22 := s21 + s2.
	extB := s22.
	s24 := numExtB.
	s25 := s24 + 1.
	numExtB := s25.
	^ 0
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_extPushFullClosureBytecode [
	"AutoGenerated by Druid"

	| s4 s38 t3 s9 s2 s20 currentBlock t1 s19 s12 s7 b10 live s5 s39 s15 s3 s21 t2 s8 s26 t0 s18 s11 |
	live := 0.
	s2 := byte1.
	s3 := extA.
	s4 := s3 << 8.
	s5 := s2 + s4.
	extA := 0.
	s7 := byte2.
	s8 := s7 bitAnd: 63.
	s9 := s7 anyMask: 64.
	live := live bitOr: (self registerMaskFor: ReceiverResultReg).
	live := live bitOr: (self registerMaskFor: SendNumArgsReg).
	live := live bitOr: (self registerMaskFor: ClassReg).
	self voidReceiverResultRegContainsSelf.
	self
		ssAllocateCallReg: ReceiverResultReg
		and: SendNumArgsReg
		and: ClassReg.
	self
		genCreateFullClosureInIndex: s5
		numCopied: s8
		ignoreContext: s9
		contextNumArgs: methodOrBlockNumArgs
		large: (coInterpreter methodNeedsLargeContext: methodObj)
		inBlock: inBlock
		intoRegister: ReceiverResultReg.
	t0 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t0).
	self MoveR: ReceiverResultReg R: t0.
	s11 := 1.
	s12 := s11.
	b10 := self Label.
	t1 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t1).
	t2 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t2).
	t3 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t3).
	[ ((s12<=s8)) ] whileTrue: [
		(self ssValue: 0) copyToReg: t1.
		self ssPop: 1.
		s18 := FullClosureFirstCopiedValueIndex.
		s19 := s18 + s8.
		s20 := s19 - s12.
		s21 := s20 << 3.
		self MoveCq: s21 R: t2.
		self MoveR: t0 R: t3.
		self AddR: t2 R: t3.
		self MoveR: t1 M64: 8 r: t3.
		s26 := s12 + 1.
		s12 := s26 ].
	(s7 anyMask: 128) ifTrue: [
		(self ssValue: 0) copyToReg: t3.
		self ssPop: 1.
		self MoveR: t3 R: t2.
		s38 := FullClosureReceiverIndex.
		s39 := s38 << 3.
		self MoveCq: s39 R: t3.
		self MoveR: t0 R: t1.
		self AddR: t3 R: t1.
		self MoveR: t2 M64: 8 r: t1.
		self ssPushRegister: t0.
		^ 0 ].
	self ensureReceiverResultRegContainsSelf.
	self MoveR: ReceiverResultReg R: t2.
	s38 := FullClosureReceiverIndex.
	s39 := s38 << 3.
	self MoveCq: s39 R: t3.
	self MoveR: t0 R: t1.
	self AddR: t3 R: t1.
	self MoveR: t2 M64: 8 r: t1.
	self ssPushRegister: t0.
	^ 0
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_extPushIntegerBytecode [
	"AutoGenerated by Druid"

	| s5 s8 s4 s2 currentBlock s9 s10 live s3 |
	live := 0.
	s2 := byte1.
	s3 := extB.
	s4 := s3 << 8.
	s5 := s2 + s4.
	extB := 0.
	numExtB := 0.
	s8 := s2 + s4.
	s9 := s8 << 3.
	s10 := s9 + 1.
	self ssPushConstant: s10.
	^ 0
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_extSendSuperBytecode [
	"AutoGenerated by Druid"

	| s6 s3 s16 s25 s10 s22 s8 s5 s2 s18 currentBlock s15 s24 s4 s17 live s23 s9 |
	live := 0.
	s2 := byte1.
	s3 := s2 >> 3.
	s4 := extA.
	s5 := s4 << 5.
	s6 := s3 + s5.
	extA := 0.
	s8 := BytecodeSetHasDirectedSuperSend.
	s8 ifTrue: [
		s10 := extB.
		s10 >= 64 ifTrue: [
			self ssFlushStack.
			self deoptimize.
			^ 0 ].
		s15 := s2 bitAnd: 7.
		s16 := extB.
		s17 := s16 << 3.
		s18 := s15 + s17.
		self marshallSendArguments: s18.
		self
			genMarshalledSend: s6
			numArgs: s18
			sendTable: superSendTrampolines.
		^ 0 ].
	s22 := s2 bitAnd: 7.
	s23 := extB.
	s24 := s23 << 3.
	s25 := s22 + s24.
	extB := 0.
	numExtB := 0.
	self marshallSendArguments: s25.
	self
		genMarshalledSend: s6
		numArgs: s25
		sendTable: superSendTrampolines.
	^ 0
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_extStoreLiteralVariableBytecode [
	"AutoGenerated by Druid"

	| jump6 t2 s94 jump7 s82 s103 jump8 s96 s58 jump9 s107 s2 jumpTrue s3 s88 s47 s4 s60 s5 live s36 s6 b623 s77 s10 s111 s11 s50 s12 jump1 jump2 jump3 jump4 t0 currentBlock s100 jump5 t1 jumpNext s55 |
	live := 0.
	self annotateBytecode: self Label.
	s3 := byte1.
	s4 := extA.
	s5 := s4 << 8.
	s6 := s3 + s5.
	extA := 0.
	t0 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t0).
	(self ssValue: 0) copyToReg: t0.
	t1 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t1).
	self genMoveConstant: methodObj R: t1.
	s10 := LiteralStart.
	s11 := s6 + s10.
	s12 := s11 << 3.
	self AddCq: s12 R: t1.
	self MoveM64: 8 r: t1 R: t1.
	t2 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t2).
	self MoveM64: 0 r: t1 R: t2.
	self AndCq: 16r3FFFF7 R: t2.
	self CmpCq: 0 R: t2.
	jump1 := self JumpNonZero: 0.
	self MoveM64: 8 r: t1 R: t2.
	b623 := self Label.
	self MoveR: t2 R: t1.
	self AndCq: 7 R: t1.
	self CmpCq: 0 R: t1.
	jump2 := self JumpNonZero: 0.
	self MoveM64: 0 r: t2 R: t1.
	self AndCq: 16r3FFFF7 R: t1.
	self CmpCq: 0 R: t1.
	jump3 := self JumpNonZero: 0.
	self MoveM64: 8 r: t2 R: t1.
	self MoveR: t1 R: t2.
	jump4 := self Jump: b623.
	currentBlock := self Label.
	jump2 jmpTarget: currentBlock.
	jump3 jmpTarget: currentBlock.
	self MoveR: t2 R: t1.
	jump3 := self Jump: 0.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	currentBlock := self Label.
	jump3 jmpTarget: currentBlock.
	s36 := ValueIndex.
	self MoveM64: 0 r: t1 R: t2.
	self LogicalShiftRightCq: 23 R: t2.
	self AndCq: 1 R: t2.
	self ssFlushStack.
	self CmpCq: 0 R: t2.
	jump3 := self JumpZero: 0.
	self deoptimize.
	jump1 := self Jump: 0.
	deadCode := false.
	currentBlock := self Label.
	jump3 jmpTarget: currentBlock.
	self MoveR: t1 R: t2.
	self AndCq: 7 R: t2.
	self CmpCq: 0 R: t2.
	jump3 := self JumpNonZero: 0.
	s47 := objectMemory getMemoryMap getSpaceMaskToUse.
	self MoveR: t1 R: t2.
	self AndCq: s47 R: t2.
	s50 := objectMemory getMemoryMap getOldSpaceMask.
	self CmpCq: s50 R: t2.
	jump2 := self JumpNonZero: 0.
	self MoveR: t0 R: t2.
	self AndCq: 7 R: t2.
	self CmpCq: 0 R: t2.
	jump5 := self JumpNonZero: 0.
	s55 := objectMemory getMemoryMap getSpaceMaskToUse.
	self MoveR: t0 R: t2.
	self AndCq: s55 R: t2.
	s58 := objectMemory getMemoryMap getNewSpaceMask.
	self CmpCq: s58 R: t2.
	jump6 := self JumpNonZero: 0.
	s60 := objectMemory getMemoryMap getNewSpaceStart.
	self MoveR: t0 R: t2.
	self CmpCq: s60 R: t2.
	jumpTrue := self JumpAboveOrEqual: 0.
	self MoveCq: 0 R: t2.
	jumpNext := self Jump: 0.
	jumpTrue jmpTarget: self Label.
	self MoveCq: 1 R: t2.
	jumpNext jmpTarget: self Label.
	self CmpCq: 1 R: t2.
	jump7 := self JumpNonZero: 0.
	self MoveM64: 0 r: t1 R: t2.
	self LogicalShiftRightCq: 29 R: t2.
	self AndCq: 1 R: t2.
	self CmpCq: 0 R: t2.
	jump8 := self JumpNonZero: 0.
	self MoveR: t1 R: TempReg.
	backEnd saveAndRestoreLinkRegAround: [
		self CallRT: ceStoreCheckTrampoline ].
	jump9 := self Jump: 0.
	currentBlock := self Label.
	jump6 jmpTarget: currentBlock.
	currentBlock := self Label.
	jump3 jmpTarget: currentBlock.
	jump2 jmpTarget: currentBlock.
	jump5 jmpTarget: currentBlock.
	jump7 jmpTarget: currentBlock.
	jump8 jmpTarget: currentBlock.
	jump9 jmpTarget: currentBlock.
	self MoveM64: 0 r: t1 R: t2.
	self LogicalShiftRightCq: 29 R: t2.
	self AndCq: 1 R: t2.
	self CmpCq: 0 R: t2.
	jump9 := self JumpZero: 0.
	s77 := s36 << 3.
	self AddCq: s77 R: t1.
	self MoveR: t0 M64: 8 r: t1.
	jump8 := self Jump: 0.
	currentBlock := self Label.
	jump9 jmpTarget: currentBlock.
	self TstCq: 7 R: t0.
	jump9 := self JumpZero: 0.
	s82 := s36 << 3.
	self AddCq: s82 R: t1.
	self MoveR: t0 M64: 8 r: t1.
	jump7 := self Jump: 0.
	currentBlock := self Label.
	jump9 jmpTarget: currentBlock.
	self CmpCq: 16r20000000000 R: t1.
	jump9 := self JumpBelow: 0.
	self CmpCq: 16r20000000000 R: t0.
	jump5 := self JumpLess: 0.
	s88 := s36 << 3.
	self AddCq: s88 R: t1.
	self MoveR: t0 M64: 8 r: t1.
	jump2 := self Jump: 0.
	currentBlock := self Label.
	jump5 jmpTarget: currentBlock.
	self genMoveConstant: objectMemory nilObject R: t2.
	self CmpR: t2 R: t0.
	jump5 := self JumpBelow: 0.
	s94 := objectMemory trueObject.
	self CmpCq: s94 R: t0.
	jump3 := self JumpAbove: 0.
	s96 := s36 << 3.
	self AddCq: s96 R: t1.
	self MoveR: t0 M64: 8 r: t1.
	jump6 := self Jump: 0.
	currentBlock := self Label.
	jump5 jmpTarget: currentBlock.
	jump3 jmpTarget: currentBlock.
	s100 := objectMemory getMemoryMap getNewSpaceStart.
	self CmpCq: s100 R: t0.
	jump3 := self JumpBelow: 0.
	self MoveR: t1 R: TempReg.
	backEnd saveAndRestoreLinkRegAround: [
		self CallRT: ceStoreCheckTrampoline ].
	s103 := s36 << 3.
	self AddCq: s103 R: t1.
	self MoveR: t0 M64: 8 r: t1.
	jump5 := self Jump: 0.
	currentBlock := self Label.
	jump3 jmpTarget: currentBlock.
	s107 := s36 << 3.
	self AddCq: s107 R: t1.
	self MoveR: t0 M64: 8 r: t1.
	jump3 := self Jump: 0.
	currentBlock := self Label.
	jump9 jmpTarget: currentBlock.
	s111 := s36 << 3.
	self AddCq: s111 R: t1.
	self MoveR: t0 M64: 8 r: t1.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	jump8 jmpTarget: currentBlock.
	jump7 jmpTarget: currentBlock.
	jump2 jmpTarget: currentBlock.
	jump6 jmpTarget: currentBlock.
	jump5 jmpTarget: currentBlock.
	jump3 jmpTarget: currentBlock.
	^ 0
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_extStoreReceiverVariableBytecode [
	"AutoGenerated by Druid"

	| s6 jump5 s33 s81 s46 s4 s77 jump3 s44 s69 s14 s2 s75 s36 currentBlock s58 s9 s84 t1 s89 jump1 jump6 live s5 jump4 s93 s63 s3 t2 jump9 jump2 jump7 t0 s41 |
	live := 0.
	self annotateBytecode: self Label.
	s3 := byte1.
	s4 := extA.
	s5 := s4 << 8.
	s6 := s3 + s5.
	t0 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t0).
	(self ssValue: 0) copyToReg: t0.
	self ensureReceiverResultRegContainsSelf.
	t1 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t1).
	self MoveR: ReceiverResultReg R: t1.
	s9 := ReceiverIndex.
	self ssFlushStack.
	t2 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t2).
	s6 <= s9 ifTrue: [
		| jump7 jump5 jump3 jump1 jump8 jump6 jump4 jump2 jump9 |
		self MoveM64: 0 r: t1 R: t2.
		self AndCq: 16r3FFFFF R: t2.
		s14 := ClassMethodContextCompactIndex.
		self CmpCq: s14 R: t2.
		jump1 := self JumpNonZero: 0.
		self deoptimize.
		jump2 := self Jump: 0.
		deadCode := false.
		currentBlock := self Label.
		jump1 jmpTarget: currentBlock.
		self MoveM64: 0 r: t1 R: t2.
		self LogicalShiftRightCq: 23 R: t2.
		self AndCq: 1 R: t2.
		self CmpCq: 0 R: t2.
		jump1 := self JumpZero: 0.
		self deoptimize.
		jump3 := self Jump: 0.
		deadCode := false.
		currentBlock := self Label.
		jump1 jmpTarget: currentBlock.
		self MoveR: t1 R: t2.
		self AndCq: 7 R: t2.
		self CmpCq: 0 R: t2.
		jump1 := self JumpNonZero: 0.
		s33 := objectMemory getMemoryMap getSpaceMaskToUse.
		self MoveR: t1 R: t2.
		self AndCq: s33 R: t2.
		s36 := objectMemory getMemoryMap getOldSpaceMask.
		self CmpCq: s36 R: t2.
		jump4 := self JumpNonZero: 0.
		self MoveR: t0 R: t2.
		self AndCq: 7 R: t2.
		self CmpCq: 0 R: t2.
		jump5 := self JumpNonZero: 0.
		s41 := objectMemory getMemoryMap getSpaceMaskToUse.
		self MoveR: t0 R: t2.
		self AndCq: s41 R: t2.
		s44 := objectMemory getMemoryMap getNewSpaceMask.
		self CmpCq: s44 R: t2.
		jump6 := self JumpNonZero: 0.
		s46 := objectMemory getMemoryMap getNewSpaceStart.
		self CmpCq: s46 R: t0.
		jump7 := self JumpBelow: 0.
		self MoveM64: 0 r: t1 R: t2.
		self LogicalShiftRightCq: 29 R: t2.
		self AndCq: 1 R: t2.
		self CmpCq: 0 R: t2.
		jump8 := self JumpNonZero: 0.
		self MoveR: t1 R: TempReg.
		backEnd saveAndRestoreLinkRegAround: [
			self CallRT: ceStoreCheckTrampoline ].
		currentBlock := self Label.
		jump1 jmpTarget: currentBlock.
		jump4 jmpTarget: currentBlock.
		jump5 jmpTarget: currentBlock.
		jump6 jmpTarget: currentBlock.
		jump7 jmpTarget: currentBlock.
		jump8 jmpTarget: currentBlock.
		self MoveM64: 0 r: t1 R: t2.
		self LogicalShiftRightCq: 29 R: t2.
		self AndCq: 1 R: t2.
		self CmpCq: 0 R: t2.
		jump8 := self JumpZero: 0.
		s58 := s6 << 3.
		self AddCq: s58 R: t1.
		self MoveR: t0 M64: 8 r: t1.
		jump7 := self Jump: 0.
		currentBlock := self Label.
		jump8 jmpTarget: currentBlock.
		self TstCq: 7 R: t0.
		jump8 := self JumpZero: 0.
		s63 := s6 << 3.
		self AddCq: s63 R: t1.
		self MoveR: t0 M64: 8 r: t1.
		jump6 := self Jump: 0.
		currentBlock := self Label.
		jump8 jmpTarget: currentBlock.
		self CmpCq: 16r20000000000 R: t1.
		jump8 := self JumpLess: 0.
		self CmpCq: 16r20000000000 R: t0.
		jump5 := self JumpLess: 0.
		s69 := s6 << 3.
		self AddCq: s69 R: t1.
		self MoveR: t0 M64: 8 r: t1.
		jump4 := self Jump: 0.
		currentBlock := self Label.
		jump5 jmpTarget: currentBlock.
		self genMoveConstant: objectMemory nilObject R: t2.
		self CmpR: t2 R: t0.
		jump5 := self JumpBelow: 0.
		s75 := objectMemory trueObject.
		self CmpCq: s75 R: t0.
		jump1 := self JumpAbove: 0.
		s77 := s6 << 3.
		self AddCq: s77 R: t1.
		self MoveR: t0 M64: 8 r: t1.
		jump9 := self Jump: 0.
		currentBlock := self Label.
		jump5 jmpTarget: currentBlock.
		jump1 jmpTarget: currentBlock.
		s81 := objectMemory getMemoryMap getNewSpaceStart.
		self CmpCq: s81 R: t0.
		jump1 := self JumpBelow: 0.
		self MoveR: t1 R: TempReg.
		backEnd saveAndRestoreLinkRegAround: [
			self CallRT: ceStoreCheckTrampoline ].
		s84 := s6 << 3.
		self AddCq: s84 R: t1.
		self MoveR: t0 M64: 8 r: t1.
		extA := 0.
		jump5 := self Jump: 0.
		currentBlock := self Label.
		jump1 jmpTarget: currentBlock.
		s89 := s6 << 3.
		self AddCq: s89 R: t1.
		self MoveR: t0 M64: 8 r: t1.
		jump1 := self Jump: 0.
		currentBlock := self Label.
		jump8 jmpTarget: currentBlock.
		s93 := s6 << 3.
		self AddCq: s93 R: t1.
		self MoveR: t0 M64: 8 r: t1.
		currentBlock := self Label.
		jump2 jmpTarget: currentBlock.
		jump3 jmpTarget: currentBlock.
		jump7 jmpTarget: currentBlock.
		jump6 jmpTarget: currentBlock.
		jump4 jmpTarget: currentBlock.
		jump9 jmpTarget: currentBlock.
		jump5 jmpTarget: currentBlock.
		jump1 jmpTarget: currentBlock.
		^ 0 ].
	self MoveM64: 0 r: t1 R: t2.
	self LogicalShiftRightCq: 23 R: t2.
	self AndCq: 1 R: t2.
	self CmpCq: 0 R: t2.
	jump1 := self JumpZero: 0.
	self deoptimize.
	jump5 := self Jump: 0.
	deadCode := false.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	self MoveR: t1 R: t2.
	self AndCq: 7 R: t2.
	self CmpCq: 0 R: t2.
	jump1 := self JumpNonZero: 0.
	s33 := objectMemory getMemoryMap getSpaceMaskToUse.
	self MoveR: t1 R: t2.
	self AndCq: s33 R: t2.
	s36 := objectMemory getMemoryMap getOldSpaceMask.
	self CmpCq: s36 R: t2.
	jump9 := self JumpNonZero: 0.
	self MoveR: t0 R: t2.
	self AndCq: 7 R: t2.
	self CmpCq: 0 R: t2.
	jump4 := self JumpNonZero: 0.
	s41 := objectMemory getMemoryMap getSpaceMaskToUse.
	self MoveR: t0 R: t2.
	self AndCq: s41 R: t2.
	s44 := objectMemory getMemoryMap getNewSpaceMask.
	self CmpCq: s44 R: t2.
	jump6 := self JumpNonZero: 0.
	s46 := objectMemory getMemoryMap getNewSpaceStart.
	self CmpCq: s46 R: t0.
	jump7 := self JumpBelow: 0.
	self MoveM64: 0 r: t1 R: t2.
	self LogicalShiftRightCq: 29 R: t2.
	self AndCq: 1 R: t2.
	self CmpCq: 0 R: t2.
	jump3 := self JumpNonZero: 0.
	self MoveR: t1 R: TempReg.
	backEnd saveAndRestoreLinkRegAround: [
		self CallRT: ceStoreCheckTrampoline ].
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	jump9 jmpTarget: currentBlock.
	jump4 jmpTarget: currentBlock.
	jump6 jmpTarget: currentBlock.
	jump7 jmpTarget: currentBlock.
	jump3 jmpTarget: currentBlock.
	self MoveM64: 0 r: t1 R: t2.
	self LogicalShiftRightCq: 29 R: t2.
	self AndCq: 1 R: t2.
	self CmpCq: 0 R: t2.
	jump3 := self JumpZero: 0.
	s58 := s6 << 3.
	self AddCq: s58 R: t1.
	self MoveR: t0 M64: 8 r: t1.
	jump7 := self Jump: 0.
	currentBlock := self Label.
	jump3 jmpTarget: currentBlock.
	self TstCq: 7 R: t0.
	jump3 := self JumpZero: 0.
	s63 := s6 << 3.
	self AddCq: s63 R: t1.
	self MoveR: t0 M64: 8 r: t1.
	jump6 := self Jump: 0.
	currentBlock := self Label.
	jump3 jmpTarget: currentBlock.
	self CmpCq: 16r20000000000 R: t1.
	jump3 := self JumpLess: 0.
	self CmpCq: 16r20000000000 R: t0.
	jump4 := self JumpLess: 0.
	s69 := s6 << 3.
	self AddCq: s69 R: t1.
	self MoveR: t0 M64: 8 r: t1.
	jump9 := self Jump: 0.
	currentBlock := self Label.
	jump4 jmpTarget: currentBlock.
	self genMoveConstant: objectMemory nilObject R: t2.
	self CmpR: t2 R: t0.
	jump4 := self JumpBelow: 0.
	s75 := objectMemory trueObject.
	self CmpCq: s75 R: t0.
	jump1 := self JumpAbove: 0.
	s77 := s6 << 3.
	self AddCq: s77 R: t1.
	self MoveR: t0 M64: 8 r: t1.
	jump2 := self Jump: 0.
	currentBlock := self Label.
	jump4 jmpTarget: currentBlock.
	jump1 jmpTarget: currentBlock.
	s81 := objectMemory getMemoryMap getNewSpaceStart.
	self CmpCq: s81 R: t0.
	jump1 := self JumpBelow: 0.
	self MoveR: t1 R: TempReg.
	backEnd saveAndRestoreLinkRegAround: [
		self CallRT: ceStoreCheckTrampoline ].
	s84 := s6 << 3.
	self AddCq: s84 R: t1.
	self MoveR: t0 M64: 8 r: t1.
	extA := 0.
	jump4 := self Jump: 0.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	s89 := s6 << 3.
	self AddCq: s89 R: t1.
	self MoveR: t0 M64: 8 r: t1.
	jump1 := self Jump: 0.
	currentBlock := self Label.
	jump3 jmpTarget: currentBlock.
	s93 := s6 << 3.
	self AddCq: s93 R: t1.
	self MoveR: t0 M64: 8 r: t1.
	currentBlock := self Label.
	jump5 jmpTarget: currentBlock.
	jump7 jmpTarget: currentBlock.
	jump6 jmpTarget: currentBlock.
	jump9 jmpTarget: currentBlock.
	jump2 jmpTarget: currentBlock.
	jump4 jmpTarget: currentBlock.
	jump1 jmpTarget: currentBlock.
	^ 0
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_extUnconditionalJump [
	"AutoGenerated by Druid"

	| s6 s33 s4 s22 s31 s38 jump3 s9 s2 s36 currentBlock t1 s42 s12 jump1 s10 s5 live s32 s23 s3 s21 s37 jump2 s43 s8 t0 s18 s41 |
	live := 0.
	self annotateBytecode: self Label.
	s3 := byte1.
	s4 := extB.
	s5 := s4 << 8.
	s6 := s3 + s5.
	t0 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t0).
	t1 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t1).
	s6 < 0 ifTrue: [
		| jump1 jump2 jump3 |
		s8 := numExtB.
		s9 := s8 << 1.
		s10 := s9.
		extB := 0.
		numExtB := 0.
		s18 := s6 + s10.
		self ssFlushStack.
		s18 >= 0 ifTrue: [
			s21 := bytecodePC.
			s22 := s21 + s6.
			s23 := s22 + 2.
			self Jump: (self ensureFixupAt: s23).
			deadCode := true.
			^ 0 ].
		self MoveR: SPReg R: t0.
		self MoveAw: coInterpreter stackLimitAddress R: t1.
		self CmpR: t1 R: t0.
		jump1 := self JumpAboveOrEqual: 0.
		self CallRT: ceCheckForInterruptTrampoline.
		self MoveR: TempReg R: t1.
		self CmpCq: 1 R: t1.
		jump2 := self JumpNonZero: 0.
		s31 := bytecodePC.
		s32 := s31 + s6.
		s33 := s32 + 2.
		self Jump: (self ensureFixupAt: s33).
		deadCode := true.
		jump3 := self Jump: 0.
		deadCode := false.
		currentBlock := self Label.
		jump2 jmpTarget: currentBlock.
		s36 := bytecodePC.
		s37 := s36 + s6.
		s38 := s37 + 2.
		self Jump: (self ensureFixupAt: s38).
		deadCode := true.
		jump2 := self Jump: 0.
		deadCode := false.
		currentBlock := self Label.
		jump1 jmpTarget: currentBlock.
		s41 := bytecodePC.
		s42 := s41 + s6.
		s43 := s42 + 2.
		self Jump: (self ensureFixupAt: s43).
		deadCode := true.
		currentBlock := self Label.
		jump3 jmpTarget: currentBlock.
		jump2 jmpTarget: currentBlock.
		^ 0 ].
	s12 := 0.
	s10 := s12.
	extB := 0.
	numExtB := 0.
	s18 := s6 + s10.
	self ssFlushStack.
	s18 >= 0 ifTrue: [
		s21 := bytecodePC.
		s22 := s21 + s6.
		s23 := s22 + 2.
		self Jump: (self ensureFixupAt: s23).
		deadCode := true.
		^ 0 ].
	self MoveR: SPReg R: t0.
	self MoveAw: coInterpreter stackLimitAddress R: t1.
	self CmpR: t1 R: t0.
	jump2 := self JumpAboveOrEqual: 0.
	self CallRT: ceCheckForInterruptTrampoline.
	self MoveR: TempReg R: t1.
	self CmpCq: 1 R: t1.
	jump3 := self JumpNonZero: 0.
	s31 := bytecodePC.
	s32 := s31 + s6.
	s33 := s32 + 2.
	self Jump: (self ensureFixupAt: s33).
	deadCode := true.
	jump1 := self Jump: 0.
	deadCode := false.
	currentBlock := self Label.
	jump3 jmpTarget: currentBlock.
	s36 := bytecodePC.
	s37 := s36 + s6.
	s38 := s37 + 2.
	self Jump: (self ensureFixupAt: s38).
	deadCode := true.
	jump3 := self Jump: 0.
	deadCode := false.
	currentBlock := self Label.
	jump2 jmpTarget: currentBlock.
	s41 := bytecodePC.
	s42 := s41 + s6.
	s43 := s42 + 2.
	self Jump: (self ensureFixupAt: s43).
	deadCode := true.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	jump3 jmpTarget: currentBlock.
	^ 0
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_extendedPushBytecode [
	"AutoGenerated by Druid"

	| s6 s46 s4 jump3 s2 s27 currentBlock s20 s19 s51 t1 s25 jump1 b325 s47 s56 live s5 jump4 s3 jump2 s52 s8 s26 t0 s18 s57 |
	live := 0.
	s2 := byte1.
	s3 := s2 >> 6.
	s4 := s3 bitAnd: 3.
	s5 := s2 bitAnd: 63.
	t0 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t0).
	s4 = 0 ifTrue: [
		self ensureReceiverResultRegContainsSelf.
		self MoveR: ReceiverResultReg R: t0.
		s8 := s5 << 3.
		self AddCq: s8 R: t0.
		self ssPushBase: t0 offset: 8.
		^ 0 ].
	s4 = 1 ifTrue: [
		(self simStackTempAt: s5) copyToReg: t0.
		self ssPushRegister: t0.
		^ 0 ].
	s4 = 2 ifTrue: [
		self genMoveConstant: methodObj R: t0.
		s18 := LiteralStart.
		s19 := s5 + s18.
		s20 := s19 << 3.
		self AddCq: s20 R: t0.
		self ssPushBase: t0 offset: 8.
		^ 0 ].
	self genMoveConstant: methodObj R: t0.
	s25 := LiteralStart.
	s26 := s5 + s25.
	s27 := s26 << 3.
	self AddCq: s27 R: t0.
	self MoveM64: 8 r: t0 R: t0.
	t1 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t1).
	self MoveM64: 0 r: t0 R: t1.
	self AndCq: 16r3FFFF7 R: t1.
	self CmpCq: 0 R: t1.
	jump1 := self JumpNonZero: 0.
	self MoveM64: 8 r: t0 R: t1.
	b325 := self Label.
	self MoveR: t1 R: t0.
	self AndCq: 7 R: t0.
	self CmpCq: 0 R: t0.
	jump2 := self JumpNonZero: 0.
	self MoveM64: 0 r: t1 R: t0.
	self AndCq: 16r3FFFF7 R: t0.
	self CmpCq: 0 R: t0.
	jump3 := self JumpNonZero: 0.
	self MoveM64: 8 r: t1 R: t0.
	self MoveR: t0 R: t1.
	jump4 := self Jump: b325.
	currentBlock := self Label.
	jump3 jmpTarget: currentBlock.
	s46 := ValueIndex.
	s47 := s46 << 3.
	self AddCq: s47 R: t1.
	self ssPushBase: t1 offset: 8.
	jump3 := self Jump: 0.
	currentBlock := self Label.
	jump2 jmpTarget: currentBlock.
	s51 := ValueIndex.
	s52 := s51 << 3.
	self AddCq: s52 R: t1.
	self ssPushBase: t1 offset: 8.
	jump2 := self Jump: 0.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	s56 := ValueIndex.
	s57 := s56 << 3.
	self AddCq: s57 R: t0.
	self ssPushBase: t0 offset: 8.
	currentBlock := self Label.
	jump3 jmpTarget: currentBlock.
	jump2 jmpTarget: currentBlock.
	^ 0
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_failingPrimitive [
	"AutoGenerated by Druid"

	| currentBlock |
	^ 0
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_failingPrimitive2 [

	| currentBlock |
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_failingPrimitiveWithArg [
	"AutoGenerated by Druid"

	| currentBlock |
	self MoveR: Arg0Reg R: ClassReg.
	^ 0
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_failingSuccess [
	"AutoGenerated by Druid"

	| currentBlock |
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_ifZeroFailPrimitive [
	"AutoGenerated by Druid"

	| jump1 currentBlock |
	self MoveR: ReceiverResultReg R: ClassReg.
	self MoveR: Arg0Reg R: SendNumArgsReg.
	self CmpCq: 0 R: ClassReg.
	jump1 := self JumpZero: 0.
	self MoveCq: 42 R: ReceiverResultReg.
	self genPrimReturn.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	^ 0
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_passingSuccess [
	"AutoGenerated by Druid"

	| currentBlock |
	self MoveCq: 1 R: ReceiverResultReg.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveAccessTempAfterCall [
	"AutoGenerated by Druid"

	| currentBlock |
	self MoveCq: 17 R: ReceiverResultReg.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveAdd [
	"AutoGenerated by Druid"

	| jump1 jump2 currentBlock |
	self mclassIsSmallInteger ifFalse: [ ^ UnimplementedPrimitive ].
	self MoveR: ReceiverResultReg R: ClassReg.
	self MoveR: Arg0Reg R: SendNumArgsReg.
	self TstCq: 1 R: SendNumArgsReg.
	jump1 := self JumpZero: 0.
	self AddCq:  -1 R: SendNumArgsReg.
	self AddR: ClassReg R: SendNumArgsReg.
	jump2 := self JumpOverflow: 0.
	self MoveR: SendNumArgsReg R: ReceiverResultReg.
	self genPrimReturn.
	currentBlock := self Label.
	jump2 jmpTarget: currentBlock.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	^ 0
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveAnd [
	"AutoGenerated by Druid"

	| jump1 jump2 currentBlock |
	self MoveR: ReceiverResultReg R: ClassReg.
	self CmpCq: 0 R: ClassReg.
	jump1 := self JumpLessOrEqual: 0.
	self CmpCq: 10 R: ClassReg.
	jump2 := self JumpLessOrEqual: 0.
	self MoveCq: 42 R: ReceiverResultReg.
	self genPrimReturn.
	currentBlock := self Label.
	jump2 jmpTarget: currentBlock.
	self MoveCq: 10 R: ReceiverResultReg.
	self genPrimReturn.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	self MoveCq: 10 R: ReceiverResultReg.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveAndIfTrue [
	"AutoGenerated by Druid"

	| jump1 jump2 currentBlock |
	self MoveR: ReceiverResultReg R: ClassReg.
	self CmpCq: 1 R: ClassReg.
	jump1 := self JumpLessOrEqual: 0.
	self AndCq: 1 R: ClassReg.
	self CmpCq: 1 R: ClassReg.
	jump2 := self JumpNonZero: 0.
	self MoveCq: 1 R: ReceiverResultReg.
	self genPrimReturn.
	currentBlock := self Label.
	jump2 jmpTarget: currentBlock.
	self MoveCq: 2 R: ReceiverResultReg.
	self genPrimReturn.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	self MoveCq: 2 R: ReceiverResultReg.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveArithmeticBitShiftRight [
	"AutoGenerated by Druid"

	| currentBlock |
	self MoveR: ReceiverResultReg R: ClassReg.
	self MoveR: Arg0Reg R: SendNumArgsReg.
	self ArithmeticShiftRightR: SendNumArgsReg R: ClassReg.
	self MoveR: ClassReg R: ReceiverResultReg.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveAsCharacter [
	"AutoGenerated by Druid"

	| s3 s16 currentBlock s2 |
	s2 := self methodNumArgs.
	s2 = 0 ifTrue: [
		| jump1 jump2 jump3 |
		self MoveR: ReceiverResultReg R: ClassReg.
		self TstCq: 1 R: ClassReg.
		jump1 := self JumpZero: 0.
		self ArithmeticShiftRightCq: 3 R: ClassReg.
		self CmpCq: 0 R: ClassReg.
		jump2 := self JumpLess: 0.
		self CmpCq: 16r3FFFFFFF R: ClassReg.
		jump3 := self JumpGreater: 0.
		self LogicalShiftLeftCq: 3 R: ClassReg.
		self AddCq: 2 R: ClassReg.
		self MoveR: ClassReg R: ReceiverResultReg.
		self genPrimReturn.
		currentBlock := self Label.
		jump3 jmpTarget: currentBlock.
		currentBlock := self Label.
		jump2 jmpTarget: currentBlock.
		currentBlock := self Label.
		jump1 jmpTarget: currentBlock.
		^ 0 ].
	s16 := self methodNumArgs.
	s16 = 1 ifTrue: [
		| jump1 jump2 jump3 |
		self MoveR: Arg0Reg R: ClassReg.
		self TstCq: 1 R: ClassReg.
		jump1 := self JumpZero: 0.
		self ArithmeticShiftRightCq: 3 R: ClassReg.
		self CmpCq: 0 R: ClassReg.
		jump2 := self JumpLess: 0.
		self CmpCq: 16r3FFFFFFF R: ClassReg.
		jump3 := self JumpGreater: 0.
		self LogicalShiftLeftCq: 3 R: ClassReg.
		self AddCq: 2 R: ClassReg.
		self MoveR: ClassReg R: ReceiverResultReg.
		self genPrimReturn.
		currentBlock := self Label.
		jump3 jmpTarget: currentBlock.
		currentBlock := self Label.
		jump2 jmpTarget: currentBlock.
		currentBlock := self Label.
		jump1 jmpTarget: currentBlock.
		^ 0 ].
	^ 0
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveAsFloat [
	"AutoGenerated by Druid"

	| jump5 s30 jump1 jump3 s33 currentBlock jump2 jump4 |
	self MoveR: ReceiverResultReg R: ClassReg.
	self ArithmeticShiftRightCq: 3 R: ClassReg.
	self ConvertR: ClassReg Rd: DPFPReg0.
	self MoveRd: DPFPReg0 R: ClassReg.
	self MoveR: ClassReg R: SendNumArgsReg.
	self LogicalShiftRightCq: 52 R: SendNumArgsReg.
	self AndCq: 2047 R: SendNumArgsReg.
	self CmpCq: 896 R: SendNumArgsReg.
	jump1 := self JumpBelowOrEqual: 0.
	self CmpCq: 1151 R: SendNumArgsReg.
	jump2 := self JumpBelowOrEqual: 0.
	jump3 := self JumpAbove: 0.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	self AndCq: 16rFFFFFFFFFFFFF R: ClassReg.
	self CmpCq: 0 R: ClassReg.
	jump1 := self JumpNonZero: 0.
	self CmpCq: 0 R: SendNumArgsReg.
	jump4 := self JumpZero: 0.
	jump5 := self JumpNonZero: 0.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	self CmpCq: 896 R: SendNumArgsReg.
	jump1 := self JumpNonZero: 0.
	currentBlock := self Label.
	jump2 jmpTarget: currentBlock.
	jump4 jmpTarget: currentBlock.
	self MoveRd: DPFPReg0 R: SendNumArgsReg.
	self RotateLeftCq: 1 R: SendNumArgsReg.
	self CmpCq: 1 R: SendNumArgsReg.
	jump4 := self JumpBelowOrEqual: 0.
	self SubCq: 16r7000000000000000 R: SendNumArgsReg.
	self LogicalShiftLeftCq: 3 R: SendNumArgsReg.
	self AddCq: 4 R: SendNumArgsReg.
	self MoveR: SendNumArgsReg R: ReceiverResultReg.
	self genPrimReturn.
	currentBlock := self Label.
	jump4 jmpTarget: currentBlock.
	self LogicalShiftLeftCq: 3 R: SendNumArgsReg.
	self AddCq: 4 R: SendNumArgsReg.
	self MoveR: SendNumArgsReg R: ReceiverResultReg.
	self genPrimReturn.
	currentBlock := self Label.
	jump3 jmpTarget: currentBlock.
	jump5 jmpTarget: currentBlock.
	jump1 jmpTarget: currentBlock.
	self MoveAw: objectMemory freeStartAddress R: SendNumArgsReg.
	self MoveAw: objectMemory freeStartAddress R: ClassReg.
	self AddCq: 16 R: ClassReg.
	s30 := objectMemory getScavengeThreshold.
	self CmpCq: s30 R: ClassReg.
	jump1 := self JumpAbove: 0.
	s33 := 72057594205700130.
	self MoveCq: s33 R: ClassReg.
	self MoveR: ClassReg M64: 0 r: SendNumArgsReg.
	self MoveAw: objectMemory freeStartAddress R: ClassReg.
	self AddCq: 16 R: ClassReg.
	self MoveR: ClassReg Aw: objectMemory freeStartAddress.
	self MoveRd: DPFPReg0 M64: 8 r: SendNumArgsReg.
	self MoveR: SendNumArgsReg R: ReceiverResultReg.
	self genPrimReturn.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	^ 0
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveAsFloatAddition [
	"AutoGenerated by Druid"

	| currentBlock |
	self MoveR: ReceiverResultReg R: ClassReg.
	self MoveR: Arg0Reg R: SendNumArgsReg.
	self ConvertR: SendNumArgsReg Rd: DPFPReg0.
	self ConvertR: ClassReg Rd: DPFPReg1.
	self AddRd: DPFPReg1 Rd: DPFPReg0.
	self MoveRd: DPFPReg0 R: ClassReg.
	self MoveR: ClassReg R: ReceiverResultReg.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveAsFloatDivision [
	"AutoGenerated by Druid"

	| currentBlock |
	self MoveR: ReceiverResultReg R: ClassReg.
	self MoveR: Arg0Reg R: SendNumArgsReg.
	self ConvertR: SendNumArgsReg Rd: DPFPReg0.
	self ConvertR: ClassReg Rd: DPFPReg1.
	self DivRd: DPFPReg1 Rd: DPFPReg0.
	self MoveRd: DPFPReg0 R: ClassReg.
	self MoveR: ClassReg R: ReceiverResultReg.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveAsFloatMultiply [
	"AutoGenerated by Druid"

	| currentBlock |
	self MoveR: ReceiverResultReg R: ClassReg.
	self MoveR: Arg0Reg R: SendNumArgsReg.
	self ConvertR: SendNumArgsReg Rd: DPFPReg0.
	self ConvertR: ClassReg Rd: DPFPReg1.
	self MulRd: DPFPReg1 Rd: DPFPReg0.
	self MoveRd: DPFPReg0 R: ClassReg.
	self MoveR: ClassReg R: ReceiverResultReg.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveAsFloatSubtract [
	"AutoGenerated by Druid"

	| currentBlock |
	self MoveR: ReceiverResultReg R: ClassReg.
	self MoveR: Arg0Reg R: SendNumArgsReg.
	self ConvertR: SendNumArgsReg Rd: DPFPReg0.
	self ConvertR: ClassReg Rd: DPFPReg1.
	self SubRd: DPFPReg1 Rd: DPFPReg0.
	self MoveRd: DPFPReg0 R: ClassReg.
	self MoveR: ClassReg R: ReceiverResultReg.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveAsInteger [
	"AutoGenerated by Druid"

	| currentBlock |
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveAssertDeferredInline [
	"AutoGenerated by Druid"

	| jump1 jump2 jump3 currentBlock |
	self MoveCq: 0 R: TempReg.
	self MoveR: TempReg Aw: coInterpreter primitiveFailureCodeAddress.
	self MoveAw: coInterpreter primitiveFailureCodeAddress R: TempReg.
	self MoveR: ReceiverResultReg R: ClassReg.
	self CmpCq: 0 R: ClassReg.
	jump1 := self JumpNonZero: 0.
	self MoveR: TempReg Aw: coInterpreter primitiveFailureCodeAddress.
	self MoveCq: 1 R: ClassReg.
	self MoveR: ClassReg Aw: coInterpreter primitiveFailureCodeAddress.
	self MoveAw: coInterpreter primitiveFailureCodeAddress R: ClassReg.
	self MoveR: ClassReg Aw: coInterpreter primitiveFailureCodeAddress.
	self MoveAw: coInterpreter primitiveFailureCodeAddress R: ClassReg.
	self MoveCq: 42 R: ReceiverResultReg.
	self CmpCq: 0 R: ClassReg.
	jump2 := self JumpZero: 0.
	jump3 := self JumpNonZero: 0.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	self MoveR: TempReg Aw: coInterpreter primitiveFailureCodeAddress.
	self MoveAw: coInterpreter primitiveFailureCodeAddress R: ClassReg.
	self MoveCq: 42 R: ReceiverResultReg.
	self CmpCq: 0 R: ClassReg.
	jump1 := self JumpNonZero: 0.
	currentBlock := self Label.
	jump2 jmpTarget: currentBlock.
	self genPrimReturn.
	currentBlock := self Label.
	jump3 jmpTarget: currentBlock.
	jump1 jmpTarget: currentBlock.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveAssertIsIgnored [
	"AutoGenerated by Druid"

	| currentBlock |
	self MoveCq: 17 R: ReceiverResultReg.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveAt [
	"AutoGenerated by Druid"

	| jump1 s72 s54 s92 jump6 jump3 currentBlock jump8 jump5 jump2 jump7 jump4 |
	self SubCq: 24 R: SPReg.
	self MoveR: ReceiverResultReg R: Extra3Reg.
	self MoveR: Extra3Reg Mw: 0 r: SPReg.
	self MoveR: Arg0Reg R: Extra3Reg.
	self MoveR: Extra3Reg Mw: 8 r: SPReg.
	self MoveMw: 0 r: SPReg R: Extra3Reg.
	self TstCq: 7 R: Extra3Reg.
	jump1 := self JumpZero: 0.
	jump2 := self Jump: 0.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	self MoveMw: 8 r: SPReg R: Extra3Reg.
	self MoveR: Extra3Reg R: Extra0Reg.
	self AndCq: 1 R: Extra0Reg.
	self CmpCq: 0 R: Extra0Reg.
	jump1 := self JumpNonZero: 0.
	jump3 := self Jump: 0.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	self MoveMw: 8 r: SPReg R: Extra3Reg.
	self ArithmeticShiftRightCq: 3 R: Extra3Reg.
	self MoveR: Extra3Reg Mw: 8 r: SPReg.
	self MoveMw: 0 r: SPReg R: Extra3Reg.
	self MoveM64: 0 r: Extra3Reg R: Extra3Reg.
	self MoveR: Extra3Reg Mw: 16 r: SPReg.
	self MoveMw: 16 r: SPReg R: Extra3Reg.
	self MoveR: Extra3Reg R: Extra1Reg.
	self LogicalShiftRightCq: 24 R: Extra1Reg.
	self AndCq: 31 R: Extra1Reg.
	self MoveMw: 0 r: SPReg R: Extra3Reg.
	self MoveMb: 7 r: Extra3Reg R: Extra2Reg.
	self AndCq: 255 R: Extra2Reg.
	self CmpCq: 255 R: Extra2Reg.
	jump1 := self JumpNonZero: 0.
	self MoveMw: 0 r: SPReg R: Extra3Reg.
	self MoveM64: -8 r: Extra3Reg R: Extra2Reg.
	self LogicalShiftLeftCq: 8 R: Extra2Reg.
	self LogicalShiftRightCq: 8 R: Extra2Reg.
	jump4 := self Jump: 0.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	currentBlock := self Label.
	jump4 jmpTarget: currentBlock.
	self CmpCq: 5 R: Extra1Reg.
	jump4 := self JumpAbove: 0.
	jump1 := self Jump: 0.
	currentBlock := self Label.
	jump4 jmpTarget: currentBlock.
	self CmpCq: 16 R: Extra1Reg.
	jump4 := self JumpBelow: 0.
	self LogicalShiftLeftCq: 3 R: Extra2Reg.
	self MoveR: Extra1Reg R: ClassReg.
	self AndCq: 7 R: ClassReg.
	self SubR: ClassReg R: Extra2Reg.
	self MoveR: Extra2Reg R: ClassReg.
	jump5 := self Jump: 0.
	currentBlock := self Label.
	jump4 jmpTarget: currentBlock.
	self CmpCq: 12 R: Extra1Reg.
	jump4 := self JumpBelow: 0.
	self LogicalShiftLeftCq: 2 R: Extra2Reg.
	self MoveR: Extra1Reg R: ClassReg.
	self AndCq: 3 R: ClassReg.
	self SubR: ClassReg R: Extra2Reg.
	self MoveR: Extra2Reg R: ClassReg.
	jump6 := self Jump: 0.
	currentBlock := self Label.
	jump4 jmpTarget: currentBlock.
	self CmpCq: 10 R: Extra1Reg.
	jump4 := self JumpBelow: 0.
	self LogicalShiftLeftCq: 1 R: Extra2Reg.
	self MoveR: Extra1Reg R: ClassReg.
	self AndCq: 1 R: ClassReg.
	self SubR: ClassReg R: Extra2Reg.
	jump7 := self Jump: 0.
	currentBlock := self Label.
	jump4 jmpTarget: currentBlock.
	self CmpCq: 9 R: Extra1Reg.
	jump4 := self JumpNonZero: 0.
	jump8 := self Jump: 0.
	currentBlock := self Label.
	jump4 jmpTarget: currentBlock.
	s54 := 0.
	self MoveCq: s54 R: Extra2Reg.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	jump7 jmpTarget: currentBlock.
	jump8 jmpTarget: currentBlock.
	self CmpCq: 9 R: Extra1Reg.
	jump8 := self JumpBelow: 0.
	self MoveR: Extra2Reg R: ClassReg.
	currentBlock := self Label.
	jump6 jmpTarget: currentBlock.
	currentBlock := self Label.
	jump5 jmpTarget: currentBlock.
	jump5 := self Jump: 0.
	currentBlock := self Label.
	jump8 jmpTarget: currentBlock.
	self CmpCq: 2 R: Extra1Reg.
	jump8 := self JumpNonZero: 0.
	self MoveR: Extra2Reg R: ClassReg.
	currentBlock := self Label.
	jump5 jmpTarget: currentBlock.
	s72 := 0.
	self MoveCq: s72 R: SendNumArgsReg.
	jump5 := self Jump: 0.
	currentBlock := self Label.
	jump8 jmpTarget: currentBlock.
	self CmpCq: 2 R: Extra1Reg.
	jump8 := self JumpAboveOrEqual: 0.
	self MoveR: Extra2Reg R: SendNumArgsReg.
	self MoveR: Extra2Reg R: ClassReg.
	jump6 := self Jump: 0.
	currentBlock := self Label.
	jump8 jmpTarget: currentBlock.
	self MoveMw: 0 r: SPReg R: Extra3Reg.
	self MoveM64: 0 r: Extra3Reg R: ClassReg.
	self AndCq: 16r3FFFFF R: ClassReg.
	self CmpCq: 31 R: ClassReg.
	jump8 := self JumpAbove: 0.
	self CmpCq: 31 R: ClassReg.
	jump7 := self JumpNonZero: 0.
	self MoveMw: 0 r: SPReg R: Extra3Reg.
	self MoveR: Extra3Reg R: ClassReg.
	jump1 := self Jump: 0.
	currentBlock := self Label.
	jump7 jmpTarget: currentBlock.
	self CmpCq: 8 R: ClassReg.
	jump7 := self JumpNonZero: 0.
	self genMoveConstant: objectMemory nilObject R: ClassReg.
	jump4 := self Jump: 0.
	currentBlock := self Label.
	jump8 jmpTarget: currentBlock.
	jump7 jmpTarget: currentBlock.
	self MoveR: ClassReg R: SendNumArgsReg.
	self LogicalShiftRightCq: 10 R: SendNumArgsReg.
	s92 := objectMemory hiddenRootsObject.
	self LogicalShiftLeftCq: 3 R: SendNumArgsReg.
	self AddCq: s92 R: SendNumArgsReg.
	self MoveM64: 8 r: SendNumArgsReg R: SendNumArgsReg.
	self genMoveConstant: objectMemory nilObject R: Extra0Reg.
	self CmpR: Extra0Reg R: SendNumArgsReg.
	jump7 := self JumpNonZero: 0.
	self genMoveConstant: objectMemory nilObject R: Extra0Reg.
	jump8 := self Jump: 0.
	currentBlock := self Label.
	jump7 jmpTarget: currentBlock.
	self AndCq: 1023 R: ClassReg.
	self LogicalShiftLeftCq: 3 R: ClassReg.
	self AddR: ClassReg R: SendNumArgsReg.
	self MoveM64: 8 r: SendNumArgsReg R: Extra0Reg.
	currentBlock := self Label.
	jump8 jmpTarget: currentBlock.
	self MoveR: Extra0Reg R: ClassReg.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	jump4 jmpTarget: currentBlock.
	self MoveM64: 24 r: ClassReg R: Extra0Reg.
	self ArithmeticShiftRightCq: 3 R: Extra0Reg.
	self AndCq: 16rFFFF R: Extra0Reg.
	self MoveR: Extra0Reg R: SendNumArgsReg.
	self MoveR: Extra2Reg R: ClassReg.
	currentBlock := self Label.
	jump5 jmpTarget: currentBlock.
	jump6 jmpTarget: currentBlock.
	self CmpCq: 3 R: Extra1Reg.
	jump6 := self JumpNonZero: 0.
	self MoveMw: 16 r: SPReg R: Extra3Reg.
	self AndCq: 16r3FFFFF R: Extra3Reg.
	self MoveR: Extra3Reg Mw: 16 r: SPReg.
	self MoveMw: 16 r: SPReg R: Extra3Reg.
	self CmpCq: 36 R: Extra3Reg.
	jump5 := self JumpNonZero: 0.
	jump4 := self Jump: 0.
	currentBlock := self Label.
	jump6 jmpTarget: currentBlock.
	jump5 jmpTarget: currentBlock.
	self SubR: SendNumArgsReg R: ClassReg.
	self CmpCq: 24 R: Extra1Reg.
	jump5 := self JumpBelow: 0.
	currentBlock := self Label.
	jump2 jmpTarget: currentBlock.
	jump3 jmpTarget: currentBlock.
	jump4 jmpTarget: currentBlock.
	jump4 := self Jump: 0.
	currentBlock := self Label.
	jump5 jmpTarget: currentBlock.
	self MoveMw: 8 r: SPReg R: Extra3Reg.
	self CmpCq: 1 R: Extra3Reg.
	jump5 := self JumpBelow: 0.
	self MoveMw: 8 r: SPReg R: Extra3Reg.
	self CmpR: ClassReg R: Extra3Reg.
	jump3 := self JumpAbove: 0.
	self MoveMw: 8 r: SPReg R: Extra3Reg.
	self AddR: SendNumArgsReg R: Extra3Reg.
	self MoveR: Extra3Reg Mw: 8 r: SPReg.
	self CmpCq: 5 R: Extra1Reg.
	jump2 := self JumpAbove: 0.
	self MoveMw: 8 r: SPReg R: Extra3Reg.
	self SubCq: 1 R: Extra3Reg.
	self MoveR: Extra3Reg Mw: 8 r: SPReg.
	self MoveMw: 8 r: SPReg R: Extra3Reg.
	self LogicalShiftLeftCq: 3 R: Extra3Reg.
	self MoveR: Extra3Reg Mw: 8 r: SPReg.
	self MoveMw: 0 r: SPReg R: Extra3Reg.
	self MoveMw: 8 r: SPReg R: Extra4Reg.
	self AddR: Extra4Reg R: Extra3Reg.
	self MoveR: Extra3Reg Mw: 0 r: SPReg.
	self MoveMw: 0 r: SPReg R: Extra3Reg.
	self MoveM64: 8 r: Extra3Reg R: Extra0Reg.
	jump6 := self Jump: 0.
	currentBlock := self Label.
	jump2 jmpTarget: currentBlock.
	self CmpCq: 16 R: Extra1Reg.
	jump2 := self JumpBelow: 0.
	self MoveMw: 8 r: SPReg R: Extra3Reg.
	self MoveMw: 0 r: SPReg R: Extra4Reg.
	self AddR: Extra4Reg R: Extra3Reg.
	self MoveR: Extra3Reg Mw: 8 r: SPReg.
	self MoveMw: 8 r: SPReg R: Extra3Reg.
	self AddCq:  -1 R: Extra3Reg.
	self MoveR: Extra3Reg Mw: 8 r: SPReg.
	self MoveMw: 8 r: SPReg R: Extra3Reg.
	self MoveMb: 8 r: Extra3Reg R: Extra0Reg.
	self AndCq: 255 R: Extra0Reg.
	self LogicalShiftLeftCq: 3 R: Extra0Reg.
	self AddCq: 1 R: Extra0Reg.
	jump1 := self Jump: 0.
	currentBlock := self Label.
	jump2 jmpTarget: currentBlock.
	self CmpCq: 12 R: Extra1Reg.
	jump2 := self JumpBelow: 0.
	self MoveMw: 8 r: SPReg R: Extra3Reg.
	self SubCq: 1 R: Extra3Reg.
	self MoveR: Extra3Reg Mw: 8 r: SPReg.
	self MoveMw: 8 r: SPReg R: Extra3Reg.
	self LogicalShiftLeftCq: 1 R: Extra3Reg.
	self MoveR: Extra3Reg Mw: 8 r: SPReg.
	self MoveMw: 0 r: SPReg R: Extra3Reg.
	self MoveMw: 8 r: SPReg R: Extra4Reg.
	self AddR: Extra4Reg R: Extra3Reg.
	self MoveR: Extra3Reg Mw: 0 r: SPReg.
	self MoveMw: 0 r: SPReg R: Extra3Reg.
	self MoveM16: 8 r: Extra3Reg R: Extra0Reg.
	self AndCq: 16rFFFF R: Extra0Reg.
	self LogicalShiftLeftCq: 3 R: Extra0Reg.
	self AddCq: 1 R: Extra0Reg.
	jump8 := self Jump: 0.
	currentBlock := self Label.
	jump2 jmpTarget: currentBlock.
	self CmpCq: 9 R: Extra1Reg.
	jump2 := self JumpNonZero: 0.
	self MoveMw: 8 r: SPReg R: Extra3Reg.
	self SubCq: 1 R: Extra3Reg.
	self MoveR: Extra3Reg Mw: 8 r: SPReg.
	self MoveMw: 8 r: SPReg R: Extra3Reg.
	self LogicalShiftLeftCq: 3 R: Extra3Reg.
	self MoveR: Extra3Reg Mw: 8 r: SPReg.
	self MoveMw: 0 r: SPReg R: Extra3Reg.
	self MoveMw: 8 r: SPReg R: Extra4Reg.
	self AddR: Extra4Reg R: Extra3Reg.
	self MoveR: Extra3Reg Mw: 0 r: SPReg.
	self MoveMw: 0 r: SPReg R: Extra3Reg.
	self MoveM64: 8 r: Extra3Reg R: Extra0Reg.
	self CmpCq: 16rFFFFFFFFFFFFFFF R: Extra0Reg.
	jump7 := self JumpAbove: 0.
	self LogicalShiftLeftCq: 3 R: Extra0Reg.
	self AddCq: 1 R: Extra0Reg.
	currentBlock := self Label.
	jump6 jmpTarget: currentBlock.
	jump1 jmpTarget: currentBlock.
	jump8 jmpTarget: currentBlock.
	self MoveR: Extra0Reg R: ReceiverResultReg.
	self AddCq: 24 R: SPReg.
	self genPrimReturn.
	currentBlock := self Label.
	jump4 jmpTarget: currentBlock.
	currentBlock := self Label.
	jump3 jmpTarget: currentBlock.
	currentBlock := self Label.
	jump2 jmpTarget: currentBlock.
	currentBlock := self Label.
	jump5 jmpTarget: currentBlock.
	currentBlock := self Label.
	jump7 jmpTarget: currentBlock.
	self AddCq: 24 R: SPReg.
	^ 0
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveAtPut [
	"AutoGenerated by Druid"

	| jump5 s153 jump10 s127 s175 s55 jump3 s119 s151 s160 s222 s62 jump1 jump8 currentBlock jump13 s178 jump6 jumpNext s124 jump11 jump4 s80 jumpTrue jump9 jump2 jump14 s172 jump7 s116 s210 s129 jump12 |
	self SubCq: 24 R: SPReg.
	self MoveR: ReceiverResultReg R: Extra3Reg.
	self MoveR: Extra3Reg Mw: 0 r: SPReg.
	self MoveR: Arg0Reg R: Extra3Reg.
	self MoveR: Extra3Reg Mw: 8 r: SPReg.
	self MoveR: Arg1Reg R: Extra3Reg.
	self MoveR: Extra3Reg Mw: 16 r: SPReg.
	self MoveMw: 0 r: SPReg R: Extra3Reg.
	self TstCq: 7 R: Extra3Reg.
	jump1 := self JumpNonZero: 0.
	self MoveMw: 8 r: SPReg R: Extra3Reg.
	self MoveR: Extra3Reg R: Extra1Reg.
	self AndCq: 1 R: Extra1Reg.
	self CmpCq: 0 R: Extra1Reg.
	jump2 := self JumpNonZero: 0.
	self CmpCq: 0 R: Extra1Reg.
	jump3 := self JumpZero: 0.
	currentBlock := self Label.
	jump2 jmpTarget: currentBlock.
	self MoveMw: 8 r: SPReg R: Extra3Reg.
	self ArithmeticShiftRightCq: 3 R: Extra3Reg.
	self MoveR: Extra3Reg Mw: 8 r: SPReg.
	self MoveMw: 0 r: SPReg R: Extra3Reg.
	self MoveM64: 0 r: Extra3Reg R: Extra1Reg.
	self MoveR: Extra1Reg R: Extra2Reg.
	self AndCq: 16r3FFFFF R: Extra2Reg.
	self CmpCq: 36 R: Extra2Reg.
	jump2 := self JumpZero: 0.
	self LogicalShiftRightCq: 24 R: Extra1Reg.
	self AndCq: 31 R: Extra1Reg.
	self MoveMw: 0 r: SPReg R: Extra3Reg.
	self MoveMb: 7 r: Extra3Reg R: Extra2Reg.
	self AndCq: 255 R: Extra2Reg.
	self CmpCq: 255 R: Extra2Reg.
	jump4 := self JumpNonZero: 0.
	self MoveMw: 0 r: SPReg R: Extra3Reg.
	self MoveM64: -8 r: Extra3Reg R: Extra2Reg.
	self LogicalShiftLeftCq: 8 R: Extra2Reg.
	self LogicalShiftRightCq: 8 R: Extra2Reg.
	jump5 := self Jump: 0.
	currentBlock := self Label.
	jump4 jmpTarget: currentBlock.
	currentBlock := self Label.
	jump5 jmpTarget: currentBlock.
	self CmpCq: 5 R: Extra1Reg.
	jump5 := self JumpAbove: 0.
	jump4 := self Jump: 0.
	currentBlock := self Label.
	jump5 jmpTarget: currentBlock.
	self CmpCq: 16 R: Extra1Reg.
	jump5 := self JumpBelow: 0.
	self LogicalShiftLeftCq: 3 R: Extra2Reg.
	self MoveR: Extra1Reg R: ClassReg.
	self AndCq: 7 R: ClassReg.
	self SubR: ClassReg R: Extra2Reg.
	jump6 := self Jump: 0.
	currentBlock := self Label.
	jump5 jmpTarget: currentBlock.
	self CmpCq: 12 R: Extra1Reg.
	jump5 := self JumpBelow: 0.
	self LogicalShiftLeftCq: 2 R: Extra2Reg.
	self MoveR: Extra1Reg R: ClassReg.
	self AndCq: 3 R: ClassReg.
	self SubR: ClassReg R: Extra2Reg.
	jump7 := self Jump: 0.
	currentBlock := self Label.
	jump5 jmpTarget: currentBlock.
	self CmpCq: 10 R: Extra1Reg.
	jump5 := self JumpBelow: 0.
	self LogicalShiftLeftCq: 1 R: Extra2Reg.
	self MoveR: Extra1Reg R: ClassReg.
	self AndCq: 1 R: ClassReg.
	self SubR: ClassReg R: Extra2Reg.
	jump8 := self Jump: 0.
	currentBlock := self Label.
	jump5 jmpTarget: currentBlock.
	self CmpCq: 9 R: Extra1Reg.
	jump5 := self JumpNonZero: 0.
	jump9 := self Jump: 0.
	currentBlock := self Label.
	jump5 jmpTarget: currentBlock.
	s55 := 0.
	self MoveCq: s55 R: Extra2Reg.
	currentBlock := self Label.
	jump4 jmpTarget: currentBlock.
	jump6 jmpTarget: currentBlock.
	jump7 jmpTarget: currentBlock.
	jump8 jmpTarget: currentBlock.
	jump9 jmpTarget: currentBlock.
	self CmpCq: 9 R: Extra1Reg.
	jump9 := self JumpBelow: 0.
	self CmpCq: 9 R: Extra1Reg.
	jump8 := self JumpAboveOrEqual: 0.
	jump7 := self JumpBelow: 0.
	currentBlock := self Label.
	jump9 jmpTarget: currentBlock.
	self CmpCq: 2 R: Extra1Reg.
	jump9 := self JumpNonZero: 0.
	currentBlock := self Label.
	jump8 jmpTarget: currentBlock.
	s62 := 0.
	self MoveCq: s62 R: ClassReg.
	jump8 := self Jump: 0.
	currentBlock := self Label.
	jump7 jmpTarget: currentBlock.
	jump9 jmpTarget: currentBlock.
	self CmpCq: 2 R: Extra1Reg.
	jump9 := self JumpAboveOrEqual: 0.
	self MoveR: Extra2Reg R: ClassReg.
	jump7 := self Jump: 0.
	currentBlock := self Label.
	jump9 jmpTarget: currentBlock.
	self MoveMw: 0 r: SPReg R: Extra3Reg.
	self MoveM64: 0 r: Extra3Reg R: ClassReg.
	self AndCq: 16r3FFFFF R: ClassReg.
	self CmpCq: 31 R: ClassReg.
	jump9 := self JumpAbove: 0.
	self CmpCq: 31 R: ClassReg.
	jump6 := self JumpNonZero: 0.
	self MoveMw: 0 r: SPReg R: Extra3Reg.
	self MoveR: Extra3Reg R: ClassReg.
	jump4 := self Jump: 0.
	currentBlock := self Label.
	jump6 jmpTarget: currentBlock.
	self CmpCq: 8 R: ClassReg.
	jump6 := self JumpNonZero: 0.
	self genMoveConstant: objectMemory nilObject R: ClassReg.
	jump5 := self Jump: 0.
	currentBlock := self Label.
	jump9 jmpTarget: currentBlock.
	jump6 jmpTarget: currentBlock.
	self MoveR: ClassReg R: SendNumArgsReg.
	self LogicalShiftRightCq: 10 R: SendNumArgsReg.
	s80 := objectMemory hiddenRootsObject.
	self LogicalShiftLeftCq: 3 R: SendNumArgsReg.
	self AddCq: s80 R: SendNumArgsReg.
	self MoveM64: 8 r: SendNumArgsReg R: SendNumArgsReg.
	self genMoveConstant: objectMemory nilObject R: Extra0Reg.
	self CmpR: Extra0Reg R: SendNumArgsReg.
	jump6 := self JumpNonZero: 0.
	self genMoveConstant: objectMemory nilObject R: Extra0Reg.
	jump9 := self Jump: 0.
	currentBlock := self Label.
	jump6 jmpTarget: currentBlock.
	self AndCq: 1023 R: ClassReg.
	self LogicalShiftLeftCq: 3 R: ClassReg.
	self AddR: ClassReg R: SendNumArgsReg.
	self MoveM64: 8 r: SendNumArgsReg R: Extra0Reg.
	currentBlock := self Label.
	jump9 jmpTarget: currentBlock.
	self MoveR: Extra0Reg R: ClassReg.
	currentBlock := self Label.
	jump4 jmpTarget: currentBlock.
	jump5 jmpTarget: currentBlock.
	self MoveM64: 24 r: ClassReg R: Extra0Reg.
	self ArithmeticShiftRightCq: 3 R: Extra0Reg.
	self AndCq: 16rFFFF R: Extra0Reg.
	self MoveR: Extra0Reg R: ClassReg.
	currentBlock := self Label.
	jump8 jmpTarget: currentBlock.
	jump7 jmpTarget: currentBlock.
	self SubR: ClassReg R: Extra2Reg.
	self CmpCq: 24 R: Extra1Reg.
	jump7 := self JumpAboveOrEqual: 0.
	self MoveMw: 8 r: SPReg R: Extra3Reg.
	self CmpCq: 1 R: Extra3Reg.
	jump8 := self JumpBelow: 0.
	self MoveMw: 8 r: SPReg R: Extra3Reg.
	self CmpR: Extra2Reg R: Extra3Reg.
	jump5 := self JumpAbove: 0.
	self MoveMw: 8 r: SPReg R: Extra3Reg.
	self AddR: ClassReg R: Extra3Reg.
	self MoveR: Extra3Reg Mw: 8 r: SPReg.
	self CmpCq: 5 R: Extra1Reg.
	jump4 := self JumpAbove: 0.
	self MoveMw: 8 r: SPReg R: Extra3Reg.
	self SubCq: 1 R: Extra3Reg.
	self MoveR: Extra3Reg Mw: 8 r: SPReg.
	self MoveMw: 0 r: SPReg R: Extra3Reg.
	self MoveR: Extra3Reg R: Extra0Reg.
	self AndCq: 7 R: Extra0Reg.
	self CmpCq: 0 R: Extra0Reg.
	jump9 := self JumpNonZero: 0.
	s116 := objectMemory getMemoryMap getSpaceMaskToUse.
	self MoveMw: 0 r: SPReg R: Extra3Reg.
	self MoveR: Extra3Reg R: Extra0Reg.
	self AndCq: s116 R: Extra0Reg.
	s119 := objectMemory getMemoryMap getOldSpaceMask.
	self CmpCq: s119 R: Extra0Reg.
	jump6 := self JumpNonZero: 0.
	self MoveMw: 16 r: SPReg R: Extra3Reg.
	self MoveR: Extra3Reg R: Extra0Reg.
	self AndCq: 7 R: Extra0Reg.
	self CmpCq: 0 R: Extra0Reg.
	jump10 := self JumpNonZero: 0.
	s124 := objectMemory getMemoryMap getSpaceMaskToUse.
	self MoveMw: 16 r: SPReg R: Extra3Reg.
	self MoveR: Extra3Reg R: Extra0Reg.
	self AndCq: s124 R: Extra0Reg.
	s127 := objectMemory getMemoryMap getNewSpaceMask.
	self CmpCq: s127 R: Extra0Reg.
	jump11 := self JumpNonZero: 0.
	s129 := objectMemory getMemoryMap getNewSpaceStart.
	self MoveMw: 16 r: SPReg R: Extra3Reg.
	self MoveR: Extra3Reg R: Extra0Reg.
	self CmpCq: s129 R: Extra0Reg.
	jumpTrue := self JumpAboveOrEqual: 0.
	self MoveCq: 0 R: Extra0Reg.
	jumpNext := self Jump: 0.
	jumpTrue jmpTarget: self Label.
	self MoveCq: 1 R: Extra0Reg.
	jumpNext jmpTarget: self Label.
	self CmpCq: 1 R: Extra0Reg.
	jump12 := self JumpNonZero: 0.
	self MoveMw: 0 r: SPReg R: Extra3Reg.
	self MoveM64: 0 r: Extra3Reg R: Extra0Reg.
	self LogicalShiftRightCq: 29 R: Extra0Reg.
	self AndCq: 1 R: Extra0Reg.
	self CmpCq: 0 R: Extra0Reg.
	jump13 := self JumpNonZero: 0.
	self MoveMw: 0 r: SPReg R: Extra3Reg.
	self MoveR: Extra3Reg R: TempReg.
	backEnd saveAndRestoreLinkRegAround: [
		self CallRT: ceStoreCheckTrampoline ].
	jump14 := self Jump: 0.
	currentBlock := self Label.
	jump11 jmpTarget: currentBlock.
	currentBlock := self Label.
	jump9 jmpTarget: currentBlock.
	jump6 jmpTarget: currentBlock.
	jump10 jmpTarget: currentBlock.
	jump12 jmpTarget: currentBlock.
	jump13 jmpTarget: currentBlock.
	jump14 jmpTarget: currentBlock.
	self MoveMw: 0 r: SPReg R: Extra3Reg.
	self MoveM64: 0 r: Extra3Reg R: Extra0Reg.
	self LogicalShiftRightCq: 29 R: Extra0Reg.
	self AndCq: 1 R: Extra0Reg.
	self CmpCq: 0 R: Extra0Reg.
	jump14 := self JumpNonZero: 0.
	self MoveMw: 16 r: SPReg R: Extra3Reg.
	self TstCq: 7 R: Extra3Reg.
	jump13 := self JumpNonZero: 0.
	self MoveMw: 0 r: SPReg R: Extra3Reg.
	self CmpCq: 16r20000000000 R: Extra3Reg.
	jump12 := self JumpBelow: 0.
	self MoveMw: 16 r: SPReg R: Extra3Reg.
	self CmpCq: 16r20000000000 R: Extra3Reg.
	jump10 := self JumpAboveOrEqual: 0.
	self genMoveConstant: objectMemory nilObject R: Extra0Reg.
	self MoveMw: 16 r: SPReg R: Extra3Reg.
	self CmpR: Extra0Reg R: Extra3Reg.
	jump6 := self JumpBelow: 0.
	s151 := objectMemory trueObject.
	self MoveMw: 16 r: SPReg R: Extra3Reg.
	self CmpCq: s151 R: Extra3Reg.
	jump9 := self JumpBelowOrEqual: 0.
	currentBlock := self Label.
	jump6 jmpTarget: currentBlock.
	s153 := objectMemory getMemoryMap getNewSpaceStart.
	self MoveMw: 16 r: SPReg R: Extra3Reg.
	self CmpCq: s153 R: Extra3Reg.
	jump6 := self JumpBelow: 0.
	self MoveMw: 0 r: SPReg R: Extra3Reg.
	self MoveR: Extra3Reg R: TempReg.
	backEnd saveAndRestoreLinkRegAround: [
		self CallRT: ceStoreCheckTrampoline ].
	currentBlock := self Label.
	jump14 jmpTarget: currentBlock.
	jump13 jmpTarget: currentBlock.
	jump12 jmpTarget: currentBlock.
	jump10 jmpTarget: currentBlock.
	jump9 jmpTarget: currentBlock.
	jump6 jmpTarget: currentBlock.
	self MoveMw: 8 r: SPReg R: Extra3Reg.
	self LogicalShiftLeftCq: 3 R: Extra3Reg.
	self MoveR: Extra3Reg Mw: 8 r: SPReg.
	self MoveMw: 0 r: SPReg R: Extra3Reg.
	self MoveMw: 8 r: SPReg R: Extra4Reg.
	self AddR: Extra4Reg R: Extra3Reg.
	self MoveR: Extra3Reg Mw: 0 r: SPReg.
	self MoveMw: 16 r: SPReg R: Extra3Reg.
	self MoveMw: 0 r: SPReg R: Extra4Reg.
	self MoveR: Extra3Reg M64: 8 r: Extra4Reg.
	s160 := 0.
	self MoveCq: s160 R: Extra0Reg.
	jump6 := self Jump: 0.
	currentBlock := self Label.
	jump4 jmpTarget: currentBlock.
	self CmpCq: 16 R: Extra1Reg.
	jump4 := self JumpBelow: 0.
	self MoveMw: 16 r: SPReg R: Extra3Reg.
	self TstCq: 1 R: Extra3Reg.
	jump9 := self JumpZero: 0.
	self MoveMw: 16 r: SPReg R: Extra3Reg.
	self MoveR: Extra3Reg R: Extra0Reg.
	self ArithmeticShiftRightCq: 3 R: Extra0Reg.
	self CmpCq: 0 R: Extra0Reg.
	jump10 := self JumpBelow: 0.
	self CmpCq: 255 R: Extra0Reg.
	jump12 := self JumpAbove: 0.
	self MoveMw: 8 r: SPReg R: Extra3Reg.
	self MoveMw: 0 r: SPReg R: Extra4Reg.
	self AddR: Extra4Reg R: Extra3Reg.
	self MoveR: Extra3Reg Mw: 8 r: SPReg.
	self MoveMw: 8 r: SPReg R: Extra3Reg.
	self AddCq:  -1 R: Extra3Reg.
	self MoveR: Extra3Reg Mw: 8 r: SPReg.
	self MoveMw: 8 r: SPReg R: Extra3Reg.
	self MoveR: Extra0Reg Mb: 8 r: Extra3Reg.
	s172 := 0.
	self MoveCq: s172 R: Extra0Reg.
	jump13 := self Jump: 0.
	currentBlock := self Label.
	jump10 jmpTarget: currentBlock.
	jump12 jmpTarget: currentBlock.
	s175 := 3.
	self MoveCq: s175 R: Extra0Reg.
	jump12 := self Jump: 0.
	currentBlock := self Label.
	jump9 jmpTarget: currentBlock.
	s178 := 3.
	self MoveCq: s178 R: Extra0Reg.
	currentBlock := self Label.
	jump6 jmpTarget: currentBlock.
	jump13 jmpTarget: currentBlock.
	jump12 jmpTarget: currentBlock.
	jump12 := self Jump: 0.
	currentBlock := self Label.
	jump4 jmpTarget: currentBlock.
	self CmpCq: 12 R: Extra1Reg.
	jump4 := self JumpBelow: 0.
	self MoveMw: 16 r: SPReg R: Extra3Reg.
	self TstCq: 1 R: Extra3Reg.
	jump13 := self JumpZero: 0.
	self MoveMw: 16 r: SPReg R: Extra3Reg.
	self MoveR: Extra3Reg R: Extra0Reg.
	self ArithmeticShiftRightCq: 3 R: Extra0Reg.
	self CmpCq: 0 R: Extra0Reg.
	jump6 := self JumpBelow: 0.
	self CmpCq: 16rFFFF R: Extra0Reg.
	jump9 := self JumpAbove: 0.
	self MoveMw: 8 r: SPReg R: Extra3Reg.
	self SubCq: 1 R: Extra3Reg.
	self MoveR: Extra3Reg Mw: 8 r: SPReg.
	self MoveMw: 8 r: SPReg R: Extra3Reg.
	self LogicalShiftLeftCq: 1 R: Extra3Reg.
	self MoveR: Extra3Reg Mw: 8 r: SPReg.
	self MoveMw: 0 r: SPReg R: Extra3Reg.
	self MoveMw: 8 r: SPReg R: Extra4Reg.
	self AddR: Extra4Reg R: Extra3Reg.
	self MoveR: Extra3Reg Mw: 0 r: SPReg.
	self MoveMw: 0 r: SPReg R: Extra3Reg.
	self MoveR: Extra3Reg R: Extra2Reg.
	self AddCq: 8 R: Extra2Reg.
	self MoveR: Extra2Reg R: Extra1Reg.
	self AndCq: 2 R: Extra1Reg.
	self CmpCq: 0 R: Extra1Reg.
	jump10 := self JumpNonZero: 0.
	self MoveMw: 0 r: SPReg R: Extra3Reg.
	self MoveM32: 8 r: Extra3Reg R: Extra1Reg.
	self AndCq: 16rFFFFFFFF R: Extra1Reg.
	self AndCq: 16rFFFF0000 R: Extra1Reg.
	self OrR: Extra0Reg R: Extra1Reg.
	self MoveMw: 0 r: SPReg R: Extra3Reg.
	self MoveR: Extra1Reg M32: 8 r: Extra3Reg.
	jump14 := self Jump: 0.
	currentBlock := self Label.
	jump10 jmpTarget: currentBlock.
	self MoveM32: -2 r: Extra2Reg R: Extra1Reg.
	self AndCq: 16rFFFFFFFF R: Extra1Reg.
	self AndCq: 16rFFFF R: Extra1Reg.
	self LogicalShiftLeftCq: 16 R: Extra0Reg.
	self OrR: Extra0Reg R: Extra1Reg.
	self MoveR: Extra1Reg M32: -2 r: Extra2Reg.
	currentBlock := self Label.
	jump14 jmpTarget: currentBlock.
	s210 := 0.
	self MoveCq: s210 R: Extra0Reg.
	currentBlock := self Label.
	jump12 jmpTarget: currentBlock.
	self CmpCq: 0 R: Extra0Reg.
	jump12 := self JumpNonZero: 0.
	self MoveR: Extra0Reg R: Extra1Reg.
	self CmpCq: 0 R: Extra1Reg.
	jump14 := self JumpZero: 0.
	jump10 := self JumpNonZero: 0.
	currentBlock := self Label.
	jump12 jmpTarget: currentBlock.
	self MoveR: Extra0Reg R: Extra1Reg.
	jump12 := self Jump: 0.
	currentBlock := self Label.
	jump6 jmpTarget: currentBlock.
	jump9 jmpTarget: currentBlock.
	s222 := 3.
	self MoveCq: s222 R: Extra1Reg.
	currentBlock := self Label.
	jump12 jmpTarget: currentBlock.
	self MoveMw: 16 r: SPReg R: Extra3Reg.
	self MoveR: Extra3Reg R: ReceiverResultReg.
	self CmpCq: 0 R: Extra1Reg.
	jump12 := self JumpNonZero: 0.
	currentBlock := self Label.
	jump14 jmpTarget: currentBlock.
	self AddCq: 24 R: SPReg.
	self genPrimReturn.
	currentBlock := self Label.
	jump13 jmpTarget: currentBlock.
	self MoveMw: 16 r: SPReg R: Extra3Reg.
	self MoveR: Extra3Reg R: ReceiverResultReg.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	jump3 jmpTarget: currentBlock.
	jump2 jmpTarget: currentBlock.
	jump7 jmpTarget: currentBlock.
	jump8 jmpTarget: currentBlock.
	jump5 jmpTarget: currentBlock.
	jump4 jmpTarget: currentBlock.
	jump10 jmpTarget: currentBlock.
	jump12 jmpTarget: currentBlock.
	self AddCq: 24 R: SPReg.
	^ 0
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveAtPut_fixed [
	"AutoGenerated by Druid"

	| s129 jump6 jump10 jump7 jump11 s119 jump8 s158 jump12 jump9 s233 jump13 jump14 s209 s170 jump15 jumpTrue jump16 s224 s62 s124 s176 s179 jump1 jump2 s152 s127 jump3 s140 jump4 s154 currentBlock s116 jump5 s80 jumpNext s55 |
	self SubCq: 24 R: SPReg.

	self MoveR: ReceiverResultReg R: Extra3Reg.
	self MoveR: Extra3Reg Mw: 0 r: SPReg.
	self MoveR: Arg0Reg R: Extra3Reg.
	self MoveR: Extra3Reg Mw: 8 r: SPReg.
	self MoveR: Arg1Reg R: Extra3Reg.
	self MoveR: Extra3Reg Mw: 16 r: SPReg.

	self MoveMw: 0 r: SPReg R: Extra3Reg.
	self TstCq: 7 R: Extra3Reg.
	jump1 := self JumpNonZero: 0.
	self MoveMw: 8 r: SPReg R: Extra3Reg.
	self MoveR: Extra3Reg R: Extra1Reg.
	self AndCq: 1 R: Extra1Reg.
	self CmpCq: 0 R: Extra1Reg.
	jump2 := self JumpNonZero: 0.
	self CmpCq: 0 R: Extra1Reg.
	jump3 := self JumpZero: 0.
	currentBlock := self Label.
	jump2 jmpTarget: currentBlock.
	self MoveMw: 8 r: SPReg R: Extra3Reg.
	self ArithmeticShiftRightCq: 3 R: Extra3Reg.
	self MoveR: Extra3Reg Mw: 8 r: SPReg.
	self MoveMw: 0 r: SPReg R: Extra3Reg.
	self MoveM64: 0 r: Extra3Reg R: Extra1Reg.
	self MoveR: Extra1Reg R: Extra2Reg.
	self AndCq: 16r3FFFFF R: Extra2Reg.
	self CmpCq: 36 R: Extra2Reg.
	jump2 := self JumpZero: 0.
	self LogicalShiftRightCq: 24 R: Extra1Reg.
	self AndCq: 31 R: Extra1Reg.
	self MoveMw: 0 r: SPReg R: Extra3Reg.
	self MoveMb: 7 r: Extra3Reg R: Extra2Reg.
	self AndCq: 255 R: Extra2Reg.
	self CmpCq: 255 R: Extra2Reg.
	jump4 := self JumpNonZero: 0.
	self MoveMw: 0 r: SPReg R: Extra3Reg.
	self MoveM64: -8 r: Extra3Reg R: Extra2Reg.
	self LogicalShiftLeftCq: 8 R: Extra2Reg.
	self LogicalShiftRightCq: 8 R: Extra2Reg.
	jump5 := self Jump: 0.
	currentBlock := self Label.
	jump4 jmpTarget: currentBlock.
	currentBlock := self Label.
	jump5 jmpTarget: currentBlock.
	self CmpCq: 5 R: Extra1Reg.
	jump5 := self JumpAbove: 0.
	jump4 := self Jump: 0.
	currentBlock := self Label.
	jump5 jmpTarget: currentBlock.
	self CmpCq: 16 R: Extra1Reg.
	jump5 := self JumpBelow: 0.
	self LogicalShiftLeftCq: 3 R: Extra2Reg.
	self MoveR: Extra1Reg R: ClassReg.
	self AndCq: 7 R: ClassReg.
	self SubR: ClassReg R: Extra2Reg.
	jump6 := self Jump: 0.
	currentBlock := self Label.
	jump5 jmpTarget: currentBlock.
	self CmpCq: 12 R: Extra1Reg.
	jump5 := self JumpBelow: 0.
	self LogicalShiftLeftCq: 2 R: Extra2Reg.
	self MoveR: Extra1Reg R: ClassReg.
	self AndCq: 3 R: ClassReg.
	self SubR: ClassReg R: Extra2Reg.
	jump7 := self Jump: 0.
	currentBlock := self Label.
	jump5 jmpTarget: currentBlock.
	self CmpCq: 10 R: Extra1Reg.
	jump5 := self JumpBelow: 0.
	self LogicalShiftLeftCq: 1 R: Extra2Reg.
	self MoveR: Extra1Reg R: ClassReg.
	self AndCq: 1 R: ClassReg.
	self SubR: ClassReg R: Extra2Reg.
	jump8 := self Jump: 0.
	currentBlock := self Label.
	jump5 jmpTarget: currentBlock.
	self CmpCq: 9 R: Extra1Reg.
	jump5 := self JumpNonZero: 0.
	jump9 := self Jump: 0.
	currentBlock := self Label.
	jump5 jmpTarget: currentBlock.
	s55 := 0.
	self MoveCq: s55 R: Extra2Reg.
	currentBlock := self Label.
	jump4 jmpTarget: currentBlock.
	jump6 jmpTarget: currentBlock.
	jump7 jmpTarget: currentBlock.
	jump8 jmpTarget: currentBlock.
	jump9 jmpTarget: currentBlock.
	self CmpCq: 9 R: Extra1Reg.
	jump9 := self JumpBelow: 0.
	self CmpCq: 9 R: Extra1Reg.
	jump8 := self JumpAboveOrEqual: 0.
	jump7 := self JumpBelow: 0.
	currentBlock := self Label.
	jump9 jmpTarget: currentBlock.
	self CmpCq: 2 R: Extra1Reg.
	jump9 := self JumpNonZero: 0.
	currentBlock := self Label.
	jump8 jmpTarget: currentBlock.
	s62 := 0.
	self MoveCq: s62 R: ClassReg.
	jump8 := self Jump: 0.
	currentBlock := self Label.
	jump7 jmpTarget: currentBlock.
	jump9 jmpTarget: currentBlock.
	self CmpCq: 2 R: Extra1Reg.
	jump9 := self JumpAboveOrEqual: 0.
	self MoveR: Extra2Reg R: ClassReg.
	jump7 := self Jump: 0.
	currentBlock := self Label.
	jump9 jmpTarget: currentBlock.
	self MoveMw: 0 r: SPReg R: Extra3Reg.
	self MoveM64: 0 r: Extra3Reg R: ClassReg.
	self AndCq: 16r3FFFFF R: ClassReg.
	self CmpCq: 31 R: ClassReg.
	jump9 := self JumpAbove: 0.
	self CmpCq: 31 R: ClassReg.
	jump6 := self JumpNonZero: 0.
	self MoveMw: 0 r: SPReg R: Extra3Reg.
	self MoveR: Extra3Reg R: ClassReg.
	jump4 := self Jump: 0.
	currentBlock := self Label.
	jump6 jmpTarget: currentBlock.
	self CmpCq: 8 R: ClassReg.
	jump6 := self JumpNonZero: 0.
	self genMoveConstant: objectMemory nilObject R: ClassReg.
	jump5 := self Jump: 0.
	currentBlock := self Label.
	jump9 jmpTarget: currentBlock.
	jump6 jmpTarget: currentBlock.
	self MoveR: ClassReg R: SendNumArgsReg.
	self LogicalShiftRightCq: 10 R: SendNumArgsReg.
	s80 := objectMemory hiddenRootsObject.
	self LogicalShiftLeftCq: 3 R: SendNumArgsReg.
	self AddCq: s80 R: SendNumArgsReg.
	self MoveM64: 8 r: SendNumArgsReg R: SendNumArgsReg.
	self genMoveConstant: objectMemory nilObject R: Extra0Reg.
	self CmpR: Extra0Reg R: SendNumArgsReg.
	jump6 := self JumpNonZero: 0.
	self genMoveConstant: objectMemory nilObject R: Extra0Reg.
	jump9 := self Jump: 0.
	currentBlock := self Label.
	jump6 jmpTarget: currentBlock.
	self AndCq: 1023 R: ClassReg.
	self LogicalShiftLeftCq: 3 R: ClassReg.
	self AddR: ClassReg R: SendNumArgsReg.
	self MoveM64: 8 r: SendNumArgsReg R: Extra0Reg.
	currentBlock := self Label.
	jump9 jmpTarget: currentBlock.
	self MoveR: Extra0Reg R: ClassReg.
	currentBlock := self Label.
	jump4 jmpTarget: currentBlock.
	jump5 jmpTarget: currentBlock.
	self MoveM64: 24 r: ClassReg R: Extra0Reg.
	self ArithmeticShiftRightCq: 3 R: Extra0Reg.
	self AndCq: 16rFFFF R: Extra0Reg.
	self MoveR: Extra0Reg R: ClassReg.
	currentBlock := self Label.
	jump8 jmpTarget: currentBlock.
	jump7 jmpTarget: currentBlock.
	self SubR: ClassReg R: Extra2Reg.
	self CmpCq: 24 R: Extra1Reg.
	jump7 := self JumpAboveOrEqual: 0.
	self MoveMw: 8 r: SPReg R: Extra3Reg.
	self CmpCq: 1 R: Extra3Reg.
	jump8 := self JumpBelow: 0.
	self MoveMw: 8 r: SPReg R: Extra3Reg.
	self CmpR: Extra2Reg R: Extra3Reg.
	jump5 := self JumpAbove: 0.
	self MoveMw: 8 r: SPReg R: Extra3Reg.
	self AddR: ClassReg R: Extra3Reg.
	self MoveR: Extra3Reg Mw: 8 r: SPReg.
	self CmpCq: 5 R: Extra1Reg.
	jump4 := self JumpAbove: 0.
	self MoveMw: 8 r: SPReg R: Extra3Reg.
	self SubCq: 1 R: Extra3Reg.
	self MoveR: Extra3Reg Mw: 8 r: SPReg.
	self MoveMw: 0 r: SPReg R: Extra3Reg.
	self MoveR: Extra3Reg R: Extra0Reg.
	self AndCq: 7 R: Extra0Reg.
	self CmpCq: 0 R: Extra0Reg.
	jump9 := self JumpNonZero: 0.
	s116 := objectMemory getMemoryMap getSpaceMaskToUse.
	self MoveMw: 0 r: SPReg R: Extra3Reg.
	self MoveR: Extra3Reg R: Extra0Reg.
	self AndCq: s116 R: Extra0Reg.
	s119 := objectMemory getMemoryMap getOldSpaceMask.
	self CmpCq: s119 R: Extra0Reg.
	jump6 := self JumpNonZero: 0.
	self MoveMw: 16 r: SPReg R: Extra3Reg.
	self MoveR: Extra3Reg R: Extra0Reg.
	self AndCq: 7 R: Extra0Reg.
	self CmpCq: 0 R: Extra0Reg.
	jump10 := self JumpNonZero: 0.
	s124 := objectMemory getMemoryMap getSpaceMaskToUse.
	self MoveMw: 16 r: SPReg R: Extra3Reg.
	self MoveR: Extra3Reg R: Extra0Reg.
	self AndCq: s124 R: Extra0Reg.
	s127 := objectMemory getMemoryMap getNewSpaceMask.
	self CmpCq: s127 R: Extra0Reg.
	jump11 := self JumpNonZero: 0.
	s129 := objectMemory getMemoryMap getNewSpaceStart.
	self MoveMw: 16 r: SPReg R: Extra3Reg.
	self MoveR: Extra3Reg R: Extra0Reg.
	self CmpCq: s129 R: Extra0Reg.
	jumpTrue := self JumpAboveOrEqual: 0.
	self MoveCq: 0 R: Extra0Reg.
	jumpNext := self Jump: 0.
	jumpTrue jmpTarget: self Label.
	self MoveCq: 1 R: Extra0Reg.
	jumpNext jmpTarget: self Label.
	self CmpCq: 1 R: Extra0Reg.
	jump12 := self JumpNonZero: 0.
	self MoveMw: 0 r: SPReg R: Extra3Reg.
	self MoveM64: 0 r: Extra3Reg R: Extra0Reg.
	self LogicalShiftRightCq: 29 R: Extra0Reg.
	self AndCq: 1 R: Extra0Reg.
	self CmpCq: 0 R: Extra0Reg.
	jump13 := self JumpNonZero: 0.
	self MoveMw: 0 r: SPReg R: Extra3Reg.
	self MoveR: Extra3Reg R: TempReg.
	backEnd saveAndRestoreLinkRegAround: [
		self CallRT: ceStoreCheckTrampoline ].
	jump14 := self Jump: 0.
	currentBlock := self Label.
	jump11 jmpTarget: currentBlock.
	s140 := 0.
	currentBlock := self Label.
	jump9 jmpTarget: currentBlock.
	jump6 jmpTarget: currentBlock.
	jump10 jmpTarget: currentBlock.
	jump12 jmpTarget: currentBlock.
	jump13 jmpTarget: currentBlock.
	jump14 jmpTarget: currentBlock.
	self MoveMw: 0 r: SPReg R: Extra3Reg.
	self MoveM64: 0 r: Extra3Reg R: Extra0Reg.
	self LogicalShiftRightCq: 29 R: Extra0Reg.
	self AndCq: 1 R: Extra0Reg.
	self CmpCq: 0 R: Extra0Reg.
	jump14 := self JumpNonZero: 0.
	self MoveMw: 16 r: SPReg R: Extra3Reg.
	self TstCq: 7 R: Extra3Reg.
	jump13 := self JumpNonZero: 0.
	self MoveMw: 0 r: SPReg R: Extra3Reg.
	self CmpCq: 16r20000000000 R: Extra3Reg.
	jump12 := self JumpBelow: 0.
	self MoveMw: 16 r: SPReg R: Extra3Reg.
	self CmpCq: 16r20000000000 R: Extra3Reg.
	jump10 := self JumpAboveOrEqual: 0.
	self genMoveConstant: objectMemory nilObject R: Extra0Reg.
	self MoveMw: 16 r: SPReg R: Extra3Reg.
	self CmpR: Extra0Reg R: Extra3Reg.
	jump6 := self JumpBelow: 0.
	s152 := objectMemory trueObject.
	self MoveMw: 16 r: SPReg R: Extra3Reg.
	self CmpCq: s152 R: Extra3Reg.
	jump9 := self JumpBelowOrEqual: 0.
	currentBlock := self Label.
	jump6 jmpTarget: currentBlock.
	s154 := objectMemory getMemoryMap getNewSpaceStart.
	self MoveMw: 16 r: SPReg R: Extra3Reg.
	self CmpCq: s154 R: Extra3Reg.
	jump6 := self JumpBelow: 0.
	self MoveMw: 0 r: SPReg R: Extra3Reg.
	self MoveR: Extra3Reg R: TempReg.
	backEnd saveAndRestoreLinkRegAround: [
		self CallRT: ceStoreCheckTrampoline ].
	currentBlock := self Label.
	jump14 jmpTarget: currentBlock.
	jump13 jmpTarget: currentBlock.
	jump12 jmpTarget: currentBlock.
	jump10 jmpTarget: currentBlock.
	jump9 jmpTarget: currentBlock.
	jump6 jmpTarget: currentBlock.

	s158 := 0.
	"GET INDEX"
	self MoveMw: 8 r: SPReg R: Extra3Reg.
	self LogicalShiftLeftCq: 3 R: Extra3Reg.
	self MoveR: Extra3Reg Mw: 8 r: SPReg.

	self MoveMw: 0 r: SPReg R: Extra3Reg.
	self MoveMw: 8 r: SPReg R: Extra4Reg.
	self AddR: Extra4Reg R: Extra3Reg.
	self MoveR: Extra3Reg Mw: 0 r: SPReg.

	self MoveMw: 16 r: SPReg R: Extra3Reg.
	self MoveMw: 0 r: SPReg R: Extra4Reg.
	self MoveR: Extra3Reg M64: 8 r: Extra4Reg.
	
	
	
	self MoveCq: s158 R: Extra0Reg.
	jump6 := self Jump: 0.
	currentBlock := self Label.
	jump4 jmpTarget: currentBlock.
	self CmpCq: 16 R: Extra1Reg.
	jump4 := self JumpBelow: 0.
	self MoveMw: 16 r: SPReg R: Extra3Reg.
	self TstCq: 1 R: Extra3Reg.
	jump9 := self JumpZero: 0.
	self MoveMw: 16 r: SPReg R: Extra3Reg.
	self MoveR: Extra3Reg R: Extra0Reg.
	self ArithmeticShiftRightCq: 3 R: Extra0Reg.
	self CmpCq: 0 R: Extra0Reg.
	jump10 := self JumpBelow: 0.
	self CmpCq: 255 R: Extra0Reg.
	jump12 := self JumpAbove: 0.
	s170 := 0.
	self MoveMw: 8 r: SPReg R: Extra3Reg.
	self MoveMw: 0 r: SPReg R: Extra4Reg.
	self AddR: Extra4Reg R: Extra3Reg.
	self MoveR: Extra3Reg Mw: 8 r: SPReg.
	self MoveMw: 8 r: SPReg R: Extra3Reg.
	self AddCq:  -1 R: Extra3Reg.
	self MoveR: Extra3Reg Mw: 8 r: SPReg.
	self MoveMw: 8 r: SPReg R: Extra3Reg.
	self MoveR: Extra0Reg Mb: 8 r: Extra3Reg.
	self MoveCq: s170 R: Extra0Reg.
	jump13 := self Jump: 0.
	currentBlock := self Label.
	jump10 jmpTarget: currentBlock.
	jump12 jmpTarget: currentBlock.
	s176 := 3.
	self MoveCq: s176 R: Extra0Reg.
	jump12 := self Jump: 0.
	currentBlock := self Label.
	jump9 jmpTarget: currentBlock.
	s179 := 3.
	self MoveCq: 3 R: Extra0Reg.
	jump9 := self Jump: 0.
	currentBlock := self Label.
	jump4 jmpTarget: currentBlock.
	self CmpCq: 12 R: Extra1Reg.
	jump4 := self JumpBelow: 0.
	self MoveMw: 16 r: SPReg R: Extra3Reg.
	self TstCq: 1 R: Extra3Reg.
	jump10 := self JumpZero: 0.
	self MoveMw: 16 r: SPReg R: Extra3Reg.
	self MoveR: Extra3Reg R: Extra0Reg.
	self ArithmeticShiftRightCq: 3 R: Extra0Reg.
	self CmpCq: 0 R: Extra0Reg.
	jump14 := self JumpBelow: 0.
	self CmpCq: 16rFFFF R: Extra0Reg.
	jump11 := self JumpAbove: 0.
	self MoveMw: 8 r: SPReg R: Extra3Reg.
	self SubCq: 1 R: Extra3Reg.
	self MoveR: Extra3Reg Mw: 8 r: SPReg.
	self MoveMw: 8 r: SPReg R: Extra3Reg.
	self LogicalShiftLeftCq: 1 R: Extra3Reg.
	self MoveR: Extra3Reg Mw: 8 r: SPReg.
	self MoveMw: 0 r: SPReg R: Extra3Reg.
	self MoveMw: 8 r: SPReg R: Extra4Reg.
	self AddR: Extra4Reg R: Extra3Reg.
	self MoveR: Extra3Reg Mw: 0 r: SPReg.
	self MoveMw: 0 r: SPReg R: Extra3Reg.
	self MoveR: Extra3Reg R: Extra2Reg.
	self AddCq: 8 R: Extra2Reg.
	self MoveR: Extra2Reg R: Extra1Reg.
	self AndCq: 2 R: Extra1Reg.
	self CmpCq: 0 R: Extra1Reg.
	jump15 := self JumpNonZero: 0.
	self MoveMw: 0 r: SPReg R: Extra3Reg.
	self MoveM32: 8 r: Extra3Reg R: Extra1Reg.
	self AndCq: 16rFFFFFFFF R: Extra1Reg.
	self AndCq: 16rFFFF0000 R: Extra1Reg.
	self OrR: Extra0Reg R: Extra1Reg.
	self MoveMw: 0 r: SPReg R: Extra3Reg.
	self MoveR: Extra1Reg M32: 8 r: Extra3Reg.
	jump16 := self Jump: 0.
	currentBlock := self Label.
	jump15 jmpTarget: currentBlock.
	self MoveM32: -2 r: Extra2Reg R: Extra1Reg.
	self AndCq: 16rFFFFFFFF R: Extra1Reg.
	self AndCq: 16rFFFF R: Extra1Reg.
	self LogicalShiftLeftCq: 16 R: Extra0Reg.
	self OrR: Extra0Reg R: Extra1Reg.
	self MoveR: Extra1Reg M32: -2 r: Extra2Reg.
	currentBlock := self Label.
	jump16 jmpTarget: currentBlock.
	s209 := 0.
	self MoveCq: s209 R: Extra0Reg.
	currentBlock := self Label.
	jump6 jmpTarget: currentBlock.
	jump13 jmpTarget: currentBlock.
	jump12 jmpTarget: currentBlock.
	currentBlock := self Label.
	jump9 jmpTarget: currentBlock.
	self CmpCq: 0 R: Extra0Reg.
	jump9 := self JumpNonZero: 0.
	self MoveR: Extra0Reg R: Extra1Reg.

	self MoveMw: 16 r: SPReg R: Extra2Reg.

	self MoveR: Extra2Reg R: ReceiverResultReg.
	self CmpCq: 0 R: Extra1Reg.
	jump12 := self JumpZero: 0.
	jump13 := self JumpNonZero: 0.
	currentBlock := self Label.
	jump9 jmpTarget: currentBlock.
	self MoveR: Extra0Reg R: Extra2Reg.
	jump9 := self Jump: 0.
	currentBlock := self Label.
	jump14 jmpTarget: currentBlock.
	jump11 jmpTarget: currentBlock.
	s224 := 3.
	self MoveCq: s224 R: Extra2Reg.
	currentBlock := self Label.
	jump9 jmpTarget: currentBlock.
	self MoveMw: 16 r: SPReg R: Extra3Reg.
	self MoveR: Extra3Reg R: ReceiverResultReg.
	self CmpCq: 0 R: Extra2Reg.
	jump9 := self JumpNonZero: 0.
	currentBlock := self Label.
	jump12 jmpTarget: currentBlock.
	self AddCq: 24 R: SPReg.
	self genPrimReturn.
	currentBlock := self Label.
	jump10 jmpTarget: currentBlock.
	s233 := 3.
	self MoveMw: 16 r: SPReg R: Extra3Reg.
	self MoveR: Extra3Reg R: ReceiverResultReg.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	jump3 jmpTarget: currentBlock.
	jump2 jmpTarget: currentBlock.
	jump7 jmpTarget: currentBlock.
	jump8 jmpTarget: currentBlock.
	jump5 jmpTarget: currentBlock.
	jump4 jmpTarget: currentBlock.
	jump13 jmpTarget: currentBlock.
	jump9 jmpTarget: currentBlock.
	self AddCq: 24 R: SPReg.
	^ 0
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveBitAnd [
	"AutoGenerated by Druid"

	| jump1 currentBlock |
	self MoveR: ReceiverResultReg R: ClassReg.
	self MoveR: Arg0Reg R: SendNumArgsReg.
	self MoveR: SendNumArgsReg R: Extra0Reg.
	self AndR: ClassReg R: Extra0Reg.
	self TstCq: 1 R: Extra0Reg.
	jump1 := self JumpZero: 0.
	self AndR: ClassReg R: SendNumArgsReg.
	self MoveR: SendNumArgsReg R: ReceiverResultReg.
	self genPrimReturn.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	^ 0
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveBitShift [
	"AutoGenerated by Druid"

	| jump1 currentBlock |
	self MoveR: ReceiverResultReg R: ClassReg.
	self MoveR: Arg0Reg R: SendNumArgsReg.
	self CmpCq: 0 R: SendNumArgsReg.
	jump1 := self JumpLessOrEqual: 0.
	self LogicalShiftLeftR: SendNumArgsReg R: ClassReg.
	self MoveR: ClassReg R: ReceiverResultReg.
	self genPrimReturn.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	self MoveR: SendNumArgsReg R: SendNumArgsReg.
	self NegateR: SendNumArgsReg.
	self LogicalShiftRightR: SendNumArgsReg R: ClassReg.
	self MoveR: ClassReg R: ReceiverResultReg.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveBitXor [
	"AutoGenerated by Druid"

	| currentBlock |
	self MoveR: ReceiverResultReg R: ClassReg.
	self MoveR: Arg0Reg R: SendNumArgsReg.
	self XorR: ClassReg R: SendNumArgsReg.
	self MoveR: SendNumArgsReg R: ReceiverResultReg.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveBranchingWithAssigments [
	"AutoGenerated by Druid"

	| jump1 currentBlock |
	self MoveR: ReceiverResultReg R: ClassReg.
	self CmpCq: 0 R: ClassReg.
	jump1 := self JumpLessOrEqual: 0.
	self MoveCq: 17 R: ReceiverResultReg.
	self genPrimReturn.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	self MoveCq: 42 R: ReceiverResultReg.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveByteAt [

	| currentBlock |
	self MoveCq: 0 R: TempReg.
	self MoveMb: 0 r: ReceiverResultReg R: TempReg.
	self MoveR: TempReg R: ReceiverResultReg.
	self RetN: 1 * objectMemory wordSize.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveCallingBlockReadingExternalTemp [
	"AutoGenerated by Druid"

	| currentBlock |
	self MoveCq: 17 R: ReceiverResultReg.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveCallingBlockReturningArgument [
	"AutoGenerated by Druid"

	| currentBlock |
	self MoveCq: 17 R: ReceiverResultReg.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveCallingBlockReturningConstant [
	"AutoGenerated by Druid"

	| currentBlock |
	self MoveCq: 17 R: ReceiverResultReg.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveCallingBlockWithNonLocalReturn [
	"AutoGenerated by Druid"

	| currentBlock |
	self MoveCq: 17 R: ReceiverResultReg.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveCallingBlockWritingExternalTemp [
	"AutoGenerated by Druid"

	| currentBlock |
	self MoveCq: 17 R: ReceiverResultReg.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveCallingEmptyBlock [
	"AutoGenerated by Druid"

	| currentBlock |
	self MoveCq: 18 R: ReceiverResultReg.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveCallingMethodReturningConstant [
	"AutoGenerated by Druid"

	| currentBlock |
	self MoveCq: 73 R: ReceiverResultReg.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveCallingMethodWithEarlyReturn [
	"AutoGenerated by Druid"

	| jump1 currentBlock |
	self MoveR: ReceiverResultReg R: ClassReg.
	self CmpCq: 0 R: ClassReg.
	jump1 := self JumpNonZero: 0.
	self MoveCq: 42 R: ReceiverResultReg.
	self genPrimReturn.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	self MoveCq: 57 R: ReceiverResultReg.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveCascadedUint16AtPut [
	"AutoGenerated by Druid"

	| s6 currentBlock s3 |
	self MoveR: ReceiverResultReg R: ClassReg.
	s3 := 1.
	self MoveCq: s3 R: SendNumArgsReg.
	self MoveR: SendNumArgsReg M64: 0 r: ClassReg.
	s6 := 2.
	self MoveCq: s6 R: SendNumArgsReg.
	self MoveR: SendNumArgsReg M16: 2 r: ClassReg.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveCaseOfOtherwiseValue [
	"AutoGenerated by Druid"

	| jump1 currentBlock |
	self MoveR: ReceiverResultReg R: ClassReg.
	self CmpCq: 0 R: ClassReg.
	jump1 := self JumpNonZero: 0.
	self MoveCq: 57 R: ReceiverResultReg.
	self genPrimReturn.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	self CmpCq: 1 R: ClassReg.
	jump1 := self JumpNonZero: 0.
	self MoveCq: 42 R: ReceiverResultReg.
	self genPrimReturn.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	self MoveCq: 77 R: ReceiverResultReg.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveClass [
	"AutoGenerated by Druid"

	| s25 s71 s40 s2 currentBlock s3 |
	s2 := self methodNumArgs.
	s2 = 0 ifTrue: [
		| jump1 jump2 |
		self MoveR: ReceiverResultReg R: ClassReg.
		self MoveR: ClassReg R: SendNumArgsReg.
		self AndCq: 7 R: SendNumArgsReg.
		self CmpCq: 0 R: SendNumArgsReg.
		jump1 := self JumpZero: 0.
		self MoveAw: objectMemory hiddenRootsObject + 8 R: ClassReg.
		self LogicalShiftLeftCq: 3 R: SendNumArgsReg.
		self AddR: SendNumArgsReg R: ClassReg.
		self MoveM64: 8 r: ClassReg R: ClassReg.
		self MoveR: ClassReg R: ReceiverResultReg.
		self genPrimReturn.
		currentBlock := self Label.
		jump1 jmpTarget: currentBlock.
		self MoveM64: 0 r: ClassReg R: ClassReg.
		self AndCq: 16r3FFFFF R: ClassReg.
		self CmpCq: 31 R: ClassReg.
		jump1 := self JumpAbove: 0.
		self CmpCq: 31 R: ClassReg.
		jump2 := self JumpNonZero: 0.
		self genPrimReturn.
		currentBlock := self Label.
		jump2 jmpTarget: currentBlock.
		self CmpCq: 8 R: ClassReg.
		jump2 := self JumpNonZero: 0.
		self genMoveConstant: objectMemory nilObject R: ClassReg.
		self MoveR: ClassReg R: ReceiverResultReg.
		self genPrimReturn.
		currentBlock := self Label.
		jump1 jmpTarget: currentBlock.
		jump2 jmpTarget: currentBlock.
		self MoveR: ClassReg R: SendNumArgsReg.
		self LogicalShiftRightCq: 10 R: SendNumArgsReg.
		s25 := objectMemory hiddenRootsObject.
		self LogicalShiftLeftCq: 3 R: SendNumArgsReg.
		self AddCq: s25 R: SendNumArgsReg.
		self MoveM64: 8 r: SendNumArgsReg R: SendNumArgsReg.
		self genMoveConstant: objectMemory nilObject R: Extra0Reg.
		self CmpR: Extra0Reg R: SendNumArgsReg.
		jump2 := self JumpNonZero: 0.
		self genMoveConstant: objectMemory nilObject R: Extra0Reg.
		self MoveR: Extra0Reg R: ReceiverResultReg.
		self genPrimReturn.
		currentBlock := self Label.
		jump2 jmpTarget: currentBlock.
		self AndCq: 1023 R: ClassReg.
		self LogicalShiftLeftCq: 3 R: ClassReg.
		self AddR: ClassReg R: SendNumArgsReg.
		self MoveM64: 8 r: SendNumArgsReg R: Extra0Reg.
		self MoveR: Extra0Reg R: ReceiverResultReg.
		self genPrimReturn.
		^ 0 ].
	s40 := self methodNumArgs.
	s40 = 1 ifTrue: [
		| jump2 jump1 |
		self MoveR: Arg0Reg R: Extra0Reg.
		self MoveR: Extra0Reg R: SendNumArgsReg.
		self AndCq: 7 R: SendNumArgsReg.
		self CmpCq: 0 R: SendNumArgsReg.
		jump2 := self JumpNonZero: 0.
		self MoveM64: 0 r: Extra0Reg R: SendNumArgsReg.
		self AndCq: 16r3FFFF7 R: SendNumArgsReg.
		self CmpCq: 0 R: SendNumArgsReg.
		jump1 := self JumpNonZero: 0.
		currentBlock := self Label.
		jump2 jmpTarget: currentBlock.
		jump1 jmpTarget: currentBlock.
		self MoveR: Extra0Reg R: SendNumArgsReg.
		self AndCq: 7 R: SendNumArgsReg.
		self CmpCq: 0 R: SendNumArgsReg.
		jump1 := self JumpZero: 0.
		self MoveAw: objectMemory hiddenRootsObject + 8 R: Extra0Reg.
		self LogicalShiftLeftCq: 3 R: SendNumArgsReg.
		self AddR: SendNumArgsReg R: Extra0Reg.
		self MoveM64: 8 r: Extra0Reg R: Extra0Reg.
		self MoveR: Extra0Reg R: ReceiverResultReg.
		self genPrimReturn.
		currentBlock := self Label.
		jump1 jmpTarget: currentBlock.
		self MoveM64: 0 r: Extra0Reg R: SendNumArgsReg.
		self AndCq: 16r3FFFFF R: SendNumArgsReg.
		self CmpCq: 31 R: SendNumArgsReg.
		jump1 := self JumpAbove: 0.
		self CmpCq: 31 R: SendNumArgsReg.
		jump2 := self JumpNonZero: 0.
		self MoveR: Extra0Reg R: ReceiverResultReg.
		self genPrimReturn.
		currentBlock := self Label.
		jump2 jmpTarget: currentBlock.
		self CmpCq: 8 R: SendNumArgsReg.
		jump2 := self JumpNonZero: 0.
		self genMoveConstant: objectMemory nilObject R: SendNumArgsReg.
		self MoveR: SendNumArgsReg R: ReceiverResultReg.
		self genPrimReturn.
		currentBlock := self Label.
		jump1 jmpTarget: currentBlock.
		jump2 jmpTarget: currentBlock.
		self MoveR: SendNumArgsReg R: Extra0Reg.
		self LogicalShiftRightCq: 10 R: Extra0Reg.
		s71 := objectMemory hiddenRootsObject.
		self LogicalShiftLeftCq: 3 R: Extra0Reg.
		self AddCq: s71 R: Extra0Reg.
		self MoveM64: 8 r: Extra0Reg R: Extra0Reg.
		self genMoveConstant: objectMemory nilObject R: ClassReg.
		self CmpR: ClassReg R: Extra0Reg.
		jump2 := self JumpNonZero: 0.
		self genMoveConstant: objectMemory nilObject R: ClassReg.
		jump1 := self Jump: 0.
		currentBlock := self Label.
		jump2 jmpTarget: currentBlock.
		self AndCq: 1023 R: SendNumArgsReg.
		self LogicalShiftLeftCq: 3 R: SendNumArgsReg.
		self AddR: SendNumArgsReg R: Extra0Reg.
		self MoveM64: 8 r: Extra0Reg R: ClassReg.
		currentBlock := self Label.
		jump1 jmpTarget: currentBlock.
		self MoveR: ClassReg R: ReceiverResultReg.
		self genPrimReturn.
		^ 0 ].
	^ 0
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveClassVariable [
	"AutoGenerated by Druid"

	| currentBlock |
	self MoveCq: 34 R: ReceiverResultReg.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveClassVariableWithBranch [
	"AutoGenerated by Druid"

	| jump1 currentBlock |
	self MoveR: ReceiverResultReg R: ClassReg.
	self CmpCq: 0 R: ClassReg.
	jump1 := self JumpNonZero: 0.
	self MoveCq: 35 R: ReceiverResultReg.
	self genPrimReturn.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	self MoveCq: 36 R: ReceiverResultReg.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveConditionWithAnyMask [
	"AutoGenerated by Druid"

	| jump1 currentBlock |
	self MoveR: ReceiverResultReg R: ClassReg.
	self TstCq: 1 R: ClassReg.
	jump1 := self JumpZero: 0.
	self MoveCq: 1 R: ReceiverResultReg.
	self genPrimReturn.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	self MoveCq: 2 R: ReceiverResultReg.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveConditionWithAnyMaskInverted [
	"AutoGenerated by Druid"

	| jump1 currentBlock |
	self MoveR: ReceiverResultReg R: ClassReg.
	self TstCq: 1 R: ClassReg.
	jump1 := self JumpZero: 0.
	self MoveCq: 1 R: ReceiverResultReg.
	self genPrimReturn.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	self MoveCq: 2 R: ReceiverResultReg.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveConditionWithObjectReference [
	"AutoGenerated by Druid"

	| jump1 currentBlock s3 |
	self MoveR: ReceiverResultReg R: ClassReg.
	s3 := objectMemory trueObject.
	self CmpCq: s3 R: ClassReg.
	jump1 := self JumpAboveOrEqual: 0.
	self MoveCq: 1 R: ReceiverResultReg.
	self genPrimReturn.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	self MoveCq: 2 R: ReceiverResultReg.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveConstantFloatAsInteger [
	"AutoGenerated by Druid"

	| currentBlock |
	self MoveCq: 17 R: ReceiverResultReg.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveDNA [
	"AutoGenerated by Druid"

	| jump3 jump1 s4 currentBlock s7 jump2 |
	self MoveR: ReceiverResultReg R: ClassReg.
	self CmpCq: 10 R: ClassReg.
	jump1 := self JumpLessOrEqual: 0.
	s4 := 1.
	self MoveCq: s4 R: ClassReg.
	jump2 := self Jump: 0.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	s7 := 99.
	self CmpCq: 0 R: ClassReg.
	jump1 := self JumpLessOrEqual: 0.
	self CmpCq: 7 R: ClassReg.
	jump3 := self JumpLessOrEqual: 0.
	self MoveCq: s7 R: ClassReg.
	currentBlock := self Label.
	jump2 jmpTarget: currentBlock.
	self AddCq: 20 R: ClassReg.
	self MoveR: ClassReg R: ReceiverResultReg.
	self genPrimReturn.
	currentBlock := self Label.
	jump3 jmpTarget: currentBlock.
	self MoveCq: 146 R: ReceiverResultReg.
	self genPrimReturn.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	self MoveCq: 158 R: ReceiverResultReg.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveDeadBranchWithError [
	"AutoGenerated by Druid"

	| currentBlock |
	self MoveCq: 17 R: ReceiverResultReg.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveDecrement [

	| currentBlock |
	self MoveR: ReceiverResultReg R: TempReg.
	self SubCq: 1 R: TempReg.
	self MoveR: TempReg R: ReceiverResultReg.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveDecrementConstantArgument [
	"AutoGenerated by Druid"

	| currentBlock |
	self MoveR: ReceiverResultReg R: ClassReg.
	self SubCq: 1 R: ClassReg.
	self MoveR: ClassReg R: ReceiverResultReg.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveDecrementConstantReceiver [
	"AutoGenerated by Druid"

	| currentBlock s3 |
	self MoveR: ReceiverResultReg R: ClassReg.
	s3 := 42.
	self MoveCq: s3 R: SendNumArgsReg.
	self SubR: ClassReg R: SendNumArgsReg.
	self MoveR: SendNumArgsReg R: ReceiverResultReg.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveDivide [
	"AutoGenerated by Druid"

	| currentBlock |
	self MoveR: ReceiverResultReg R: ClassReg.
	self MoveR: Arg0Reg R: SendNumArgsReg.
	self
		DivR: SendNumArgsReg
		R: ClassReg
		Quo: ClassReg
		Rem: SendNumArgsReg.
	self MoveR: ClassReg R: ReceiverResultReg.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveDivideByConstant [
	"AutoGenerated by Druid"

	| currentBlock s3 |
	self MoveR: ReceiverResultReg R: ClassReg.
	s3 := 2.
	self MoveCq: s3 R: SendNumArgsReg.
	self
		DivR: SendNumArgsReg
		R: ClassReg
		Quo: SendNumArgsReg
		Rem: ClassReg.
	self MoveR: SendNumArgsReg R: ReceiverResultReg.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveDivisionAsFloat [
	"AutoGenerated by Druid"

	| currentBlock |
	self MoveR: ReceiverResultReg R: ClassReg.
	self MoveR: Arg0Reg R: SendNumArgsReg.
	self ConvertR: SendNumArgsReg Rd: DPFPReg0.
	self ConvertR: ClassReg Rd: DPFPReg1.
	self DivRd: DPFPReg1 Rd: DPFPReg0.
	self MoveRd: DPFPReg0 R: ClassReg.
	self MoveR: ClassReg R: ReceiverResultReg.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveDoubleBitAndSubtreeLeftVariableLeft [
	"AutoGenerated by Druid"

	| currentBlock |
	self MoveR: ReceiverResultReg R: ClassReg.
	self AndCq: 16r3FFFFF R: ClassReg.
	self MoveR: ClassReg R: ReceiverResultReg.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveDoubleBitAndSubtreeLeftVariableRight [
	"AutoGenerated by Druid"

	| currentBlock |
	self MoveR: ReceiverResultReg R: ClassReg.
	self AndCq: 16r3FFFFF R: ClassReg.
	self MoveR: ClassReg R: ReceiverResultReg.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveDoubleBitAndSubtreeRightVariableLeft [
	"AutoGenerated by Druid"

	| currentBlock |
	self MoveR: ReceiverResultReg R: ClassReg.
	self AndCq: 16r3FFFFF R: ClassReg.
	self MoveR: ClassReg R: ReceiverResultReg.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveDoubleBitAndSubtreeRightVariableRight [
	"AutoGenerated by Druid"

	| currentBlock |
	self MoveR: ReceiverResultReg R: ClassReg.
	self AndCq: 16r3FFFFF R: ClassReg.
	self MoveR: ClassReg R: ReceiverResultReg.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveDoubleDeferredInline [
	"AutoGenerated by Druid"

	| jump1 currentBlock |
	self MoveR: ReceiverResultReg R: TempReg.
	self MoveCq: 0 R: ClassReg.
	self MoveR: ClassReg Aw: coInterpreter primitiveFailureCodeAddress.
	self MoveAw: coInterpreter primitiveFailureCodeAddress R: ClassReg.
	self MoveR: Arg0Reg R: SendNumArgsReg.
	self MoveCq: 2 R: SendNumArgsReg.
	self MulR: TempReg R: SendNumArgsReg.
	self MoveR: ClassReg Aw: coInterpreter primitiveFailureCodeAddress.
	self MoveAw: coInterpreter primitiveFailureCodeAddress R: ClassReg.
	self MoveR: SendNumArgsReg R: ReceiverResultReg.
	self CmpCq: 0 R: ClassReg.
	jump1 := self JumpNonZero: 0.
	self genPrimReturn.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveEqualsThan [
	"AutoGenerated by Druid"

	| jump1 currentBlock |
	self MoveR: ReceiverResultReg R: ClassReg.
	self CmpCq: 10 R: ClassReg.
	jump1 := self JumpNonZero: 0.
	self MoveCq: 5 R: ReceiverResultReg.
	self genPrimReturn.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	self MoveCq: 11 R: ReceiverResultReg.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveEqualsThanFloatConstant [
	"AutoGenerated by Druid"

	| jumpNext currentBlock jumpTrue |
	self MoveR: ReceiverResultReg R: ClassReg.
	self ConvertR: ClassReg Rd: DPFPReg0.
	self MoveCq: (objectMemory rawFloatBitsOf: 0.0) R: ClassReg.
	self MoveR: ClassReg Rd: DPFPReg1.
	self CmpRd: DPFPReg1 Rd: DPFPReg0.
	jumpTrue := self JumpFPEqual: 0.
	self MoveCq: 0 R: ClassReg.
	jumpNext := self Jump: 0.
	jumpTrue jmpTarget: self Label.
	self MoveCq: 1 R: ClassReg.
	jumpNext jmpTarget: self Label.
	self MoveR: ClassReg R: ReceiverResultReg.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveEqualsThanFloats [
	"AutoGenerated by Druid"

	| jumpNext currentBlock jumpTrue |
	self MoveR: ReceiverResultReg R: ClassReg.
	self MoveR: Arg0Reg R: SendNumArgsReg.
	self ConvertR: SendNumArgsReg Rd: DPFPReg0.
	self ConvertR: ClassReg Rd: DPFPReg1.
	self CmpRd: DPFPReg1 Rd: DPFPReg0.
	jumpTrue := self JumpFPEqual: 0.
	self MoveCq: 0 R: ClassReg.
	jumpNext := self Jump: 0.
	jumpTrue jmpTarget: self Label.
	self MoveCq: 1 R: ClassReg.
	jumpNext jmpTarget: self Label.
	self MoveR: ClassReg R: ReceiverResultReg.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveEqualsThanInverted [
	"AutoGenerated by Druid"

	| jump1 currentBlock |
	self MoveR: ReceiverResultReg R: ClassReg.
	self CmpCq: 10 R: ClassReg.
	jump1 := self JumpNonZero: 0.
	self MoveCq: 5 R: ReceiverResultReg.
	self genPrimReturn.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	self MoveCq: 11 R: ReceiverResultReg.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveEqualsThanReferenceValue [

	| jumpNext currentBlock jumpTrue |
	self MoveR: ReceiverResultReg R: TempReg.
	self CmpCw: objectMemory trueObject R: TempReg.
	jumpTrue := self JumpZero: 0.
	self MoveCq: 0 R: TempReg.
	jumpNext := self Jump: 0.
	jumpTrue jmpTarget: self Label.
	self MoveCq: 1 R: TempReg.
	jumpNext jmpTarget: self Label.
	self MoveR: TempReg R: ReceiverResultReg.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveEqualsThanValue [
	"AutoGenerated by Druid"

	| jumpTrue jumpNext currentBlock s3 |
	self MoveR: ReceiverResultReg R: ClassReg.
	s3 := 0.
	self CmpCq: s3 R: ClassReg.
	jumpTrue := self JumpZero: 0.
	self MoveCq: 0 R: ClassReg.
	jumpNext := self Jump: 0.
	jumpTrue jmpTarget: self Label.
	self MoveCq: 1 R: ClassReg.
	jumpNext jmpTarget: self Label.
	self MoveR: ClassReg R: ReceiverResultReg.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveFalseAsInteger [
	"AutoGenerated by Druid"

	| currentBlock |
	self MoveCq: 0 R: ReceiverResultReg.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveFalseAssignmentAsInteger [
	"AutoGenerated by Druid"

	| currentBlock |
	self MoveCq: 0 R: ReceiverResultReg.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveFalseNot [
	"AutoGenerated by Druid"

	| currentBlock |
	self MoveCq: 1 R: ReceiverResultReg.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveFloat64At [
	"AutoGenerated by Druid"

	| currentBlock |
	self MoveR: ReceiverResultReg R: ClassReg.
	self MoveM64: 0 r: ClassReg Rd: DPFPReg0.
	self MoveRd: DPFPReg0 R: ClassReg.
	self MoveR: ClassReg R: ReceiverResultReg.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveFloat64AtPut [
	"AutoGenerated by Druid"

	| currentBlock |
	self MoveR: ReceiverResultReg R: ClassReg.
	self MoveR: Arg0Reg R: SendNumArgsReg.
	self ConvertR: SendNumArgsReg Rd: DPFPReg0.
	self MoveRd: DPFPReg0 M64: 0 r: ClassReg.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveFloatAdd [
	"AutoGenerated by Druid"

	| jump1 s123 jumpNext s98 s126 jump9 jump6 jump3 jump10 currentBlock s91 jump5 jump2 jump8 jumpTrue jump11 jump7 jump4 |
	self MoveR: ReceiverResultReg R: ClassReg.
	self MoveR: Arg0Reg R: SendNumArgsReg.
	self MoveR: ClassReg R: Extra0Reg.
	self AndCq: 7 R: Extra0Reg.
	self CmpCq: 0 R: Extra0Reg.
	jump1 := self JumpZero: 0.
	self CmpCq: 4 R: Extra0Reg.
	jump2 := self JumpNonZero: 0.
	self MoveR: ClassReg R: Extra0Reg.
	self LogicalShiftRightCq: 3 R: Extra0Reg.
	self CmpCq: 1 R: Extra0Reg.
	jump3 := self JumpBelowOrEqual: 0.
	self AddCq: 16r7000000000000000 R: Extra0Reg.
	jump4 := self Jump: 0.
	currentBlock := self Label.
	jump3 jmpTarget: currentBlock.
	currentBlock := self Label.
	jump4 jmpTarget: currentBlock.
	self MoveR: Extra0Reg R: ClassReg.
	self LogicalShiftLeftCq: 63 R: ClassReg.
	self LogicalShiftRightCq: 1 R: Extra0Reg.
	self AddR: Extra0Reg R: ClassReg.
	self MoveR: ClassReg Rd: DPFPReg0.
	jump4 := self Jump: 0.
	currentBlock := self Label.
	jump2 jmpTarget: currentBlock.
	self CmpCq: 1 R: Extra0Reg.
	jump2 := self JumpNonZero: 0.
	self MoveR: ClassReg R: Extra0Reg.
	self LogicalShiftLeftCq: 9 R: Extra0Reg.
	self ArithmeticShiftRightCq: 9 R: Extra0Reg.
	self CmpR: ClassReg R: Extra0Reg.
	jump3 := self JumpNonZero: 0.
	self ArithmeticShiftRightCq: 3 R: ClassReg.
	self ConvertR: ClassReg Rd: DPFPReg0.
	jump5 := self Jump: 0.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	self MoveM64: 0 r: ClassReg R: Extra0Reg.
	self AndCq: 16r3FFFFF R: Extra0Reg.
	self CmpCq: 34 R: Extra0Reg.
	jump1 := self JumpNonZero: 0.
	self MoveM64: 8 r: ClassReg Rd: DPFPReg0.
	currentBlock := self Label.
	jump4 jmpTarget: currentBlock.
	jump5 jmpTarget: currentBlock.
	self MoveR: SendNumArgsReg R: Extra0Reg.
	self AndCq: 7 R: Extra0Reg.
	self CmpCq: 0 R: Extra0Reg.
	jump5 := self JumpZero: 0.
	self CmpCq: 4 R: Extra0Reg.
	jump4 := self JumpNonZero: 0.
	self MoveR: SendNumArgsReg R: Extra0Reg.
	self LogicalShiftRightCq: 3 R: Extra0Reg.
	self CmpCq: 1 R: Extra0Reg.
	jump6 := self JumpBelowOrEqual: 0.
	self AddCq: 16r7000000000000000 R: Extra0Reg.
	jump7 := self Jump: 0.
	currentBlock := self Label.
	jump6 jmpTarget: currentBlock.
	currentBlock := self Label.
	jump7 jmpTarget: currentBlock.
	self MoveR: Extra0Reg R: SendNumArgsReg.
	self LogicalShiftLeftCq: 63 R: SendNumArgsReg.
	self LogicalShiftRightCq: 1 R: Extra0Reg.
	self AddR: Extra0Reg R: SendNumArgsReg.
	self MoveR: SendNumArgsReg Rd: DPFPReg1.
	jump7 := self Jump: 0.
	currentBlock := self Label.
	jump4 jmpTarget: currentBlock.
	self CmpCq: 1 R: Extra0Reg.
	jump4 := self JumpNonZero: 0.
	self MoveR: SendNumArgsReg R: Extra0Reg.
	self LogicalShiftLeftCq: 9 R: Extra0Reg.
	self ArithmeticShiftRightCq: 9 R: Extra0Reg.
	self CmpR: SendNumArgsReg R: Extra0Reg.
	jump6 := self JumpNonZero: 0.
	self ArithmeticShiftRightCq: 3 R: SendNumArgsReg.
	self ConvertR: SendNumArgsReg Rd: DPFPReg1.
	jump8 := self Jump: 0.
	currentBlock := self Label.
	jump5 jmpTarget: currentBlock.
	self MoveM64: 0 r: SendNumArgsReg R: Extra0Reg.
	self AndCq: 16r3FFFFF R: Extra0Reg.
	self CmpCq: 34 R: Extra0Reg.
	jump5 := self JumpNonZero: 0.
	self MoveM64: 8 r: SendNumArgsReg Rd: DPFPReg1.
	currentBlock := self Label.
	jump7 jmpTarget: currentBlock.
	jump8 jmpTarget: currentBlock.
	self AddRd: DPFPReg1 Rd: DPFPReg0.
	self MoveRd: DPFPReg0 R: Extra0Reg.
	self MoveR: Extra0Reg R: SendNumArgsReg.
	self LogicalShiftRightCq: 52 R: SendNumArgsReg.
	self AndCq: 2047 R: SendNumArgsReg.
	self CmpCq: 896 R: SendNumArgsReg.
	jump8 := self JumpBelowOrEqual: 0.
	self CmpCq: 1151 R: SendNumArgsReg.
	jump7 := self JumpBelowOrEqual: 0.
	jump9 := self JumpAbove: 0.
	currentBlock := self Label.
	jump8 jmpTarget: currentBlock.
	self AndCq: 16rFFFFFFFFFFFFF R: Extra0Reg.
	self CmpCq: 0 R: Extra0Reg.
	jump8 := self JumpNonZero: 0.
	s91 := 0.
	self CmpCq: s91 R: SendNumArgsReg.
	jumpTrue := self JumpZero: 0.
	self MoveCq: 0 R: SendNumArgsReg.
	jumpNext := self Jump: 0.
	jumpTrue jmpTarget: self Label.
	self MoveCq: 1 R: SendNumArgsReg.
	jumpNext jmpTarget: self Label.
	self CmpCq: 1 R: SendNumArgsReg.
	jump10 := self JumpZero: 0.
	jump11 := self JumpNonZero: 0.
	currentBlock := self Label.
	jump8 jmpTarget: currentBlock.
	s98 := 896.
	self CmpCq: s98 R: SendNumArgsReg.
	jumpTrue := self JumpZero: 0.
	self MoveCq: 0 R: SendNumArgsReg.
	jumpNext := self Jump: 0.
	jumpTrue jmpTarget: self Label.
	self MoveCq: 1 R: SendNumArgsReg.
	jumpNext jmpTarget: self Label.
	self CmpCq: 1 R: SendNumArgsReg.
	jump8 := self JumpNonZero: 0.
	currentBlock := self Label.
	jump10 jmpTarget: currentBlock.
	currentBlock := self Label.
	jump7 jmpTarget: currentBlock.
	self MoveRd: DPFPReg0 R: SendNumArgsReg.
	self RotateLeftCq: 1 R: SendNumArgsReg.
	self CmpCq: 1 R: SendNumArgsReg.
	jump7 := self JumpBelowOrEqual: 0.
	self SubCq: 16r7000000000000000 R: SendNumArgsReg.
	jump10 := self Jump: 0.
	currentBlock := self Label.
	jump7 jmpTarget: currentBlock.
	currentBlock := self Label.
	jump10 jmpTarget: currentBlock.
	self LogicalShiftLeftCq: 3 R: SendNumArgsReg.
	self AddCq: 4 R: SendNumArgsReg.
	jump10 := self Jump: 0.
	currentBlock := self Label.
	jump11 jmpTarget: currentBlock.
	jump8 jmpTarget: currentBlock.
	currentBlock := self Label.
	jump9 jmpTarget: currentBlock.
	self MoveAw: objectMemory freeStartAddress R: SendNumArgsReg.
	self MoveAw: objectMemory freeStartAddress R: Extra0Reg.
	self AddCq: 16 R: Extra0Reg.
	s123 := objectMemory getScavengeThreshold.
	self CmpCq: s123 R: Extra0Reg.
	jump9 := self JumpAbove: 0.
	s126 := 72057594205700130.
	self MoveCq: s126 R: Extra0Reg.
	self MoveR: Extra0Reg M64: 0 r: SendNumArgsReg.
	self MoveAw: objectMemory freeStartAddress R: Extra0Reg.
	self AddCq: 16 R: Extra0Reg.
	self MoveR: Extra0Reg Aw: objectMemory freeStartAddress.
	self MoveRd: DPFPReg0 M64: 8 r: SendNumArgsReg.
	currentBlock := self Label.
	jump10 jmpTarget: currentBlock.
	self MoveR: SendNumArgsReg R: ReceiverResultReg.
	self genPrimReturn.
	currentBlock := self Label.
	jump9 jmpTarget: currentBlock.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	currentBlock := self Label.
	jump5 jmpTarget: currentBlock.
	currentBlock := self Label.
	jump3 jmpTarget: currentBlock.
	currentBlock := self Label.
	jump6 jmpTarget: currentBlock.
	currentBlock := self Label.
	jump4 jmpTarget: currentBlock.
	currentBlock := self Label.
	jump2 jmpTarget: currentBlock.
	^ 0
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveFloatDivide [
	"AutoGenerated by Druid"

	| jump1 jump10 jumpNext jump9 jump6 jump3 s119 currentBlock jump8 jump5 jump2 s121 jumpTrue jump7 jump4 |
	self MoveR: ReceiverResultReg R: ClassReg.
	self MoveR: Arg0Reg R: SendNumArgsReg.
	self MoveR: ClassReg R: Extra0Reg.
	self AndCq: 7 R: Extra0Reg.
	self CmpCq: 0 R: Extra0Reg.
	jump1 := self JumpZero: 0.
	self CmpCq: 4 R: Extra0Reg.
	jump2 := self JumpNonZero: 0.
	self MoveR: ClassReg R: Extra0Reg.
	self LogicalShiftRightCq: 3 R: Extra0Reg.
	self CmpCq: 1 R: Extra0Reg.
	jump3 := self JumpBelowOrEqual: 0.
	self AddCq: 16r7000000000000000 R: Extra0Reg.
	jump4 := self Jump: 0.
	currentBlock := self Label.
	jump3 jmpTarget: currentBlock.
	currentBlock := self Label.
	jump4 jmpTarget: currentBlock.
	self MoveR: Extra0Reg R: ClassReg.
	self LogicalShiftLeftCq: 63 R: ClassReg.
	self LogicalShiftRightCq: 1 R: Extra0Reg.
	self AddR: Extra0Reg R: ClassReg.
	self MoveR: ClassReg Rd: DPFPReg0.
	jump4 := self Jump: 0.
	currentBlock := self Label.
	jump2 jmpTarget: currentBlock.
	self CmpCq: 1 R: Extra0Reg.
	jump2 := self JumpNonZero: 0.
	self MoveR: ClassReg R: Extra0Reg.
	self LogicalShiftLeftCq: 9 R: Extra0Reg.
	self ArithmeticShiftRightCq: 9 R: Extra0Reg.
	self CmpR: ClassReg R: Extra0Reg.
	jump3 := self JumpNonZero: 0.
	self ArithmeticShiftRightCq: 3 R: ClassReg.
	self ConvertR: ClassReg Rd: DPFPReg0.
	jump5 := self Jump: 0.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	self MoveM64: 0 r: ClassReg R: Extra0Reg.
	self AndCq: 16r3FFFFF R: Extra0Reg.
	self CmpCq: 34 R: Extra0Reg.
	jump1 := self JumpNonZero: 0.
	self MoveM64: 8 r: ClassReg Rd: DPFPReg0.
	currentBlock := self Label.
	jump4 jmpTarget: currentBlock.
	jump5 jmpTarget: currentBlock.
	self MoveR: SendNumArgsReg R: Extra0Reg.
	self AndCq: 7 R: Extra0Reg.
	self CmpCq: 0 R: Extra0Reg.
	jump5 := self JumpZero: 0.
	self CmpCq: 4 R: Extra0Reg.
	jump4 := self JumpNonZero: 0.
	self MoveR: SendNumArgsReg R: Extra0Reg.
	self LogicalShiftRightCq: 3 R: Extra0Reg.
	self CmpCq: 1 R: Extra0Reg.
	jump6 := self JumpBelowOrEqual: 0.
	self AddCq: 16r7000000000000000 R: Extra0Reg.
	jump7 := self Jump: 0.
	currentBlock := self Label.
	jump6 jmpTarget: currentBlock.
	currentBlock := self Label.
	jump7 jmpTarget: currentBlock.
	self MoveR: Extra0Reg R: SendNumArgsReg.
	self LogicalShiftLeftCq: 63 R: SendNumArgsReg.
	self LogicalShiftRightCq: 1 R: Extra0Reg.
	self AddR: Extra0Reg R: SendNumArgsReg.
	self MoveR: SendNumArgsReg Rd: DPFPReg1.
	jump7 := self Jump: 0.
	currentBlock := self Label.
	jump4 jmpTarget: currentBlock.
	self CmpCq: 1 R: Extra0Reg.
	jump4 := self JumpNonZero: 0.
	self MoveR: SendNumArgsReg R: Extra0Reg.
	self LogicalShiftLeftCq: 9 R: Extra0Reg.
	self ArithmeticShiftRightCq: 9 R: Extra0Reg.
	self CmpR: SendNumArgsReg R: Extra0Reg.
	jump6 := self JumpNonZero: 0.
	self ArithmeticShiftRightCq: 3 R: SendNumArgsReg.
	self ConvertR: SendNumArgsReg Rd: DPFPReg1.
	jump8 := self Jump: 0.
	currentBlock := self Label.
	jump5 jmpTarget: currentBlock.
	self MoveM64: 0 r: SendNumArgsReg R: Extra0Reg.
	self AndCq: 16r3FFFFF R: Extra0Reg.
	self CmpCq: 34 R: Extra0Reg.
	jump5 := self JumpNonZero: 0.
	self MoveM64: 8 r: SendNumArgsReg Rd: DPFPReg1.
	currentBlock := self Label.
	jump7 jmpTarget: currentBlock.
	jump8 jmpTarget: currentBlock.
	self CmpCq: 0.0 Rd: DPFPReg1.
	jump8 := self JumpFPEqual: 0.
	self DivRd: DPFPReg1 Rd: DPFPReg0.
	self MoveRd: DPFPReg0 R: Extra0Reg.
	self MoveR: Extra0Reg R: SendNumArgsReg.
	self LogicalShiftRightCq: 52 R: SendNumArgsReg.
	self AndCq: 2047 R: SendNumArgsReg.
	self CmpCq: 896 R: SendNumArgsReg.
	jump7 := self JumpBelowOrEqual: 0.
	self CmpCq: 1151 R: SendNumArgsReg.
	jumpTrue := self JumpBelowOrEqual: 0.
	self MoveCq: 0 R: SendNumArgsReg.
	jumpNext := self Jump: 0.
	jumpTrue jmpTarget: self Label.
	self MoveCq: 1 R: SendNumArgsReg.
	jumpNext jmpTarget: self Label.
	jump9 := self Jump: 0.
	currentBlock := self Label.
	jump7 jmpTarget: currentBlock.
	self AndCq: 16rFFFFFFFFFFFFF R: Extra0Reg.
	self CmpCq: 0 R: Extra0Reg.
	jump7 := self JumpNonZero: 0.
	self CmpCq: 0 R: SendNumArgsReg.
	jumpTrue := self JumpZero: 0.
	self MoveCq: 0 R: SendNumArgsReg.
	jumpNext := self Jump: 0.
	jumpTrue jmpTarget: self Label.
	self MoveCq: 1 R: SendNumArgsReg.
	jumpNext jmpTarget: self Label.
	jump10 := self Jump: 0.
	currentBlock := self Label.
	jump7 jmpTarget: currentBlock.
	self CmpCq: 896 R: SendNumArgsReg.
	jumpTrue := self JumpZero: 0.
	self MoveCq: 0 R: SendNumArgsReg.
	jumpNext := self Jump: 0.
	jumpTrue jmpTarget: self Label.
	self MoveCq: 1 R: SendNumArgsReg.
	jumpNext jmpTarget: self Label.
	currentBlock := self Label.
	jump10 jmpTarget: currentBlock.
	currentBlock := self Label.
	jump9 jmpTarget: currentBlock.
	self CmpCq: 1 R: SendNumArgsReg.
	jump9 := self JumpNonZero: 0.
	self MoveRd: DPFPReg0 R: SendNumArgsReg.
	self RotateLeftCq: 1 R: SendNumArgsReg.
	self CmpCq: 1 R: SendNumArgsReg.
	jump10 := self JumpBelowOrEqual: 0.
	self SubCq: 16r7000000000000000 R: SendNumArgsReg.
	jump7 := self Jump: 0.
	currentBlock := self Label.
	jump10 jmpTarget: currentBlock.
	currentBlock := self Label.
	jump7 jmpTarget: currentBlock.
	self LogicalShiftLeftCq: 3 R: SendNumArgsReg.
	self AddCq: 4 R: SendNumArgsReg.
	self MoveR: SendNumArgsReg R: ReceiverResultReg.
	jump7 := self Jump: 0.
	currentBlock := self Label.
	jump9 jmpTarget: currentBlock.
	self MoveAw: objectMemory freeStartAddress R: SendNumArgsReg.
	self MoveAw: objectMemory freeStartAddress R: Extra0Reg.
	self AddCq: 16 R: Extra0Reg.
	s119 := objectMemory getScavengeThreshold.
	self CmpCq: s119 R: Extra0Reg.
	jump9 := self JumpAbove: 0.
	s121 := 72057594205700130.
	self MoveCq: s121 R: Extra0Reg.
	self MoveR: Extra0Reg M64: 0 r: SendNumArgsReg.
	self MoveAw: objectMemory freeStartAddress R: Extra0Reg.
	self AddCq: 16 R: Extra0Reg.
	self MoveR: Extra0Reg Aw: objectMemory freeStartAddress.
	self MoveRd: DPFPReg0 M64: 8 r: SendNumArgsReg.
	self MoveR: SendNumArgsReg R: ReceiverResultReg.
	currentBlock := self Label.
	jump7 jmpTarget: currentBlock.
	self genPrimReturn.
	currentBlock := self Label.
	jump8 jmpTarget: currentBlock.
	currentBlock := self Label.
	jump2 jmpTarget: currentBlock.
	jump3 jmpTarget: currentBlock.
	jump1 jmpTarget: currentBlock.
	jump4 jmpTarget: currentBlock.
	jump6 jmpTarget: currentBlock.
	jump5 jmpTarget: currentBlock.
	jump9 jmpTarget: currentBlock.
	^ 0
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveFloatEqual [
	"AutoGenerated by Druid"

	| jump1 s86 s83 jump6 jump3 currentBlock jump8 jump5 jump2 jump7 jump4 |
	self MoveR: ReceiverResultReg R: ClassReg.
	self MoveR: Arg0Reg R: SendNumArgsReg.
	self MoveR: ClassReg R: Extra0Reg.
	self AndCq: 7 R: Extra0Reg.
	self CmpCq: 0 R: Extra0Reg.
	jump1 := self JumpZero: 0.
	self CmpCq: 4 R: Extra0Reg.
	jump2 := self JumpNonZero: 0.
	self MoveR: ClassReg R: Extra0Reg.
	self LogicalShiftRightCq: 3 R: Extra0Reg.
	self CmpCq: 1 R: Extra0Reg.
	jump3 := self JumpBelowOrEqual: 0.
	self AddCq: 16r7000000000000000 R: Extra0Reg.
	jump4 := self Jump: 0.
	currentBlock := self Label.
	jump3 jmpTarget: currentBlock.
	currentBlock := self Label.
	jump4 jmpTarget: currentBlock.
	self MoveR: Extra0Reg R: ClassReg.
	self LogicalShiftLeftCq: 63 R: ClassReg.
	self LogicalShiftRightCq: 1 R: Extra0Reg.
	self AddR: Extra0Reg R: ClassReg.
	self MoveR: ClassReg Rd: DPFPReg0.
	jump4 := self Jump: 0.
	currentBlock := self Label.
	jump2 jmpTarget: currentBlock.
	self CmpCq: 1 R: Extra0Reg.
	jump2 := self JumpNonZero: 0.
	self MoveR: ClassReg R: Extra0Reg.
	self LogicalShiftLeftCq: 9 R: Extra0Reg.
	self ArithmeticShiftRightCq: 9 R: Extra0Reg.
	self CmpR: ClassReg R: Extra0Reg.
	jump3 := self JumpNonZero: 0.
	self ArithmeticShiftRightCq: 3 R: ClassReg.
	self ConvertR: ClassReg Rd: DPFPReg0.
	jump5 := self Jump: 0.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	self MoveM64: 0 r: ClassReg R: Extra0Reg.
	self AndCq: 16r3FFFFF R: Extra0Reg.
	self CmpCq: 34 R: Extra0Reg.
	jump1 := self JumpNonZero: 0.
	self MoveM64: 8 r: ClassReg Rd: DPFPReg0.
	currentBlock := self Label.
	jump4 jmpTarget: currentBlock.
	jump5 jmpTarget: currentBlock.
	self MoveR: SendNumArgsReg R: Extra0Reg.
	self AndCq: 7 R: Extra0Reg.
	self CmpCq: 0 R: Extra0Reg.
	jump5 := self JumpZero: 0.
	self CmpCq: 4 R: Extra0Reg.
	jump4 := self JumpNonZero: 0.
	self MoveR: SendNumArgsReg R: Extra0Reg.
	self LogicalShiftRightCq: 3 R: Extra0Reg.
	self CmpCq: 1 R: Extra0Reg.
	jump6 := self JumpBelowOrEqual: 0.
	self AddCq: 16r7000000000000000 R: Extra0Reg.
	jump7 := self Jump: 0.
	currentBlock := self Label.
	jump6 jmpTarget: currentBlock.
	currentBlock := self Label.
	jump7 jmpTarget: currentBlock.
	self MoveR: Extra0Reg R: SendNumArgsReg.
	self LogicalShiftLeftCq: 63 R: SendNumArgsReg.
	self LogicalShiftRightCq: 1 R: Extra0Reg.
	self AddR: Extra0Reg R: SendNumArgsReg.
	self MoveR: SendNumArgsReg Rd: DPFPReg1.
	jump7 := self Jump: 0.
	currentBlock := self Label.
	jump4 jmpTarget: currentBlock.
	self CmpCq: 1 R: Extra0Reg.
	jump4 := self JumpNonZero: 0.
	self MoveR: SendNumArgsReg R: Extra0Reg.
	self LogicalShiftLeftCq: 9 R: Extra0Reg.
	self ArithmeticShiftRightCq: 9 R: Extra0Reg.
	self CmpR: SendNumArgsReg R: Extra0Reg.
	jump6 := self JumpNonZero: 0.
	self ArithmeticShiftRightCq: 3 R: SendNumArgsReg.
	self ConvertR: SendNumArgsReg Rd: DPFPReg1.
	jump8 := self Jump: 0.
	currentBlock := self Label.
	jump5 jmpTarget: currentBlock.
	self MoveM64: 0 r: SendNumArgsReg R: Extra0Reg.
	self AndCq: 16r3FFFFF R: Extra0Reg.
	self CmpCq: 34 R: Extra0Reg.
	jump5 := self JumpNonZero: 0.
	self MoveM64: 8 r: SendNumArgsReg Rd: DPFPReg1.
	currentBlock := self Label.
	jump7 jmpTarget: currentBlock.
	jump8 jmpTarget: currentBlock.
	self CmpRd: DPFPReg1 Rd: DPFPReg0.
	jump8 := self JumpFPNotEqual: 0.
	s83 := objectMemory trueObject.
	self MoveCq: s83 R: ReceiverResultReg.
	self genPrimReturn.
	currentBlock := self Label.
	jump8 jmpTarget: currentBlock.
	s86 := objectMemory falseObject.
	self MoveCq: s86 R: ReceiverResultReg.
	self genPrimReturn.
	currentBlock := self Label.
	jump5 jmpTarget: currentBlock.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	currentBlock := self Label.
	jump3 jmpTarget: currentBlock.
	currentBlock := self Label.
	jump6 jmpTarget: currentBlock.
	currentBlock := self Label.
	jump4 jmpTarget: currentBlock.
	currentBlock := self Label.
	jump2 jmpTarget: currentBlock.
	^ 0
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveFloatMultiply [
	"AutoGenerated by Druid"

	| jump1 s123 jumpNext s98 s126 jump9 jump6 jump3 jump10 currentBlock s91 jump5 jump2 jump8 jumpTrue jump11 jump7 jump4 |
	self MoveR: ReceiverResultReg R: ClassReg.
	self MoveR: Arg0Reg R: SendNumArgsReg.
	self MoveR: ClassReg R: Extra0Reg.
	self AndCq: 7 R: Extra0Reg.
	self CmpCq: 0 R: Extra0Reg.
	jump1 := self JumpZero: 0.
	self CmpCq: 4 R: Extra0Reg.
	jump2 := self JumpNonZero: 0.
	self MoveR: ClassReg R: Extra0Reg.
	self LogicalShiftRightCq: 3 R: Extra0Reg.
	self CmpCq: 1 R: Extra0Reg.
	jump3 := self JumpBelowOrEqual: 0.
	self AddCq: 16r7000000000000000 R: Extra0Reg.
	jump4 := self Jump: 0.
	currentBlock := self Label.
	jump3 jmpTarget: currentBlock.
	currentBlock := self Label.
	jump4 jmpTarget: currentBlock.
	self MoveR: Extra0Reg R: ClassReg.
	self LogicalShiftLeftCq: 63 R: ClassReg.
	self LogicalShiftRightCq: 1 R: Extra0Reg.
	self AddR: Extra0Reg R: ClassReg.
	self MoveR: ClassReg Rd: DPFPReg0.
	jump4 := self Jump: 0.
	currentBlock := self Label.
	jump2 jmpTarget: currentBlock.
	self CmpCq: 1 R: Extra0Reg.
	jump2 := self JumpNonZero: 0.
	self MoveR: ClassReg R: Extra0Reg.
	self LogicalShiftLeftCq: 9 R: Extra0Reg.
	self ArithmeticShiftRightCq: 9 R: Extra0Reg.
	self CmpR: ClassReg R: Extra0Reg.
	jump3 := self JumpNonZero: 0.
	self ArithmeticShiftRightCq: 3 R: ClassReg.
	self ConvertR: ClassReg Rd: DPFPReg0.
	jump5 := self Jump: 0.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	self MoveM64: 0 r: ClassReg R: Extra0Reg.
	self AndCq: 16r3FFFFF R: Extra0Reg.
	self CmpCq: 34 R: Extra0Reg.
	jump1 := self JumpNonZero: 0.
	self MoveM64: 8 r: ClassReg Rd: DPFPReg0.
	currentBlock := self Label.
	jump4 jmpTarget: currentBlock.
	jump5 jmpTarget: currentBlock.
	self MoveR: SendNumArgsReg R: Extra0Reg.
	self AndCq: 7 R: Extra0Reg.
	self CmpCq: 0 R: Extra0Reg.
	jump5 := self JumpZero: 0.
	self CmpCq: 4 R: Extra0Reg.
	jump4 := self JumpNonZero: 0.
	self MoveR: SendNumArgsReg R: Extra0Reg.
	self LogicalShiftRightCq: 3 R: Extra0Reg.
	self CmpCq: 1 R: Extra0Reg.
	jump6 := self JumpBelowOrEqual: 0.
	self AddCq: 16r7000000000000000 R: Extra0Reg.
	jump7 := self Jump: 0.
	currentBlock := self Label.
	jump6 jmpTarget: currentBlock.
	currentBlock := self Label.
	jump7 jmpTarget: currentBlock.
	self MoveR: Extra0Reg R: SendNumArgsReg.
	self LogicalShiftLeftCq: 63 R: SendNumArgsReg.
	self LogicalShiftRightCq: 1 R: Extra0Reg.
	self AddR: Extra0Reg R: SendNumArgsReg.
	self MoveR: SendNumArgsReg Rd: DPFPReg1.
	jump7 := self Jump: 0.
	currentBlock := self Label.
	jump4 jmpTarget: currentBlock.
	self CmpCq: 1 R: Extra0Reg.
	jump4 := self JumpNonZero: 0.
	self MoveR: SendNumArgsReg R: Extra0Reg.
	self LogicalShiftLeftCq: 9 R: Extra0Reg.
	self ArithmeticShiftRightCq: 9 R: Extra0Reg.
	self CmpR: SendNumArgsReg R: Extra0Reg.
	jump6 := self JumpNonZero: 0.
	self ArithmeticShiftRightCq: 3 R: SendNumArgsReg.
	self ConvertR: SendNumArgsReg Rd: DPFPReg1.
	jump8 := self Jump: 0.
	currentBlock := self Label.
	jump5 jmpTarget: currentBlock.
	self MoveM64: 0 r: SendNumArgsReg R: Extra0Reg.
	self AndCq: 16r3FFFFF R: Extra0Reg.
	self CmpCq: 34 R: Extra0Reg.
	jump5 := self JumpNonZero: 0.
	self MoveM64: 8 r: SendNumArgsReg Rd: DPFPReg1.
	currentBlock := self Label.
	jump7 jmpTarget: currentBlock.
	jump8 jmpTarget: currentBlock.
	self MulRd: DPFPReg1 Rd: DPFPReg0.
	self MoveRd: DPFPReg0 R: Extra0Reg.
	self MoveR: Extra0Reg R: SendNumArgsReg.
	self LogicalShiftRightCq: 52 R: SendNumArgsReg.
	self AndCq: 2047 R: SendNumArgsReg.
	self CmpCq: 896 R: SendNumArgsReg.
	jump8 := self JumpBelowOrEqual: 0.
	self CmpCq: 1151 R: SendNumArgsReg.
	jump7 := self JumpBelowOrEqual: 0.
	jump9 := self JumpAbove: 0.
	currentBlock := self Label.
	jump8 jmpTarget: currentBlock.
	self AndCq: 16rFFFFFFFFFFFFF R: Extra0Reg.
	self CmpCq: 0 R: Extra0Reg.
	jump8 := self JumpNonZero: 0.
	s91 := 0.
	self CmpCq: s91 R: SendNumArgsReg.
	jumpTrue := self JumpZero: 0.
	self MoveCq: 0 R: SendNumArgsReg.
	jumpNext := self Jump: 0.
	jumpTrue jmpTarget: self Label.
	self MoveCq: 1 R: SendNumArgsReg.
	jumpNext jmpTarget: self Label.
	self CmpCq: 1 R: SendNumArgsReg.
	jump10 := self JumpZero: 0.
	jump11 := self JumpNonZero: 0.
	currentBlock := self Label.
	jump8 jmpTarget: currentBlock.
	s98 := 896.
	self CmpCq: s98 R: SendNumArgsReg.
	jumpTrue := self JumpZero: 0.
	self MoveCq: 0 R: SendNumArgsReg.
	jumpNext := self Jump: 0.
	jumpTrue jmpTarget: self Label.
	self MoveCq: 1 R: SendNumArgsReg.
	jumpNext jmpTarget: self Label.
	self CmpCq: 1 R: SendNumArgsReg.
	jump8 := self JumpNonZero: 0.
	currentBlock := self Label.
	jump10 jmpTarget: currentBlock.
	currentBlock := self Label.
	jump7 jmpTarget: currentBlock.
	self MoveRd: DPFPReg0 R: SendNumArgsReg.
	self RotateLeftCq: 1 R: SendNumArgsReg.
	self CmpCq: 1 R: SendNumArgsReg.
	jump7 := self JumpBelowOrEqual: 0.
	self SubCq: 16r7000000000000000 R: SendNumArgsReg.
	jump10 := self Jump: 0.
	currentBlock := self Label.
	jump7 jmpTarget: currentBlock.
	currentBlock := self Label.
	jump10 jmpTarget: currentBlock.
	self LogicalShiftLeftCq: 3 R: SendNumArgsReg.
	self AddCq: 4 R: SendNumArgsReg.
	jump10 := self Jump: 0.
	currentBlock := self Label.
	jump11 jmpTarget: currentBlock.
	jump8 jmpTarget: currentBlock.
	currentBlock := self Label.
	jump9 jmpTarget: currentBlock.
	self MoveAw: objectMemory freeStartAddress R: SendNumArgsReg.
	self MoveAw: objectMemory freeStartAddress R: Extra0Reg.
	self AddCq: 16 R: Extra0Reg.
	s123 := objectMemory getScavengeThreshold.
	self CmpCq: s123 R: Extra0Reg.
	jump9 := self JumpAbove: 0.
	s126 := 72057594205700130.
	self MoveCq: s126 R: Extra0Reg.
	self MoveR: Extra0Reg M64: 0 r: SendNumArgsReg.
	self MoveAw: objectMemory freeStartAddress R: Extra0Reg.
	self AddCq: 16 R: Extra0Reg.
	self MoveR: Extra0Reg Aw: objectMemory freeStartAddress.
	self MoveRd: DPFPReg0 M64: 8 r: SendNumArgsReg.
	currentBlock := self Label.
	jump10 jmpTarget: currentBlock.
	self MoveR: SendNumArgsReg R: ReceiverResultReg.
	self genPrimReturn.
	currentBlock := self Label.
	jump9 jmpTarget: currentBlock.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	currentBlock := self Label.
	jump5 jmpTarget: currentBlock.
	currentBlock := self Label.
	jump3 jmpTarget: currentBlock.
	currentBlock := self Label.
	jump6 jmpTarget: currentBlock.
	currentBlock := self Label.
	jump4 jmpTarget: currentBlock.
	currentBlock := self Label.
	jump2 jmpTarget: currentBlock.
	^ 0
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveFloatNotEqual [
	"AutoGenerated by Druid"

	| jump1 s86 s83 jump6 jump3 currentBlock jump8 jump5 jump2 jump7 jump4 |
	self MoveR: ReceiverResultReg R: ClassReg.
	self MoveR: Arg0Reg R: SendNumArgsReg.
	self MoveR: ClassReg R: Extra0Reg.
	self AndCq: 7 R: Extra0Reg.
	self CmpCq: 0 R: Extra0Reg.
	jump1 := self JumpZero: 0.
	self CmpCq: 4 R: Extra0Reg.
	jump2 := self JumpNonZero: 0.
	self MoveR: ClassReg R: Extra0Reg.
	self LogicalShiftRightCq: 3 R: Extra0Reg.
	self CmpCq: 1 R: Extra0Reg.
	jump3 := self JumpBelowOrEqual: 0.
	self AddCq: 16r7000000000000000 R: Extra0Reg.
	jump4 := self Jump: 0.
	currentBlock := self Label.
	jump3 jmpTarget: currentBlock.
	currentBlock := self Label.
	jump4 jmpTarget: currentBlock.
	self MoveR: Extra0Reg R: ClassReg.
	self LogicalShiftLeftCq: 63 R: ClassReg.
	self LogicalShiftRightCq: 1 R: Extra0Reg.
	self AddR: Extra0Reg R: ClassReg.
	self MoveR: ClassReg Rd: DPFPReg0.
	jump4 := self Jump: 0.
	currentBlock := self Label.
	jump2 jmpTarget: currentBlock.
	self CmpCq: 1 R: Extra0Reg.
	jump2 := self JumpNonZero: 0.
	self MoveR: ClassReg R: Extra0Reg.
	self LogicalShiftLeftCq: 9 R: Extra0Reg.
	self ArithmeticShiftRightCq: 9 R: Extra0Reg.
	self CmpR: ClassReg R: Extra0Reg.
	jump3 := self JumpNonZero: 0.
	self ArithmeticShiftRightCq: 3 R: ClassReg.
	self ConvertR: ClassReg Rd: DPFPReg0.
	jump5 := self Jump: 0.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	self MoveM64: 0 r: ClassReg R: Extra0Reg.
	self AndCq: 16r3FFFFF R: Extra0Reg.
	self CmpCq: 34 R: Extra0Reg.
	jump1 := self JumpNonZero: 0.
	self MoveM64: 8 r: ClassReg Rd: DPFPReg0.
	currentBlock := self Label.
	jump4 jmpTarget: currentBlock.
	jump5 jmpTarget: currentBlock.
	self MoveR: SendNumArgsReg R: Extra0Reg.
	self AndCq: 7 R: Extra0Reg.
	self CmpCq: 0 R: Extra0Reg.
	jump5 := self JumpZero: 0.
	self CmpCq: 4 R: Extra0Reg.
	jump4 := self JumpNonZero: 0.
	self MoveR: SendNumArgsReg R: Extra0Reg.
	self LogicalShiftRightCq: 3 R: Extra0Reg.
	self CmpCq: 1 R: Extra0Reg.
	jump6 := self JumpBelowOrEqual: 0.
	self AddCq: 16r7000000000000000 R: Extra0Reg.
	jump7 := self Jump: 0.
	currentBlock := self Label.
	jump6 jmpTarget: currentBlock.
	currentBlock := self Label.
	jump7 jmpTarget: currentBlock.
	self MoveR: Extra0Reg R: SendNumArgsReg.
	self LogicalShiftLeftCq: 63 R: SendNumArgsReg.
	self LogicalShiftRightCq: 1 R: Extra0Reg.
	self AddR: Extra0Reg R: SendNumArgsReg.
	self MoveR: SendNumArgsReg Rd: DPFPReg1.
	jump7 := self Jump: 0.
	currentBlock := self Label.
	jump4 jmpTarget: currentBlock.
	self CmpCq: 1 R: Extra0Reg.
	jump4 := self JumpNonZero: 0.
	self MoveR: SendNumArgsReg R: Extra0Reg.
	self LogicalShiftLeftCq: 9 R: Extra0Reg.
	self ArithmeticShiftRightCq: 9 R: Extra0Reg.
	self CmpR: SendNumArgsReg R: Extra0Reg.
	jump6 := self JumpNonZero: 0.
	self ArithmeticShiftRightCq: 3 R: SendNumArgsReg.
	self ConvertR: SendNumArgsReg Rd: DPFPReg1.
	jump8 := self Jump: 0.
	currentBlock := self Label.
	jump5 jmpTarget: currentBlock.
	self MoveM64: 0 r: SendNumArgsReg R: Extra0Reg.
	self AndCq: 16r3FFFFF R: Extra0Reg.
	self CmpCq: 34 R: Extra0Reg.
	jump5 := self JumpNonZero: 0.
	self MoveM64: 8 r: SendNumArgsReg Rd: DPFPReg1.
	currentBlock := self Label.
	jump7 jmpTarget: currentBlock.
	jump8 jmpTarget: currentBlock.
	self CmpRd: DPFPReg1 Rd: DPFPReg0.
	jump8 := self JumpFPNotEqual: 0.
	s83 := objectMemory falseObject.
	self MoveCq: s83 R: ReceiverResultReg.
	self genPrimReturn.
	currentBlock := self Label.
	jump8 jmpTarget: currentBlock.
	s86 := objectMemory trueObject.
	self MoveCq: s86 R: ReceiverResultReg.
	self genPrimReturn.
	currentBlock := self Label.
	jump5 jmpTarget: currentBlock.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	currentBlock := self Label.
	jump3 jmpTarget: currentBlock.
	currentBlock := self Label.
	jump6 jmpTarget: currentBlock.
	currentBlock := self Label.
	jump4 jmpTarget: currentBlock.
	currentBlock := self Label.
	jump2 jmpTarget: currentBlock.
	^ 0
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveFloatSubtract [
	"AutoGenerated by Druid"

	| jump1 s123 jumpNext s98 s126 jump9 jump6 jump3 jump10 currentBlock s91 jump5 jump2 jump8 jumpTrue jump11 jump7 jump4 |
	self MoveR: ReceiverResultReg R: ClassReg.
	self MoveR: Arg0Reg R: SendNumArgsReg.
	self MoveR: ClassReg R: Extra0Reg.
	self AndCq: 7 R: Extra0Reg.
	self CmpCq: 0 R: Extra0Reg.
	jump1 := self JumpZero: 0.
	self CmpCq: 4 R: Extra0Reg.
	jump2 := self JumpNonZero: 0.
	self MoveR: ClassReg R: Extra0Reg.
	self LogicalShiftRightCq: 3 R: Extra0Reg.
	self CmpCq: 1 R: Extra0Reg.
	jump3 := self JumpBelowOrEqual: 0.
	self AddCq: 16r7000000000000000 R: Extra0Reg.
	jump4 := self Jump: 0.
	currentBlock := self Label.
	jump3 jmpTarget: currentBlock.
	currentBlock := self Label.
	jump4 jmpTarget: currentBlock.
	self MoveR: Extra0Reg R: ClassReg.
	self LogicalShiftLeftCq: 63 R: ClassReg.
	self LogicalShiftRightCq: 1 R: Extra0Reg.
	self AddR: Extra0Reg R: ClassReg.
	self MoveR: ClassReg Rd: DPFPReg0.
	jump4 := self Jump: 0.
	currentBlock := self Label.
	jump2 jmpTarget: currentBlock.
	self CmpCq: 1 R: Extra0Reg.
	jump2 := self JumpNonZero: 0.
	self MoveR: ClassReg R: Extra0Reg.
	self LogicalShiftLeftCq: 9 R: Extra0Reg.
	self ArithmeticShiftRightCq: 9 R: Extra0Reg.
	self CmpR: ClassReg R: Extra0Reg.
	jump3 := self JumpNonZero: 0.
	self ArithmeticShiftRightCq: 3 R: ClassReg.
	self ConvertR: ClassReg Rd: DPFPReg0.
	jump5 := self Jump: 0.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	self MoveM64: 0 r: ClassReg R: Extra0Reg.
	self AndCq: 16r3FFFFF R: Extra0Reg.
	self CmpCq: 34 R: Extra0Reg.
	jump1 := self JumpNonZero: 0.
	self MoveM64: 8 r: ClassReg Rd: DPFPReg0.
	currentBlock := self Label.
	jump4 jmpTarget: currentBlock.
	jump5 jmpTarget: currentBlock.
	self MoveR: SendNumArgsReg R: Extra0Reg.
	self AndCq: 7 R: Extra0Reg.
	self CmpCq: 0 R: Extra0Reg.
	jump5 := self JumpZero: 0.
	self CmpCq: 4 R: Extra0Reg.
	jump4 := self JumpNonZero: 0.
	self MoveR: SendNumArgsReg R: Extra0Reg.
	self LogicalShiftRightCq: 3 R: Extra0Reg.
	self CmpCq: 1 R: Extra0Reg.
	jump6 := self JumpBelowOrEqual: 0.
	self AddCq: 16r7000000000000000 R: Extra0Reg.
	jump7 := self Jump: 0.
	currentBlock := self Label.
	jump6 jmpTarget: currentBlock.
	currentBlock := self Label.
	jump7 jmpTarget: currentBlock.
	self MoveR: Extra0Reg R: SendNumArgsReg.
	self LogicalShiftLeftCq: 63 R: SendNumArgsReg.
	self LogicalShiftRightCq: 1 R: Extra0Reg.
	self AddR: Extra0Reg R: SendNumArgsReg.
	self MoveR: SendNumArgsReg Rd: DPFPReg1.
	jump7 := self Jump: 0.
	currentBlock := self Label.
	jump4 jmpTarget: currentBlock.
	self CmpCq: 1 R: Extra0Reg.
	jump4 := self JumpNonZero: 0.
	self MoveR: SendNumArgsReg R: Extra0Reg.
	self LogicalShiftLeftCq: 9 R: Extra0Reg.
	self ArithmeticShiftRightCq: 9 R: Extra0Reg.
	self CmpR: SendNumArgsReg R: Extra0Reg.
	jump6 := self JumpNonZero: 0.
	self ArithmeticShiftRightCq: 3 R: SendNumArgsReg.
	self ConvertR: SendNumArgsReg Rd: DPFPReg1.
	jump8 := self Jump: 0.
	currentBlock := self Label.
	jump5 jmpTarget: currentBlock.
	self MoveM64: 0 r: SendNumArgsReg R: Extra0Reg.
	self AndCq: 16r3FFFFF R: Extra0Reg.
	self CmpCq: 34 R: Extra0Reg.
	jump5 := self JumpNonZero: 0.
	self MoveM64: 8 r: SendNumArgsReg Rd: DPFPReg1.
	currentBlock := self Label.
	jump7 jmpTarget: currentBlock.
	jump8 jmpTarget: currentBlock.
	self SubRd: DPFPReg1 Rd: DPFPReg0.
	self MoveRd: DPFPReg0 R: Extra0Reg.
	self MoveR: Extra0Reg R: SendNumArgsReg.
	self LogicalShiftRightCq: 52 R: SendNumArgsReg.
	self AndCq: 2047 R: SendNumArgsReg.
	self CmpCq: 896 R: SendNumArgsReg.
	jump8 := self JumpBelowOrEqual: 0.
	self CmpCq: 1151 R: SendNumArgsReg.
	jump7 := self JumpBelowOrEqual: 0.
	jump9 := self JumpAbove: 0.
	currentBlock := self Label.
	jump8 jmpTarget: currentBlock.
	self AndCq: 16rFFFFFFFFFFFFF R: Extra0Reg.
	self CmpCq: 0 R: Extra0Reg.
	jump8 := self JumpNonZero: 0.
	s91 := 0.
	self CmpCq: s91 R: SendNumArgsReg.
	jumpTrue := self JumpZero: 0.
	self MoveCq: 0 R: SendNumArgsReg.
	jumpNext := self Jump: 0.
	jumpTrue jmpTarget: self Label.
	self MoveCq: 1 R: SendNumArgsReg.
	jumpNext jmpTarget: self Label.
	self CmpCq: 1 R: SendNumArgsReg.
	jump10 := self JumpZero: 0.
	jump11 := self JumpNonZero: 0.
	currentBlock := self Label.
	jump8 jmpTarget: currentBlock.
	s98 := 896.
	self CmpCq: s98 R: SendNumArgsReg.
	jumpTrue := self JumpZero: 0.
	self MoveCq: 0 R: SendNumArgsReg.
	jumpNext := self Jump: 0.
	jumpTrue jmpTarget: self Label.
	self MoveCq: 1 R: SendNumArgsReg.
	jumpNext jmpTarget: self Label.
	self CmpCq: 1 R: SendNumArgsReg.
	jump8 := self JumpNonZero: 0.
	currentBlock := self Label.
	jump10 jmpTarget: currentBlock.
	currentBlock := self Label.
	jump7 jmpTarget: currentBlock.
	self MoveRd: DPFPReg0 R: SendNumArgsReg.
	self RotateLeftCq: 1 R: SendNumArgsReg.
	self CmpCq: 1 R: SendNumArgsReg.
	jump7 := self JumpBelowOrEqual: 0.
	self SubCq: 16r7000000000000000 R: SendNumArgsReg.
	jump10 := self Jump: 0.
	currentBlock := self Label.
	jump7 jmpTarget: currentBlock.
	currentBlock := self Label.
	jump10 jmpTarget: currentBlock.
	self LogicalShiftLeftCq: 3 R: SendNumArgsReg.
	self AddCq: 4 R: SendNumArgsReg.
	jump10 := self Jump: 0.
	currentBlock := self Label.
	jump11 jmpTarget: currentBlock.
	jump8 jmpTarget: currentBlock.
	currentBlock := self Label.
	jump9 jmpTarget: currentBlock.
	self MoveAw: objectMemory freeStartAddress R: SendNumArgsReg.
	self MoveAw: objectMemory freeStartAddress R: Extra0Reg.
	self AddCq: 16 R: Extra0Reg.
	s123 := objectMemory getScavengeThreshold.
	self CmpCq: s123 R: Extra0Reg.
	jump9 := self JumpAbove: 0.
	s126 := 72057594205700130.
	self MoveCq: s126 R: Extra0Reg.
	self MoveR: Extra0Reg M64: 0 r: SendNumArgsReg.
	self MoveAw: objectMemory freeStartAddress R: Extra0Reg.
	self AddCq: 16 R: Extra0Reg.
	self MoveR: Extra0Reg Aw: objectMemory freeStartAddress.
	self MoveRd: DPFPReg0 M64: 8 r: SendNumArgsReg.
	currentBlock := self Label.
	jump10 jmpTarget: currentBlock.
	self MoveR: SendNumArgsReg R: ReceiverResultReg.
	self genPrimReturn.
	currentBlock := self Label.
	jump9 jmpTarget: currentBlock.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	currentBlock := self Label.
	jump5 jmpTarget: currentBlock.
	currentBlock := self Label.
	jump3 jmpTarget: currentBlock.
	currentBlock := self Label.
	jump6 jmpTarget: currentBlock.
	currentBlock := self Label.
	jump4 jmpTarget: currentBlock.
	currentBlock := self Label.
	jump2 jmpTarget: currentBlock.
	^ 0
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveFullClosureValue [
	"AutoGenerated by Druid"

	| s51 s26 currentBlock s2 s3 |
	s2 := self methodNumArgs.
	s2 = 0 ifTrue: [
		| jump1 jump2 jump3 jump4 |
		self MoveR: ReceiverResultReg R: ClassReg.
		self MoveM64: 24 r: ClassReg R: SendNumArgsReg.
		self ArithmeticShiftRightCq: 3 R: SendNumArgsReg.
		self CmpCq: 0 R: SendNumArgsReg.
		jump1 := self JumpNonZero: 0.
		self MoveM64: 16 r: ClassReg R: SendNumArgsReg.
		self MoveR: SendNumArgsReg R: ClassReg.
		self AndCq: 7 R: ClassReg.
		self CmpCq: 0 R: ClassReg.
		jump2 := self JumpNonZero: 0.
		self MoveM64: 0 r: SendNumArgsReg R: ClassReg.
		self LogicalShiftRightCq: 24 R: ClassReg.
		self AndCq: 31 R: ClassReg.
		self CmpCq: 24 R: ClassReg.
		jump3 := self JumpBelow: 0.
		self MoveM64: 8 r: SendNumArgsReg R: ClassReg.
		self AndCq: 1 R: ClassReg.
		self CmpCq: 0 R: ClassReg.
		jump4 := self JumpNonZero: 0.
		self MoveM64: 8 r: SendNumArgsReg R: ClassReg.
		self AddCq: self fullBlockEntryOffset R: ClassReg.
		self JumpR: ClassReg.
		self genPrimReturn.
		currentBlock := self Label.
		jump4 jmpTarget: currentBlock.
		currentBlock := self Label.
		jump3 jmpTarget: currentBlock.
		currentBlock := self Label.
		jump2 jmpTarget: currentBlock.
		currentBlock := self Label.
		jump1 jmpTarget: currentBlock.
		^ 0 ].
	s26 := self methodNumArgs.
	s26 = 1 ifTrue: [
		| jump1 jump2 jump3 jump4 |
		self MoveR: ReceiverResultReg R: ClassReg.
		self MoveR: Arg0Reg R: SendNumArgsReg.
		self MoveM64: 24 r: ClassReg R: SendNumArgsReg.
		self ArithmeticShiftRightCq: 3 R: SendNumArgsReg.
		self CmpCq: 1 R: SendNumArgsReg.
		jump1 := self JumpNonZero: 0.
		self MoveM64: 16 r: ClassReg R: SendNumArgsReg.
		self MoveR: SendNumArgsReg R: ClassReg.
		self AndCq: 7 R: ClassReg.
		self CmpCq: 0 R: ClassReg.
		jump2 := self JumpNonZero: 0.
		self MoveM64: 0 r: SendNumArgsReg R: ClassReg.
		self LogicalShiftRightCq: 24 R: ClassReg.
		self AndCq: 31 R: ClassReg.
		self CmpCq: 24 R: ClassReg.
		jump3 := self JumpBelow: 0.
		self MoveM64: 8 r: SendNumArgsReg R: ClassReg.
		self AndCq: 1 R: ClassReg.
		self CmpCq: 0 R: ClassReg.
		jump4 := self JumpNonZero: 0.
		self MoveM64: 8 r: SendNumArgsReg R: ClassReg.
		self AddCq: self fullBlockEntryOffset R: ClassReg.
		self JumpR: ClassReg.
		self genPrimReturn.
		currentBlock := self Label.
		jump4 jmpTarget: currentBlock.
		currentBlock := self Label.
		jump3 jmpTarget: currentBlock.
		currentBlock := self Label.
		jump2 jmpTarget: currentBlock.
		currentBlock := self Label.
		jump1 jmpTarget: currentBlock.
		^ 0 ].
	s51 := self methodNumArgs.
	s51 = 2 ifTrue: [
		| jump1 jump2 jump3 jump4 |
		self MoveR: ReceiverResultReg R: ClassReg.
		self MoveR: Arg0Reg R: SendNumArgsReg.
		self MoveR: Arg1Reg R: SendNumArgsReg.
		self MoveM64: 24 r: ClassReg R: SendNumArgsReg.
		self ArithmeticShiftRightCq: 3 R: SendNumArgsReg.
		self CmpCq: 2 R: SendNumArgsReg.
		jump1 := self JumpNonZero: 0.
		self MoveM64: 16 r: ClassReg R: SendNumArgsReg.
		self MoveR: SendNumArgsReg R: ClassReg.
		self AndCq: 7 R: ClassReg.
		self CmpCq: 0 R: ClassReg.
		jump2 := self JumpNonZero: 0.
		self MoveM64: 0 r: SendNumArgsReg R: ClassReg.
		self LogicalShiftRightCq: 24 R: ClassReg.
		self AndCq: 31 R: ClassReg.
		self CmpCq: 24 R: ClassReg.
		jump3 := self JumpBelow: 0.
		self MoveM64: 8 r: SendNumArgsReg R: ClassReg.
		self AndCq: 1 R: ClassReg.
		self CmpCq: 0 R: ClassReg.
		jump4 := self JumpNonZero: 0.
		self MoveM64: 8 r: SendNumArgsReg R: ClassReg.
		self AddCq: self fullBlockEntryOffset R: ClassReg.
		self JumpR: ClassReg.
		self genPrimReturn.
		currentBlock := self Label.
		jump4 jmpTarget: currentBlock.
		currentBlock := self Label.
		jump3 jmpTarget: currentBlock.
		currentBlock := self Label.
		jump2 jmpTarget: currentBlock.
		currentBlock := self Label.
		jump1 jmpTarget: currentBlock.
		^ 0 ].
	^ 0
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveGreaterOrEqualThanArgument [
	"AutoGenerated by Druid"

	| jumpNext currentBlock jumpTrue |
	self MoveR: Arg0Reg R: ClassReg.
	self CmpCq: 0 R: ClassReg.
	jumpTrue := self JumpGreaterOrEqual: 0.
	self MoveCq: 0 R: ClassReg.
	jumpNext := self Jump: 0.
	jumpTrue jmpTarget: self Label.
	self MoveCq: 1 R: ClassReg.
	jumpNext jmpTarget: self Label.
	self MoveR: ClassReg R: ReceiverResultReg.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveGreaterOrEqualThanValue [
	"AutoGenerated by Druid"

	| jumpNext currentBlock jumpTrue |
	self MoveR: ReceiverResultReg R: ClassReg.
	self CmpCq: 0 R: ClassReg.
	jumpTrue := self JumpGreaterOrEqual: 0.
	self MoveCq: 0 R: ClassReg.
	jumpNext := self Jump: 0.
	jumpTrue jmpTarget: self Label.
	self MoveCq: 1 R: ClassReg.
	jumpNext jmpTarget: self Label.
	self MoveR: ClassReg R: ReceiverResultReg.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveGreaterOrEqualsThan [
	"AutoGenerated by Druid"

	| jump1 currentBlock |
	self MoveR: ReceiverResultReg R: ClassReg.
	self CmpCq: 10 R: ClassReg.
	jump1 := self JumpLess: 0.
	self MoveCq: 5 R: ReceiverResultReg.
	self genPrimReturn.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	self MoveCq: 11 R: ReceiverResultReg.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveGreaterOrEqualsThanFloats [
	"AutoGenerated by Druid"

	| jumpNext currentBlock jumpTrue |
	self MoveR: ReceiverResultReg R: ClassReg.
	self MoveR: Arg0Reg R: SendNumArgsReg.
	self ConvertR: SendNumArgsReg Rd: DPFPReg0.
	self ConvertR: ClassReg Rd: DPFPReg1.
	self CmpRd: DPFPReg1 Rd: DPFPReg0.
	jumpTrue := self JumpFPGreaterOrEqual: 0.
	self MoveCq: 0 R: ClassReg.
	jumpNext := self Jump: 0.
	jumpTrue jmpTarget: self Label.
	self MoveCq: 1 R: ClassReg.
	jumpNext jmpTarget: self Label.
	self MoveR: ClassReg R: ReceiverResultReg.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveGreaterOrEqualsThanInverted [
	"AutoGenerated by Druid"

	| jump1 currentBlock |
	self MoveR: ReceiverResultReg R: ClassReg.
	self CmpCq: 10 R: ClassReg.
	jump1 := self JumpGreater: 0.
	self MoveCq: 5 R: ReceiverResultReg.
	self genPrimReturn.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	self MoveCq: 11 R: ReceiverResultReg.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveGreaterThan [
	"AutoGenerated by Druid"

	| jump1 currentBlock |
	self MoveR: ReceiverResultReg R: ClassReg.
	self CmpCq: 10 R: ClassReg.
	jump1 := self JumpLessOrEqual: 0.
	self MoveCq: 5 R: ReceiverResultReg.
	self genPrimReturn.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	self MoveCq: 11 R: ReceiverResultReg.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveGreaterThanArgument [
	"AutoGenerated by Druid"

	| jumpNext currentBlock jumpTrue |
	self MoveR: Arg0Reg R: ClassReg.
	self CmpCq: 0 R: ClassReg.
	jumpTrue := self JumpGreater: 0.
	self MoveCq: 0 R: ClassReg.
	jumpNext := self Jump: 0.
	jumpTrue jmpTarget: self Label.
	self MoveCq: 1 R: ClassReg.
	jumpNext jmpTarget: self Label.
	self MoveR: ClassReg R: ReceiverResultReg.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveGreaterThanBitAnd [
	"AutoGenerated by Druid"

	| jump1 currentBlock |
	self MoveR: ReceiverResultReg R: ClassReg.
	self AndCq: 16rFFFFFFFFFFFFFFFF R: ClassReg.
	self CmpCq: 1 R: ClassReg.
	jump1 := self JumpBelowOrEqual: 0.
	self MoveCq: 1 R: ReceiverResultReg.
	self genPrimReturn.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	self MoveCq: 2 R: ReceiverResultReg.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveGreaterThanFloats [
	"AutoGenerated by Druid"

	| jumpNext currentBlock jumpTrue |
	self MoveR: ReceiverResultReg R: ClassReg.
	self MoveR: Arg0Reg R: SendNumArgsReg.
	self ConvertR: SendNumArgsReg Rd: DPFPReg0.
	self ConvertR: ClassReg Rd: DPFPReg1.
	self CmpRd: DPFPReg1 Rd: DPFPReg0.
	jumpTrue := self JumpFPGreater: 0.
	self MoveCq: 0 R: ClassReg.
	jumpNext := self Jump: 0.
	jumpTrue jmpTarget: self Label.
	self MoveCq: 1 R: ClassReg.
	jumpNext jmpTarget: self Label.
	self MoveR: ClassReg R: ReceiverResultReg.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveGreaterThanInverted [
	"AutoGenerated by Druid"

	| jump1 currentBlock |
	self MoveR: ReceiverResultReg R: ClassReg.
	self CmpCq: 10 R: ClassReg.
	jump1 := self JumpGreaterOrEqual: 0.
	self MoveCq: 5 R: ReceiverResultReg.
	self genPrimReturn.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	self MoveCq: 11 R: ReceiverResultReg.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveGreaterThanReferenceValue [
	"AutoGenerated by Druid"

	| jumpTrue jumpNext currentBlock s3 |
	self MoveR: ReceiverResultReg R: ClassReg.
	s3 := objectMemory trueObject.
	self CmpCq: s3 R: ClassReg.
	jumpTrue := self JumpAbove: 0.
	self MoveCq: 0 R: ClassReg.
	jumpNext := self Jump: 0.
	jumpTrue jmpTarget: self Label.
	self MoveCq: 1 R: ClassReg.
	jumpNext jmpTarget: self Label.
	self MoveR: ClassReg R: ReceiverResultReg.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveIdentityHash [
	"AutoGenerated by Druid"

	| jump1 jump2 currentBlock |
	self MoveR: ReceiverResultReg R: ClassReg.
	self TstCq: 7 R: ClassReg.
	jump1 := self JumpNonZero: 0.
	self MoveM32: 4 r: ClassReg R: SendNumArgsReg.
	self AndCq: 16rFFFFFFFF R: SendNumArgsReg.
	self AndCq: 16r3FFFFF R: SendNumArgsReg.
	self CmpCq: 0 R: SendNumArgsReg.
	jump2 := self JumpNonZero: 0.
	self MoveR: ClassReg R: TempReg.
	backEnd saveAndRestoreLinkRegAround: [
		self CallRT: ceNewHashTrampoline ].
	self MoveR: TempReg R: SendNumArgsReg.
	self LogicalShiftLeftCq: 3 R: SendNumArgsReg.
	self AddCq: 1 R: SendNumArgsReg.
	self MoveR: SendNumArgsReg R: ReceiverResultReg.
	self genPrimReturn.
	currentBlock := self Label.
	jump2 jmpTarget: currentBlock.
	self LogicalShiftLeftCq: 3 R: SendNumArgsReg.
	self AddCq: 1 R: SendNumArgsReg.
	self MoveR: SendNumArgsReg R: ReceiverResultReg.
	self genPrimReturn.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	^ 0
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveIfFalseIfTrueReturningValue [
	"AutoGenerated by Druid"

	| jump1 currentBlock |
	self MoveR: ReceiverResultReg R: ClassReg.
	self CmpCq: 0 R: ClassReg.
	jump1 := self JumpNonZero: 0.
	self MoveCq: 42 R: ReceiverResultReg.
	self genPrimReturn.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	self MoveCq: 57 R: ReceiverResultReg.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveIfTrueIfFalseAssigningValue [
	"AutoGenerated by Druid"

	| jump1 currentBlock |
	self MoveR: ReceiverResultReg R: ClassReg.
	self CmpCq: 0 R: ClassReg.
	jump1 := self JumpNonZero: 0.
	self MoveCq: 42 R: ReceiverResultReg.
	self genPrimReturn.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	self MoveCq: 57 R: ReceiverResultReg.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveIfTrueIfFalseReturningValue [
	"AutoGenerated by Druid"

	| jump1 currentBlock |
	self MoveR: ReceiverResultReg R: ClassReg.
	self CmpCq: 0 R: ClassReg.
	jump1 := self JumpNonZero: 0.
	self MoveCq: 42 R: ReceiverResultReg.
	self genPrimReturn.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	self MoveCq: 57 R: ReceiverResultReg.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveIfTrueStatement [
	"AutoGenerated by Druid"

	| jump1 currentBlock |
	self MoveR: ReceiverResultReg R: ClassReg.
	self CmpCq: 0 R: ClassReg.
	jump1 := self JumpNonZero: 0.
	self MoveCq: 42 R: ReceiverResultReg.
	self genPrimReturn.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	self MoveCq: 10 R: ReceiverResultReg.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveImmediateAsInteger [
	"AutoGenerated by Druid"

	| s27 s60 s2 s24 currentBlock s63 s38 s3 |
	s2 := self methodNumArgs.
	s2 = 0 ifTrue: [
		| jump1 jump2 jump3 |
		self MoveR: ReceiverResultReg R: ClassReg.
		self TstCq: 1 R: ClassReg.
		jump1 := self JumpZero: 0.
		self ArithmeticShiftRightCq: 3 R: ClassReg.
		self LogicalShiftLeftCq: 3 R: ClassReg.
		self AddCq: 1 R: ClassReg.
		self MoveR: ClassReg R: ReceiverResultReg.
		self genPrimReturn.
		currentBlock := self Label.
		jump1 jmpTarget: currentBlock.
		self TstCq: 2 R: ClassReg.
		jump1 := self JumpZero: 0.
		self LogicalShiftRightCq: 3 R: ClassReg.
		self LogicalShiftLeftCq: 3 R: ClassReg.
		self AddCq: 1 R: ClassReg.
		self MoveR: ClassReg R: ReceiverResultReg.
		self genPrimReturn.
		currentBlock := self Label.
		jump1 jmpTarget: currentBlock.
		self TstCq: 4 R: ClassReg.
		jump1 := self JumpZero: 0.
		self MoveR: ClassReg R: SendNumArgsReg.
		self LogicalShiftRightCq: 4 R: SendNumArgsReg.
		self TstCq: 8 R: ClassReg.
		jump2 := self JumpZero: 0.
		s24 :=  -1152921504606846976.
		self MoveCq: s24 R: ClassReg.
		jump3 := self Jump: 0.
		currentBlock := self Label.
		jump2 jmpTarget: currentBlock.
		s27 := 0.
		self MoveCq: s27 R: ClassReg.
		currentBlock := self Label.
		jump3 jmpTarget: currentBlock.
		self AddR: ClassReg R: SendNumArgsReg.
		self MoveR: SendNumArgsReg R: ClassReg.
		self LogicalShiftLeftCq: 3 R: ClassReg.
		self AddCq: 1 R: ClassReg.
		self MoveR: ClassReg R: ReceiverResultReg.
		self genPrimReturn.
		currentBlock := self Label.
		jump1 jmpTarget: currentBlock.
		^ 0 ].
	s38 := self methodNumArgs.
	s38 = 1 ifTrue: [
		| jump1 jump3 jump2 |
		self MoveR: Arg0Reg R: ClassReg.
		self TstCq: 1 R: ClassReg.
		jump1 := self JumpZero: 0.
		self ArithmeticShiftRightCq: 3 R: ClassReg.
		self LogicalShiftLeftCq: 3 R: ClassReg.
		self AddCq: 1 R: ClassReg.
		self MoveR: ClassReg R: ReceiverResultReg.
		self genPrimReturn.
		currentBlock := self Label.
		jump1 jmpTarget: currentBlock.
		self TstCq: 2 R: ClassReg.
		jump1 := self JumpZero: 0.
		self LogicalShiftRightCq: 3 R: ClassReg.
		self LogicalShiftLeftCq: 3 R: ClassReg.
		self AddCq: 1 R: ClassReg.
		self MoveR: ClassReg R: ReceiverResultReg.
		self genPrimReturn.
		currentBlock := self Label.
		jump1 jmpTarget: currentBlock.
		self TstCq: 4 R: ClassReg.
		jump1 := self JumpZero: 0.
		self MoveR: ClassReg R: SendNumArgsReg.
		self LogicalShiftRightCq: 4 R: SendNumArgsReg.
		self TstCq: 8 R: ClassReg.
		jump3 := self JumpZero: 0.
		s60 :=  -1152921504606846976.
		self MoveCq: s60 R: ClassReg.
		jump2 := self Jump: 0.
		currentBlock := self Label.
		jump3 jmpTarget: currentBlock.
		s63 := 0.
		self MoveCq: s63 R: ClassReg.
		currentBlock := self Label.
		jump2 jmpTarget: currentBlock.
		self AddR: ClassReg R: SendNumArgsReg.
		self MoveR: SendNumArgsReg R: ClassReg.
		self LogicalShiftLeftCq: 3 R: ClassReg.
		self AddCq: 1 R: ClassReg.
		self MoveR: ClassReg R: ReceiverResultReg.
		self genPrimReturn.
		currentBlock := self Label.
		jump1 jmpTarget: currentBlock.
		^ 0 ].
	^ 0
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveImplicitArgumentBitShiftLeft [
	"AutoGenerated by Druid"

	| jump1 s10 currentBlock s4 |
	self MoveR: ReceiverResultReg R: ClassReg.
	self CmpCq: 0 R: ClassReg.
	jump1 := self JumpLessOrEqual: 0.
	s4 := 1.
	self MoveCq: s4 R: SendNumArgsReg.
	self LogicalShiftLeftR: ClassReg R: SendNumArgsReg.
	self MoveR: SendNumArgsReg R: ReceiverResultReg.
	self genPrimReturn.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	self MoveR: ClassReg R: SendNumArgsReg.
	self NegateR: SendNumArgsReg.
	s10 := 1.
	self MoveCq: s10 R: ClassReg.
	self LogicalShiftRightR: SendNumArgsReg R: ClassReg.
	self MoveR: ClassReg R: ReceiverResultReg.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveImplicitBitShiftLeft [
	"AutoGenerated by Druid"

	| currentBlock |
	self MoveR: ReceiverResultReg R: ClassReg.
	self LogicalShiftLeftCq: 1 R: ClassReg.
	self MoveR: ClassReg R: ReceiverResultReg.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveImplicitBitShiftRight [
	"AutoGenerated by Druid"

	| currentBlock |
	self MoveR: ReceiverResultReg R: ClassReg.
	self LogicalShiftRightCq: 1 R: ClassReg.
	self MoveR: ClassReg R: ReceiverResultReg.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveIncrement [

	| currentBlock |
	self MoveR: ReceiverResultReg R: TempReg.
	self AddCq: 1 R: TempReg.
	self MoveR: TempReg R: ReceiverResultReg.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveIncrementConstantArgument [
	"AutoGenerated by Druid"

	| currentBlock |
	self MoveR: ReceiverResultReg R: ClassReg.
	self AddCq: 1 R: ClassReg.
	self MoveR: ClassReg R: ReceiverResultReg.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveIncrementConstantReceiver [
	"AutoGenerated by Druid"

	| currentBlock |
	self MoveR: ReceiverResultReg R: ClassReg.
	self AddCq: 1 R: ClassReg.
	self MoveR: ClassReg R: ReceiverResultReg.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveIntegerAsFloat [
	"AutoGenerated by Druid"

	| currentBlock |
	self MoveR: ReceiverResultReg R: ClassReg.
	self ConvertR: ClassReg Rd: DPFPReg0.
	self MoveRd: DPFPReg0 R: ClassReg.
	self MoveR: ClassReg R: ReceiverResultReg.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveIntegerDivide [
	"AutoGenerated by Druid"

	| currentBlock |
	self MoveR: ReceiverResultReg R: ClassReg.
	self MoveR: Arg0Reg R: SendNumArgsReg.
	self
		DivR: SendNumArgsReg
		R: ClassReg
		Quo: ClassReg
		Rem: SendNumArgsReg.
	self MoveR: ClassReg R: ReceiverResultReg.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveIntegerDivideByConstant [
	"AutoGenerated by Druid"

	| currentBlock s3 |
	self MoveR: ReceiverResultReg R: ClassReg.
	s3 := 2.
	self MoveCq: s3 R: SendNumArgsReg.
	self
		DivR: SendNumArgsReg
		R: ClassReg
		Quo: ClassReg
		Rem: SendNumArgsReg.
	self MoveR: ClassReg R: ReceiverResultReg.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveIntegerRawBitsAsFloat [
	"AutoGenerated by Druid"

	| currentBlock |
	self MoveR: ReceiverResultReg R: ClassReg.
	self MoveR: ClassReg Rd: DPFPReg0.
	self ConvertRd: DPFPReg0 R: ClassReg.
	self MoveR: ClassReg R: ReceiverResultReg.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveIsIntegerObject [
	"AutoGenerated by Druid"

	| s7 jump1 currentBlock s4 |
	self MoveR: ReceiverResultReg R: ClassReg.
	self TstCq: 1 R: ClassReg.
	jump1 := self JumpZero: 0.
	s4 := objectMemory trueObject.
	self MoveCq: s4 R: ReceiverResultReg.
	self genPrimReturn.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	s7 := objectMemory falseObject.
	self MoveCq: s7 R: ReceiverResultReg.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveJITCompileTimeExpression [
	"AutoGenerated by Druid"

	| s3 currentBlock s2 |
	s2 := objectMemory trueObject.
	s3 := s2 + 5.
	self MoveCq: s3 R: ReceiverResultReg.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveLessOrEqualThanArgument [
	"AutoGenerated by Druid"

	| jumpNext currentBlock jumpTrue |
	self MoveR: Arg0Reg R: ClassReg.
	self CmpCq: 0 R: ClassReg.
	jumpTrue := self JumpLessOrEqual: 0.
	self MoveCq: 0 R: ClassReg.
	jumpNext := self Jump: 0.
	jumpTrue jmpTarget: self Label.
	self MoveCq: 1 R: ClassReg.
	jumpNext jmpTarget: self Label.
	self MoveR: ClassReg R: ReceiverResultReg.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveLessOrEqualThanValue [
	"AutoGenerated by Druid"

	| jumpNext currentBlock jumpTrue |
	self MoveR: ReceiverResultReg R: ClassReg.
	self CmpCq: 0 R: ClassReg.
	jumpTrue := self JumpLessOrEqual: 0.
	self MoveCq: 0 R: ClassReg.
	jumpNext := self Jump: 0.
	jumpTrue jmpTarget: self Label.
	self MoveCq: 1 R: ClassReg.
	jumpNext jmpTarget: self Label.
	self MoveR: ClassReg R: ReceiverResultReg.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveLessOrEqualsThan [
	"AutoGenerated by Druid"

	| jump1 currentBlock |
	self MoveR: ReceiverResultReg R: ClassReg.
	self CmpCq: 10 R: ClassReg.
	jump1 := self JumpGreater: 0.
	self MoveCq: 5 R: ReceiverResultReg.
	self genPrimReturn.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	self MoveCq: 11 R: ReceiverResultReg.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveLessOrEqualsThanFloats [
	"AutoGenerated by Druid"

	| jumpNext currentBlock jumpTrue |
	self MoveR: ReceiverResultReg R: ClassReg.
	self MoveR: Arg0Reg R: SendNumArgsReg.
	self ConvertR: SendNumArgsReg Rd: DPFPReg0.
	self ConvertR: ClassReg Rd: DPFPReg1.
	self CmpRd: DPFPReg1 Rd: DPFPReg0.
	jumpTrue := self JumpFPLessOrEqual: 0.
	self MoveCq: 0 R: ClassReg.
	jumpNext := self Jump: 0.
	jumpTrue jmpTarget: self Label.
	self MoveCq: 1 R: ClassReg.
	jumpNext jmpTarget: self Label.
	self MoveR: ClassReg R: ReceiverResultReg.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveLessOrEqualsThanInverted [
	"AutoGenerated by Druid"

	| jump1 currentBlock |
	self MoveR: ReceiverResultReg R: ClassReg.
	self CmpCq: 10 R: ClassReg.
	jump1 := self JumpLess: 0.
	self MoveCq: 5 R: ReceiverResultReg.
	self genPrimReturn.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	self MoveCq: 11 R: ReceiverResultReg.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveLessThan [
	"AutoGenerated by Druid"

	| jump1 currentBlock |
	self MoveR: ReceiverResultReg R: ClassReg.
	self CmpCq: 10 R: ClassReg.
	jump1 := self JumpGreaterOrEqual: 0.
	self MoveCq: 5 R: ReceiverResultReg.
	self genPrimReturn.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	self MoveCq: 11 R: ReceiverResultReg.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveLessThanArgument [
	"AutoGenerated by Druid"

	| jumpNext currentBlock jumpTrue |
	self MoveR: Arg0Reg R: ClassReg.
	self CmpCq: 0 R: ClassReg.
	jumpTrue := self JumpLess: 0.
	self MoveCq: 0 R: ClassReg.
	jumpNext := self Jump: 0.
	jumpTrue jmpTarget: self Label.
	self MoveCq: 1 R: ClassReg.
	jumpNext jmpTarget: self Label.
	self MoveR: ClassReg R: ReceiverResultReg.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveLessThanFloats [
	"AutoGenerated by Druid"

	| jumpNext currentBlock jumpTrue |
	self MoveR: ReceiverResultReg R: ClassReg.
	self MoveR: Arg0Reg R: SendNumArgsReg.
	self ConvertR: SendNumArgsReg Rd: DPFPReg0.
	self ConvertR: ClassReg Rd: DPFPReg1.
	self CmpRd: DPFPReg1 Rd: DPFPReg0.
	jumpTrue := self JumpFPLess: 0.
	self MoveCq: 0 R: ClassReg.
	jumpNext := self Jump: 0.
	jumpTrue jmpTarget: self Label.
	self MoveCq: 1 R: ClassReg.
	jumpNext jmpTarget: self Label.
	self MoveR: ClassReg R: ReceiverResultReg.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveLessThanInverted [
	"AutoGenerated by Druid"

	| jump1 currentBlock |
	self MoveR: ReceiverResultReg R: ClassReg.
	self CmpCq: 10 R: ClassReg.
	jump1 := self JumpLessOrEqual: 0.
	self MoveCq: 5 R: ReceiverResultReg.
	self genPrimReturn.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	self MoveCq: 11 R: ReceiverResultReg.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveLessThanThanInverted [

	| currentBlock jump0 jump1 |
	self MoveCq: true asBit R: TempReg.
	self MoveCq: 10 R: ClassReg.
	self CmpCq: 10 R: ReceiverResultReg.
	jump0 := self JumpLess: 0.
	self MoveCq: 5 R: Extra0Reg.
	self MoveCq: 5 R: Extra1Reg.
	self MoveR: Extra1Reg R: ClassReg.
	self MoveR: ReceiverResultReg R: SendNumArgsReg.
	jump1 := self Jump: 0.
	currentBlock := self Label.
	jump0 jmpTarget: currentBlock.
	self MoveCq: 11 R: Extra2Reg.
	self MoveCq: 11 R: TempReg.
	self MoveR: TempReg R: ClassReg.
	self MoveR: ReceiverResultReg R: SendNumArgsReg.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	self MoveCq: 1 R: Extra0Reg.
	self MoveR: ClassReg R: ReceiverResultReg.
	self RetN: 1 * objectMemory wordSize.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveLessThanValue [
	"AutoGenerated by Druid"

	| jumpNext currentBlock jumpTrue |
	self MoveR: ReceiverResultReg R: ClassReg.
	self CmpCq: 0 R: ClassReg.
	jumpTrue := self JumpLess: 0.
	self MoveCq: 0 R: ClassReg.
	jumpNext := self Jump: 0.
	jumpTrue jmpTarget: self Label.
	self MoveCq: 1 R: ClassReg.
	jumpNext jmpTarget: self Label.
	self MoveR: ClassReg R: ReceiverResultReg.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveLogicalBitShiftRight [
	"AutoGenerated by Druid"

	| currentBlock |
	self MoveR: ReceiverResultReg R: ClassReg.
	self MoveR: Arg0Reg R: SendNumArgsReg.
	self LogicalShiftRightR: SendNumArgsReg R: ClassReg.
	self MoveR: ClassReg R: ReceiverResultReg.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveLoopIncrementing [
	"AutoGenerated by Druid"

	| s6 s2 currentBlock s7 b16 s3 |
	s2 := 10.
	s3 := s2.
	b16 := self Label.
	s6 := s3 + 1.
	[ ((s6<15)) ] whileTrue: [ s3 := s6 ].
	self MoveCq: s6 R: ReceiverResultReg.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveLoopIncrementingGlobalState [
	"AutoGenerated by Druid"

	| s6 s2 currentBlock s7 b16 s3 |
	s2 := 10.
	s3 := s2.
	b16 := self Label.
	s6 := s3 + 1.
	[ ((s6<15)) ] whileTrue: [ s3 := s6 ].
	self MoveCq: s6 R: ReceiverResultReg.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveLoopWithInvariant [

	| jump1 currentBlock b14 |
	self MoveCq: 0 R: TempReg.
	self MoveR: ReceiverResultReg R: ClassReg.
	b14 := self Label.
	self MoveCq: 1 R: SendNumArgsReg.
	self MoveR: ClassReg R: Extra0Reg.
	self MulR: SendNumArgsReg R: Extra0Reg.
	self MoveR: TempReg R: SendNumArgsReg.
	self AddR: Extra0Reg R: SendNumArgsReg.
	self CmpCq: 15 R: SendNumArgsReg.
	jump1 := self JumpLess: 0.
	self MoveR: SendNumArgsReg R: ReceiverResultReg.
	self genPrimReturn.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	self MoveR: SendNumArgsReg R: TempReg.
	jump1 := self Jump: b14.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveMod [
	"AutoGenerated by Druid"

	| currentBlock |
	self MoveR: ReceiverResultReg R: ClassReg.
	self MoveR: Arg0Reg R: SendNumArgsReg.
	self
		DivR: SendNumArgsReg
		R: ClassReg
		Quo: SendNumArgsReg
		Rem: ClassReg.
	self MoveR: ClassReg R: ReceiverResultReg.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveModByConstant [
	"AutoGenerated by Druid"

	| currentBlock s3 |
	self MoveR: ReceiverResultReg R: ClassReg.
	s3 := 2.
	self MoveCq: s3 R: SendNumArgsReg.
	self
		DivR: SendNumArgsReg
		R: ClassReg
		Quo: ClassReg
		Rem: SendNumArgsReg.
	self MoveR: SendNumArgsReg R: ReceiverResultReg.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveMultiply [

	| currentBlock |
	self MoveR: ReceiverResultReg R: TempReg.
	self MoveR: TempReg R: ReceiverResultReg.
	self MulR: ReceiverResultReg R: TempReg.
	self MoveR: TempReg R: ReceiverResultReg.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveMultiplyConstantArgument [
	"AutoGenerated by Druid"

	| currentBlock |
	self MoveR: ReceiverResultReg R: ClassReg.
	self LogicalShiftLeftCq: 1 R: ClassReg.
	self MoveR: ClassReg R: ReceiverResultReg.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveMultiplyConstantReceiver [
	"AutoGenerated by Druid"

	| currentBlock s3 |
	self MoveR: ReceiverResultReg R: ClassReg.
	s3 := 2.
	self MoveCq: s3 R: SendNumArgsReg.
	self MulR: ClassReg R: SendNumArgsReg.
	self MoveR: SendNumArgsReg R: ReceiverResultReg.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveMultiplyInverted [

	| currentBlock |
	self MoveCq: 2 R: TempReg.
	self MoveR: TempReg Cq: 2.
	self MulCq: 2 R: TempReg.
	self MoveR: TempReg R: ReceiverResultReg.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveMultiplyWithOverflow [
	"AutoGenerated by Druid"

	| jump1 currentBlock |
	self MoveR: ReceiverResultReg R: ClassReg.
	self MoveR: Arg0Reg R: SendNumArgsReg.
	self ArithmeticShiftRightCq: 3 R: ClassReg.
	self SubCq: 1 R: SendNumArgsReg.
	self MulR: ClassReg R: SendNumArgsReg.
	jump1 := self JumpMultiplyNoOverflow: 0.
	self MoveCq: 99 R: ReceiverResultReg.
	self genPrimReturn.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	self AddCq: 1 R: SendNumArgsReg.
	self MoveR: SendNumArgsReg R: ReceiverResultReg.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveNegated [
	"AutoGenerated by Druid"

	| currentBlock |
	self MoveR: ReceiverResultReg R: ClassReg.
	self MoveR: ClassReg R: ClassReg.
	self NegateR: ClassReg.
	self MoveR: ClassReg R: ReceiverResultReg.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveNew [
	"AutoGenerated by Druid"

	| s34 jump1 jump6 jump3 b349 currentBlock jump8 jump5 jump2 s23 jump7 jump4 |
	self SubCq: 8 R: SPReg.
	self MoveR: ReceiverResultReg R: ClassReg.
	self MoveM64: 24 r: ClassReg R: Extra3Reg.
	self MoveR: Extra3Reg Mw: 0 r: SPReg.
	self MoveMw: 0 r: SPReg R: Extra3Reg.
	self ArithmeticShiftRightCq: 3 R: Extra3Reg.
	self MoveR: Extra3Reg Mw: 0 r: SPReg.
	self MoveMw: 0 r: SPReg R: Extra3Reg.
	self MoveR: Extra3Reg R: Extra0Reg.
	self LogicalShiftRightCq: 16 R: Extra0Reg.
	self AndCq: 31 R: Extra0Reg.
	self CmpCq: 1 R: Extra0Reg.
	jump1 := self JumpBelowOrEqual: 0.
	self CmpCq: 5 R: Extra0Reg.
	jump2 := self JumpNonZero: 0.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	self MoveM32: 4 r: ClassReg R: ClassReg.
	self AndCq: 16rFFFFFFFF R: ClassReg.
	self AndCq: 16r3FFFFF R: ClassReg.
	self CmpCq: 0 R: ClassReg.
	jump1 := self JumpZero: 0.
	self CmpCq: 0 R: ClassReg.
	jump3 := self JumpAboveOrEqual: 0.
	jump4 := self Jump: 0.
	currentBlock := self Label.
	jump3 jmpTarget: currentBlock.
	self MoveMw: 0 r: SPReg R: Extra3Reg.
	self AndCq: 16rFFFF R: Extra3Reg.
	self MoveR: Extra3Reg Mw: 0 r: SPReg.
	self MoveMw: 0 r: SPReg R: Extra3Reg.
	self CmpCq: 255 R: Extra3Reg.
	jump3 := self JumpBelow: 0.
	jump5 := self Jump: 0.
	currentBlock := self Label.
	jump3 jmpTarget: currentBlock.
	self MoveMw: 0 r: SPReg R: Extra3Reg.
	self CmpCq: 1 R: Extra3Reg.
	jump3 := self JumpAboveOrEqual: 0.
	s23 := 8.
	self MoveCq: s23 R: Extra1Reg.
	jump6 := self Jump: 0.
	currentBlock := self Label.
	jump3 jmpTarget: currentBlock.
	self MoveMw: 0 r: SPReg R: Extra3Reg.
	self MoveR: Extra3Reg R: Extra1Reg.
	self LogicalShiftLeftCq: 3 R: Extra1Reg.
	currentBlock := self Label.
	jump6 jmpTarget: currentBlock.
	self AddCq: 8 R: Extra1Reg.
	self MoveAw: objectMemory freeStartAddress R: Extra2Reg.
	self AddR: Extra1Reg R: Extra2Reg.
	s34 := objectMemory getScavengeThreshold.
	self CmpCq: s34 R: Extra2Reg.
	jump6 := self JumpBelowOrEqual: 0.
	self CmpCq: s34 R: Extra2Reg.
	jump3 := self JumpAbove: 0.
	self MoveAw: objectMemory freeStartAddress R: Extra2Reg.
	jump7 := self Jump: 0.
	currentBlock := self Label.
	jump6 jmpTarget: currentBlock.
	self MoveAw: objectMemory freeStartAddress R: Extra2Reg.
	currentBlock := self Label.
	jump7 jmpTarget: currentBlock.
	self MoveMw: 0 r: SPReg R: Extra3Reg.
	self MoveR: Extra3Reg R: SendNumArgsReg.
	self LogicalShiftLeftCq: 56 R: SendNumArgsReg.
	self LogicalShiftLeftCq: 24 R: Extra0Reg.
	self AddR: Extra0Reg R: SendNumArgsReg.
	self AddR: ClassReg R: SendNumArgsReg.
	self OrCq: 0 R: SendNumArgsReg.
	self MoveR: SendNumArgsReg M64: 0 r: Extra2Reg.
	self MoveAw: objectMemory freeStartAddress R: SendNumArgsReg.
	self AddR: Extra1Reg R: SendNumArgsReg.
	self MoveR: SendNumArgsReg Aw: objectMemory freeStartAddress.
	self CmpCq: 0 R: Extra2Reg.
	jump7 := self JumpZero: 0.
	self genMoveConstant: objectMemory nilObject R: SendNumArgsReg.
	self MoveR: Extra2Reg R: Extra1Reg.
	self AddCq: 8 R: Extra1Reg.
	self MoveMw: 0 r: SPReg R: Extra3Reg.
	self LogicalShiftLeftCq: 3 R: Extra3Reg.
	self MoveR: Extra3Reg Mw: 0 r: SPReg.
	self MoveR: Extra2Reg R: ClassReg.
	self MoveMw: 0 r: SPReg R: Extra3Reg.
	self AddR: Extra3Reg R: ClassReg.
	self AddCq: 8 R: ClassReg.
	self SubCq: 1 R: ClassReg.
	b349 := self Label.
	self CmpR: Extra1Reg R: ClassReg.
	jump6 := self JumpLess: 0.
	self MoveR: SendNumArgsReg M64: 0 r: Extra1Reg.
	self MoveR: Extra1Reg R: Extra0Reg.
	self AddCq: 8 R: Extra0Reg.
	self MoveR: Extra0Reg R: Extra1Reg.
	jump8 := self Jump: b349.
	currentBlock := self Label.
	jump6 jmpTarget: currentBlock.
	self MoveR: Extra2Reg R: ReceiverResultReg.
	self AddCq: 8 R: SPReg.
	self genPrimReturn.
	currentBlock := self Label.
	jump4 jmpTarget: currentBlock.
	jump5 jmpTarget: currentBlock.
	currentBlock := self Label.
	jump7 jmpTarget: currentBlock.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	currentBlock := self Label.
	jump2 jmpTarget: currentBlock.
	currentBlock := self Label.
	jump3 jmpTarget: currentBlock.
	self AddCq: 8 R: SPReg.
	^ 0
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveNewWithArg [
	"AutoGenerated by Druid"

	| jump5 s169 s81 s55 jump10 s184 jump3 s86 b690 s173 jump1 jump8 currentBlock s49 s195 s90 s7 s141 s106 s233 jump6 s40 jump11 jump4 jump13 s93 s63 jump2 s109 s102 jump9 jump14 jump7 jump12 s66 |
	self SubCq: 32 R: SPReg.
	self MoveR: ReceiverResultReg R: Extra3Reg.
	self MoveR: Extra3Reg Mw: 0 r: SPReg.
	self MoveR: Arg0Reg R: SendNumArgsReg.
	self TstCq: 1 R: SendNumArgsReg.
	jump1 := self JumpZero: 0.
	self ArithmeticShiftRightCq: 3 R: SendNumArgsReg.
	self CmpCq: 0 R: SendNumArgsReg.
	jump2 := self JumpGreaterOrEqual: 0.
	s7 := 1.
	self MoveCq: s7 R: ClassReg.
	jump3 := self Jump: 0.
	currentBlock := self Label.
	jump2 jmpTarget: currentBlock.
	self MoveMw: 0 r: SPReg R: Extra3Reg.
	self MoveM64: 24 r: Extra3Reg R: Extra0Reg.
	self ArithmeticShiftRightCq: 3 R: Extra0Reg.
	self MoveR: Extra0Reg R: Extra1Reg.
	self LogicalShiftRightCq: 16 R: Extra1Reg.
	self AndCq: 31 R: Extra1Reg.
	self MoveMw: 0 r: SPReg R: Extra3Reg.
	self MoveM32: 4 r: Extra3Reg R: Extra3Reg.
	self AndCq: 16rFFFFFFFF R: Extra3Reg.
	self MoveR: Extra3Reg Mw: 8 r: SPReg.
	self MoveMw: 8 r: SPReg R: Extra3Reg.
	self AndCq: 16r3FFFFF R: Extra3Reg.
	self MoveR: Extra3Reg Mw: 8 r: SPReg.
	self CmpCq: 2 R: Extra1Reg.
	jump2 := self JumpNonZero: 0.
	self genMoveConstant: objectMemory nilObject R: Extra0Reg.
	self MoveR: Extra0Reg R: ClassReg.
	jump4 := self Jump: 0.
	currentBlock := self Label.
	jump2 jmpTarget: currentBlock.
	self CmpCq: 3 R: Extra1Reg.
	jump2 := self JumpNonZero: 0.
	self AndCq: 16rFFFF R: Extra0Reg.
	self AddR: SendNumArgsReg R: Extra0Reg.
	self genMoveConstant: objectMemory nilObject R: ClassReg.
	self MoveR: Extra0Reg R: SendNumArgsReg.
	jump5 := self Jump: 0.
	currentBlock := self Label.
	jump2 jmpTarget: currentBlock.
	self CmpCq: 4 R: Extra1Reg.
	jump2 := self JumpNonZero: 0.
	self AndCq: 16rFFFF R: Extra0Reg.
	self AddR: SendNumArgsReg R: Extra0Reg.
	self genMoveConstant: objectMemory nilObject R: ClassReg.
	self MoveR: Extra0Reg R: SendNumArgsReg.
	jump6 := self Jump: 0.
	currentBlock := self Label.
	jump2 jmpTarget: currentBlock.
	s40 := 0.
	self CmpCq: 9 R: Extra1Reg.
	jump2 := self JumpNonZero: 0.
	self MoveCq: s40 R: ClassReg.
	jump7 := self Jump: 0.
	currentBlock := self Label.
	jump2 jmpTarget: currentBlock.
	self CmpCq: 10 R: Extra1Reg.
	jump2 := self JumpNonZero: 0.
	self MoveMw: 8 r: SPReg R: Extra3Reg.
	self CmpCq: 34 R: Extra3Reg.
	jump8 := self JumpNonZero: 0.
	self CmpCq: 2 R: SendNumArgsReg.
	jump9 := self JumpZero: 0.
	s49 := 1.
	self MoveMw: 0 r: SPReg R: Extra3Reg.
	self MoveR: Extra3Reg R: SendNumArgsReg.
	self MoveCq: s49 R: ClassReg.
	jump10 := self Jump: 0.
	currentBlock := self Label.
	jump9 jmpTarget: currentBlock.
	self MoveR: SendNumArgsReg R: ClassReg.
	self AddCq: 1 R: ClassReg.
	s55 := 2.
	self MoveCq: s55 R: Extra0Reg.
	self
		DivR: Extra0Reg
		R: ClassReg
		Quo: ClassReg
		Rem: Extra0Reg.
	self AndCq: 1 R: SendNumArgsReg.
	self AddR: SendNumArgsReg R: Extra1Reg.
	jump9 := self Jump: 0.
	currentBlock := self Label.
	jump8 jmpTarget: currentBlock.
	s63 := 0.
	self MoveR: SendNumArgsReg R: ClassReg.
	self AddCq: 1 R: ClassReg.
	s66 := 2.
	self MoveCq: s66 R: Extra0Reg.
	self
		DivR: Extra0Reg
		R: ClassReg
		Quo: Extra0Reg
		Rem: ClassReg.
	self AndCq: 1 R: SendNumArgsReg.
	self AddR: SendNumArgsReg R: Extra1Reg.
	self MoveMw: 8 r: SPReg R: Extra3Reg.
	self CmpCq: 0 R: Extra3Reg.
	jump8 := self JumpNonZero: 0.
	self MoveCq: s63 R: ClassReg.
	jump11 := self Jump: 0.
	currentBlock := self Label.
	jump8 jmpTarget: currentBlock.
	self MoveR: Extra0Reg R: ClassReg.
	currentBlock := self Label.
	jump9 jmpTarget: currentBlock.
	s81 := 0.
	self MoveCq: s81 R: Extra0Reg.
	jump9 := self Jump: 0.
	currentBlock := self Label.
	jump2 jmpTarget: currentBlock.
	s86 := 0.
	self CmpCq: 12 R: Extra1Reg.
	jump2 := self JumpNonZero: 0.
	self MoveR: SendNumArgsReg R: ClassReg.
	self AddCq: 3 R: ClassReg.
	s90 := 4.
	self MoveCq: s90 R: Extra0Reg.
	self
		DivR: Extra0Reg
		R: ClassReg
		Quo: Extra2Reg
		Rem: Extra0Reg.
	s93 := 4.
	self MoveCq: s93 R: Extra0Reg.
	self SubR: SendNumArgsReg R: Extra0Reg.
	self AndCq: 3 R: Extra0Reg.
	self AddR: Extra0Reg R: Extra1Reg.
	self MoveCq: s86 R: ClassReg.
	self MoveR: Extra2Reg R: SendNumArgsReg.
	jump8 := self Jump: 0.
	currentBlock := self Label.
	jump2 jmpTarget: currentBlock.
	s102 := 0.
	self CmpCq: 16 R: Extra1Reg.
	jump2 := self JumpNonZero: 0.
	self MoveR: SendNumArgsReg R: Extra0Reg.
	self AddCq: 7 R: Extra0Reg.
	s106 := 8.
	self MoveCq: s106 R: Extra2Reg.
	self
		DivR: Extra2Reg
		R: Extra0Reg
		Quo: Extra2Reg
		Rem: Extra0Reg.
	s109 := 8.
	self MoveCq: s109 R: Extra0Reg.
	self SubR: SendNumArgsReg R: Extra0Reg.
	self AndCq: 7 R: Extra0Reg.
	self AddR: Extra0Reg R: Extra1Reg.
	self MoveCq: s102 R: ClassReg.
	self MoveR: Extra2Reg R: SendNumArgsReg.
	jump12 := self Jump: 0.
	currentBlock := self Label.
	jump2 jmpTarget: currentBlock.
	self CmpCq: 0 R: SendNumArgsReg.
	jump2 := self JumpNonZero: 0.
	self CmpCq: 5 R: Extra1Reg.
	jump13 := self JumpAbove: 0.
	self AndCq: 16rFFFF R: Extra0Reg.
	self genMoveConstant: objectMemory nilObject R: Extra2Reg.
	self MoveR: Extra2Reg R: ClassReg.
	self MoveR: Extra0Reg R: SendNumArgsReg.
	currentBlock := self Label.
	jump4 jmpTarget: currentBlock.
	jump5 jmpTarget: currentBlock.
	jump6 jmpTarget: currentBlock.
	jump7 jmpTarget: currentBlock.
	jump8 jmpTarget: currentBlock.
	jump12 jmpTarget: currentBlock.
	self MoveMw: 8 r: SPReg R: Extra3Reg.
	self CmpCq: 0 R: Extra3Reg.
	jump12 := self JumpNonZero: 0.
	self MoveR: SendNumArgsReg R: Extra0Reg.
	currentBlock := self Label.
	jump11 jmpTarget: currentBlock.
	self MoveMw: 0 r: SPReg R: Extra3Reg.
	self MoveM32: 4 r: Extra3Reg R: Extra2Reg.
	self AndCq: 16rFFFFFFFF R: Extra2Reg.
	self AndCq: 16r3FFFFF R: Extra2Reg.
	self CmpCq: 0 R: Extra2Reg.
	jump11 := self JumpZero: 0.
	self CmpCq: 0 R: Extra2Reg.
	jump8 := self JumpAboveOrEqual: 0.
	s141 := 1.
	self MoveMw: 0 r: SPReg R: Extra3Reg.
	self MoveR: Extra3Reg R: SendNumArgsReg.
	self MoveCq: s141 R: ClassReg.
	jump7 := self Jump: 0.
	currentBlock := self Label.
	jump8 jmpTarget: currentBlock.
	self MoveR: ClassReg R: Extra3Reg.
	self MoveR: Extra3Reg Mw: 16 r: SPReg.
	self MoveR: Extra0Reg R: Extra3Reg.
	self MoveR: Extra3Reg Mw: 24 r: SPReg.
	jump8 := self Jump: 0.
	currentBlock := self Label.
	jump12 jmpTarget: currentBlock.
	self MoveR: ClassReg R: Extra0Reg.
	self MoveR: SendNumArgsReg R: ClassReg.
	currentBlock := self Label.
	jump9 jmpTarget: currentBlock.
	self MoveR: Extra0Reg R: Extra3Reg.
	self MoveR: Extra3Reg Mw: 16 r: SPReg.
	self MoveR: ClassReg R: Extra3Reg.
	self MoveR: Extra3Reg Mw: 24 r: SPReg.
	self MoveMw: 8 r: SPReg R: Extra3Reg.
	self MoveR: Extra3Reg R: Extra2Reg.
	currentBlock := self Label.
	jump8 jmpTarget: currentBlock.
	self MoveMw: 24 r: SPReg R: Extra3Reg.
	self CmpCq: 16rFFFF R: Extra3Reg.
	jump8 := self JumpBelowOrEqual: 0.
	self MoveMw: 24 r: SPReg R: Extra3Reg.
	self CmpCq: 16r10000000000 R: Extra3Reg.
	jump9 := self JumpBelowOrEqual: 0.
	s169 := 1.
	self MoveMw: 0 r: SPReg R: Extra3Reg.
	self MoveR: Extra3Reg R: SendNumArgsReg.
	self MoveCq: s169 R: ClassReg.
	jump12 := self Jump: 0.
	currentBlock := self Label.
	jump9 jmpTarget: currentBlock.
	s173 := 1.
	self MoveMw: 0 r: SPReg R: Extra3Reg.
	self MoveR: Extra3Reg R: SendNumArgsReg.
	self MoveCq: s173 R: ClassReg.
	jump9 := self Jump: 0.
	currentBlock := self Label.
	jump8 jmpTarget: currentBlock.
	self MoveMw: 24 r: SPReg R: Extra3Reg.
	self CmpCq: 255 R: Extra3Reg.
	jump8 := self JumpBelow: 0.
	self MoveMw: 0 r: SPReg R: Extra3Reg.
	self MoveR: Extra3Reg R: Extra2Reg.
	self MoveR: Extra2Reg R: ReceiverResultReg.
	jump6 := self Jump: 0.
	currentBlock := self Label.
	jump8 jmpTarget: currentBlock.
	self MoveMw: 24 r: SPReg R: Extra3Reg.
	self CmpCq: 1 R: Extra3Reg.
	jump8 := self JumpAboveOrEqual: 0.
	s184 := 8.
	self MoveCq: s184 R: ClassReg.
	jump5 := self Jump: 0.
	currentBlock := self Label.
	jump8 jmpTarget: currentBlock.
	self MoveMw: 24 r: SPReg R: Extra3Reg.
	self MoveR: Extra3Reg R: ClassReg.
	self LogicalShiftLeftCq: 3 R: ClassReg.
	currentBlock := self Label.
	jump5 jmpTarget: currentBlock.
	self AddCq: 8 R: ClassReg.
	self MoveAw: objectMemory freeStartAddress R: SendNumArgsReg.
	self AddR: ClassReg R: SendNumArgsReg.
	s195 := objectMemory getScavengeThreshold.
	self CmpCq: s195 R: SendNumArgsReg.
	jump5 := self JumpBelowOrEqual: 0.
	self CmpCq: s195 R: SendNumArgsReg.
	jump8 := self JumpBelowOrEqual: 0.
	jump4 := self Jump: 0.
	currentBlock := self Label.
	jump5 jmpTarget: currentBlock.
	jump8 jmpTarget: currentBlock.
	self MoveAw: objectMemory freeStartAddress R: SendNumArgsReg.
	self MoveMw: 24 r: SPReg R: Extra3Reg.
	self MoveR: Extra3Reg R: Extra0Reg.
	self LogicalShiftLeftCq: 56 R: Extra0Reg.
	self LogicalShiftLeftCq: 24 R: Extra1Reg.
	self AddR: Extra1Reg R: Extra0Reg.
	self AddR: Extra2Reg R: Extra0Reg.
	self OrCq: 0 R: Extra0Reg.
	self MoveR: Extra0Reg M64: 0 r: SendNumArgsReg.
	self MoveAw: objectMemory freeStartAddress R: Extra0Reg.
	self AddR: ClassReg R: Extra0Reg.
	self MoveR: Extra0Reg Aw: objectMemory freeStartAddress.
	self CmpCq: 0 R: SendNumArgsReg.
	jump8 := self JumpNonZero: 0.
	jump5 := self Jump: 0.
	currentBlock := self Label.
	jump8 jmpTarget: currentBlock.
	self MoveR: SendNumArgsReg R: Extra0Reg.
	self AddCq: 8 R: Extra0Reg.
	self MoveMw: 24 r: SPReg R: Extra3Reg.
	self LogicalShiftLeftCq: 3 R: Extra3Reg.
	self MoveR: Extra3Reg Mw: 24 r: SPReg.
	self MoveR: SendNumArgsReg R: ClassReg.
	self MoveMw: 24 r: SPReg R: Extra3Reg.
	self AddR: Extra3Reg R: ClassReg.
	self AddCq: 8 R: ClassReg.
	self SubCq: 1 R: ClassReg.
	b690 := self Label.
	self CmpR: Extra0Reg R: ClassReg.
	jump8 := self JumpLess: 0.
	self MoveMw: 16 r: SPReg R: Extra3Reg.
	self MoveR: Extra3Reg M64: 0 r: Extra0Reg.
	self MoveR: Extra0Reg R: Extra2Reg.
	self AddCq: 8 R: Extra2Reg.
	self MoveR: Extra2Reg R: Extra0Reg.
	jump14 := self Jump: b690.
	currentBlock := self Label.
	jump8 jmpTarget: currentBlock.
	s233 := 0.
	self MoveCq: s233 R: ClassReg.
	currentBlock := self Label.
	jump3 jmpTarget: currentBlock.
	jump10 jmpTarget: currentBlock.
	jump7 jmpTarget: currentBlock.
	jump12 jmpTarget: currentBlock.
	jump9 jmpTarget: currentBlock.
	self MoveR: SendNumArgsReg R: ReceiverResultReg.
	self CmpCq: 0 R: ClassReg.
	jump9 := self JumpNonZero: 0.
	self AddCq: 32 R: SPReg.
	self genPrimReturn.
	currentBlock := self Label.
	jump6 jmpTarget: currentBlock.
	jump9 jmpTarget: currentBlock.
	currentBlock := self Label.
	jump4 jmpTarget: currentBlock.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	currentBlock := self Label.
	jump11 jmpTarget: currentBlock.
	currentBlock := self Label.
	jump2 jmpTarget: currentBlock.
	jump13 jmpTarget: currentBlock.
	jump5 jmpTarget: currentBlock.
	self AddCq: 32 R: SPReg.
	^ 0
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveNextUint16At [
	"AutoGenerated by Druid"

	| currentBlock |
	self MoveM16: 1 r: ReceiverResultReg R: TempReg.
	self AndCq: 16rFFFF R: TempReg.
	self MoveR: TempReg R: ReceiverResultReg.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveNoopLoopWithInvariant [
	"AutoGenerated by Druid"

	| jump3 jump1 currentBlock b18 jump2 |
	self MoveR: ReceiverResultReg R: ClassReg.
	self CmpCq: 10 R: ClassReg.
	jump1 := self JumpGreaterOrEqual: 0.
	b18 := self Label.
	self MoveR: ClassReg R: SendNumArgsReg.
	self AddCq: 1 R: SendNumArgsReg.
	self CmpCq: 10 R: SendNumArgsReg.
	jump2 := self JumpGreaterOrEqual: 0.
	self MoveR: SendNumArgsReg R: ClassReg.
	jump3 := self Jump: b18.
	currentBlock := self Label.
	jump2 jmpTarget: currentBlock.
	self MoveCq: 5 R: ReceiverResultReg.
	self genPrimReturn.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	self MoveCq: 3 R: ReceiverResultReg.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveNotEqualsThan [
	"AutoGenerated by Druid"

	| jump1 currentBlock |
	self MoveR: ReceiverResultReg R: ClassReg.
	self CmpCq: 10 R: ClassReg.
	jump1 := self JumpZero: 0.
	self MoveCq: 5 R: ReceiverResultReg.
	self genPrimReturn.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	self MoveCq: 11 R: ReceiverResultReg.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveNotEqualsThanFloats [
	"AutoGenerated by Druid"

	| jumpNext currentBlock jumpTrue |
	self MoveR: ReceiverResultReg R: ClassReg.
	self MoveR: Arg0Reg R: SendNumArgsReg.
	self ConvertR: SendNumArgsReg Rd: DPFPReg0.
	self ConvertR: ClassReg Rd: DPFPReg1.
	self CmpRd: DPFPReg1 Rd: DPFPReg0.
	jumpTrue := self JumpFPNotEqual: 0.
	self MoveCq: 0 R: ClassReg.
	jumpNext := self Jump: 0.
	jumpTrue jmpTarget: self Label.
	self MoveCq: 1 R: ClassReg.
	jumpNext jmpTarget: self Label.
	self MoveR: ClassReg R: ReceiverResultReg.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveNotEqualsThanInverted [
	"AutoGenerated by Druid"

	| jump1 currentBlock |
	self MoveR: ReceiverResultReg R: ClassReg.
	self CmpCq: 10 R: ClassReg.
	jump1 := self JumpZero: 0.
	self MoveCq: 5 R: ReceiverResultReg.
	self genPrimReturn.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	self MoveCq: 11 R: ReceiverResultReg.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveOr [
	"AutoGenerated by Druid"

	| jump1 currentBlock |
	self MoveR: ReceiverResultReg R: ClassReg.
	self CmpCq: 5 R: ClassReg.
	jump1 := self JumpGreaterOrEqual: 0.
	self MoveCq: 42 R: ReceiverResultReg.
	self genPrimReturn.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	self CmpCq: 10 R: ClassReg.
	jump1 := self JumpLessOrEqual: 0.
	self MoveCq: 42 R: ReceiverResultReg.
	self genPrimReturn.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	self MoveCq: 10 R: ReceiverResultReg.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitivePlusFloatConstant [
	"AutoGenerated by Druid"

	| currentBlock |
	self MoveR: ReceiverResultReg R: ClassReg.
	self ConvertR: ClassReg Rd: DPFPReg0.
	self MoveCq: (objectMemory rawFloatBitsOf: 3.14) R: ClassReg.
	self MoveR: ClassReg Rd: DPFPReg1.
	self AddRd: DPFPReg1 Rd: DPFPReg0.
	self MoveRd: DPFPReg0 R: ClassReg.
	self MoveR: ClassReg R: ReceiverResultReg.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitivePushFirstArgument [
	"AutoGenerated by Druid"

	| currentBlock |
	self MoveR: Arg0Reg R: ClassReg.
	self MoveR: ClassReg R: ReceiverResultReg.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitivePushReceiverOf0ArgSelector [
	"AutoGenerated by Druid"

	| currentBlock |
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitivePushReceiverOf1ArgSelector [
	"AutoGenerated by Druid"

	| currentBlock |
	self MoveR: Arg0Reg R: ClassReg.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitivePushStackValue0 [
	"AutoGenerated by Druid"

	| currentBlock |
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitivePushStackValue0WithOneArgument [
	"AutoGenerated by Druid"

	| currentBlock |
	self MoveR: Arg0Reg R: ReceiverResultReg.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitivePushStackValue1 [
	"AutoGenerated by Druid"

	| currentBlock |
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveReturnFalse [
	"AutoGenerated by Druid"

	| currentBlock s2 |
	s2 := objectMemory falseObject.
	self MoveCq: s2 R: ReceiverResultReg.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveReturnOne [
	"AutoGenerated by Druid"

	| currentBlock |
	self MoveCq: 1 R: ReceiverResultReg.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveReturnOneWithArguments [
	"AutoGenerated by Druid"

	| currentBlock |
	self MoveR: Arg0Reg R: ClassReg.
	self MoveR: Arg1Reg R: ClassReg.
	self MoveCq: 1 R: ReceiverResultReg.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveReturnTrue [
	"AutoGenerated by Druid"

	| currentBlock s2 |
	s2 := objectMemory trueObject.
	self MoveCq: s2 R: ReceiverResultReg.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveRotateLeft [
	"AutoGenerated by Druid"

	| currentBlock |
	self MoveR: ReceiverResultReg R: ClassReg.
	self RotateLeftCq: 1 R: ClassReg.
	self MoveR: ClassReg R: ReceiverResultReg.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveRotateLeftDoesNotBehavesLikeShift [
	"AutoGenerated by Druid"

	| currentBlock |
	self MoveR: ReceiverResultReg R: ClassReg.
	self RotateLeftCq: 1 R: ClassReg.
	self MoveR: ClassReg R: ReceiverResultReg.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveSandclock [
	"AutoGenerated by Druid"

	| jump1 currentBlock |
	self MoveR: ReceiverResultReg R: ClassReg.
	self CmpCq: 10 R: ClassReg.
	jump1 := self JumpLessOrEqual: 0.
	self MoveCq: 6 R: ReceiverResultReg.
	self genPrimReturn.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	self CmpCq: 0 R: ClassReg.
	jump1 := self JumpLessOrEqual: 0.
	self MoveCq: 104 R: ReceiverResultReg.
	self genPrimReturn.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	self MoveCq: 116 R: ReceiverResultReg.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveSize [
	"AutoGenerated by Druid"

	| jump1 jumpNext jump6 jump3 s108 currentBlock jump8 jump5 jumpTrue jump2 s159 s14 jump7 jump4 |
	self MoveR: ReceiverResultReg R: ClassReg.
	self MoveR: ClassReg R: Extra1Reg.
	self CmpCq: 7 R: Extra1Reg.
	jumpTrue := self JumpNonZero: 0.
	self MoveCq: 0 R: Extra1Reg.
	jumpNext := self Jump: 0.
	jumpTrue jmpTarget: self Label.
	self MoveCq: 1 R: Extra1Reg.
	jumpNext jmpTarget: self Label.
	self TstCq: 7 R: ClassReg.
	jump1 := self JumpZero: 0.
	jump2 := self Jump: 0.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	self MoveM64: 0 r: ClassReg R: Extra1Reg.
	self AndCq: 16r3FFFF7 R: Extra1Reg.
	s14 := 0.
	self MoveR: Extra1Reg R: Extra2Reg.
	self CmpCq: s14 R: Extra2Reg.
	jumpTrue := self JumpZero: 0.
	self MoveCq: 0 R: Extra2Reg.
	jumpNext := self Jump: 0.
	jumpTrue jmpTarget: self Label.
	self MoveCq: 1 R: Extra2Reg.
	jumpNext jmpTarget: self Label.
	self CmpCq: 0 R: Extra1Reg.
	jump1 := self JumpNonZero: 0.
	jump3 := self Jump: 0.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	self MoveM64: 0 r: ClassReg R: SendNumArgsReg.
	self MoveR: SendNumArgsReg R: Extra0Reg.
	self LogicalShiftRightCq: 24 R: Extra0Reg.
	self AndCq: 31 R: Extra0Reg.
	self MoveR: Extra0Reg R: Extra2Reg.
	self CmpCq: 2 R: Extra2Reg.
	jumpTrue := self JumpBelow: 0.
	self MoveCq: 0 R: Extra2Reg.
	jumpNext := self Jump: 0.
	jumpTrue jmpTarget: self Label.
	self MoveCq: 1 R: Extra2Reg.
	jumpNext jmpTarget: self Label.
	currentBlock := self Label.
	jump3 jmpTarget: currentBlock.
	self MoveR: Extra2Reg R: Extra1Reg.
	currentBlock := self Label.
	jump2 jmpTarget: currentBlock.
	self CmpCq: 1 R: Extra1Reg.
	jump2 := self JumpZero: 0.
	self CmpCq: 3 R: Extra0Reg.
	jump3 := self JumpNonZero: 0.
	self AndCq: 16r3FFFFF R: SendNumArgsReg.
	self CmpCq: 36 R: SendNumArgsReg.
	jump1 := self JumpZero: 0.
	self MoveMb: 7 r: ClassReg R: Extra2Reg.
	self AndCq: 255 R: Extra2Reg.
	self CmpCq: 255 R: Extra2Reg.
	jump4 := self JumpNonZero: 0.
	self MoveM64: -8 r: ClassReg R: Extra2Reg.
	self LogicalShiftLeftCq: 8 R: Extra2Reg.
	self LogicalShiftRightCq: 8 R: Extra2Reg.
	jump5 := self Jump: 0.
	currentBlock := self Label.
	jump4 jmpTarget: currentBlock.
	jump4 := self Jump: 0.
	currentBlock := self Label.
	jump3 jmpTarget: currentBlock.
	self MoveMb: 7 r: ClassReg R: Extra2Reg.
	self AndCq: 255 R: Extra2Reg.
	self CmpCq: 255 R: Extra2Reg.
	jump3 := self JumpNonZero: 0.
	self MoveM64: -8 r: ClassReg R: Extra2Reg.
	self LogicalShiftLeftCq: 8 R: Extra2Reg.
	self LogicalShiftRightCq: 8 R: Extra2Reg.
	self CmpCq: 5 R: Extra0Reg.
	jump6 := self JumpAbove: 0.
	currentBlock := self Label.
	jump5 jmpTarget: currentBlock.
	jump5 := self Jump: 0.
	currentBlock := self Label.
	jump6 jmpTarget: currentBlock.
	jump6 := self Jump: 0.
	currentBlock := self Label.
	jump3 jmpTarget: currentBlock.
	self CmpCq: 5 R: Extra0Reg.
	jump3 := self JumpAbove: 0.
	currentBlock := self Label.
	jump4 jmpTarget: currentBlock.
	currentBlock := self Label.
	jump5 jmpTarget: currentBlock.
	jump5 := self Jump: 0.
	currentBlock := self Label.
	jump3 jmpTarget: currentBlock.
	currentBlock := self Label.
	jump6 jmpTarget: currentBlock.
	self CmpCq: 16 R: Extra0Reg.
	jump6 := self JumpBelow: 0.
	self LogicalShiftLeftCq: 3 R: Extra2Reg.
	self MoveR: Extra0Reg R: SendNumArgsReg.
	self AndCq: 7 R: SendNumArgsReg.
	self SubR: SendNumArgsReg R: Extra2Reg.
	jump3 := self Jump: 0.
	currentBlock := self Label.
	jump6 jmpTarget: currentBlock.
	self CmpCq: 12 R: Extra0Reg.
	jump6 := self JumpBelow: 0.
	self LogicalShiftLeftCq: 2 R: Extra2Reg.
	self MoveR: Extra0Reg R: SendNumArgsReg.
	self AndCq: 3 R: SendNumArgsReg.
	self SubR: SendNumArgsReg R: Extra2Reg.
	jump4 := self Jump: 0.
	currentBlock := self Label.
	jump6 jmpTarget: currentBlock.
	self CmpCq: 10 R: Extra0Reg.
	jump6 := self JumpBelow: 0.
	self LogicalShiftLeftCq: 1 R: Extra2Reg.
	self MoveR: Extra0Reg R: SendNumArgsReg.
	self AndCq: 1 R: SendNumArgsReg.
	self SubR: SendNumArgsReg R: Extra2Reg.
	jump7 := self Jump: 0.
	currentBlock := self Label.
	jump6 jmpTarget: currentBlock.
	self CmpCq: 9 R: Extra0Reg.
	jump6 := self JumpNonZero: 0.
	jump8 := self Jump: 0.
	currentBlock := self Label.
	jump6 jmpTarget: currentBlock.
	s108 := 0.
	self MoveCq: s108 R: Extra2Reg.
	currentBlock := self Label.
	jump5 jmpTarget: currentBlock.
	jump3 jmpTarget: currentBlock.
	jump4 jmpTarget: currentBlock.
	jump7 jmpTarget: currentBlock.
	jump8 jmpTarget: currentBlock.
	self CmpCq: 9 R: Extra0Reg.
	jump8 := self JumpBelow: 0.
	self SubCq: 0 R: Extra2Reg.
	self MoveR: Extra2Reg R: SendNumArgsReg.
	self LogicalShiftLeftCq: 3 R: SendNumArgsReg.
	self AddCq: 1 R: SendNumArgsReg.
	self MoveR: SendNumArgsReg R: ReceiverResultReg.
	self genPrimReturn.
	currentBlock := self Label.
	jump8 jmpTarget: currentBlock.
	self CmpCq: 2 R: Extra0Reg.
	jump8 := self JumpNonZero: 0.
	self SubCq: 0 R: Extra2Reg.
	self MoveR: Extra2Reg R: SendNumArgsReg.
	self LogicalShiftLeftCq: 3 R: SendNumArgsReg.
	self AddCq: 1 R: SendNumArgsReg.
	self MoveR: SendNumArgsReg R: ReceiverResultReg.
	self genPrimReturn.
	currentBlock := self Label.
	jump8 jmpTarget: currentBlock.
	self CmpCq: 2 R: Extra0Reg.
	jump8 := self JumpAboveOrEqual: 0.
	self SubR: Extra2Reg R: Extra2Reg.
	self MoveR: Extra2Reg R: SendNumArgsReg.
	self LogicalShiftLeftCq: 3 R: SendNumArgsReg.
	self AddCq: 1 R: SendNumArgsReg.
	self MoveR: SendNumArgsReg R: ReceiverResultReg.
	self genPrimReturn.
	currentBlock := self Label.
	jump8 jmpTarget: currentBlock.
	self MoveM64: 0 r: ClassReg R: SendNumArgsReg.
	self AndCq: 16r3FFFFF R: SendNumArgsReg.
	self CmpCq: 31 R: SendNumArgsReg.
	jump8 := self JumpAbove: 0.
	self CmpCq: 31 R: SendNumArgsReg.
	jump7 := self JumpNonZero: 0.
	self MoveM64: 24 r: ClassReg R: SendNumArgsReg.
	self ArithmeticShiftRightCq: 3 R: SendNumArgsReg.
	self AndCq: 16rFFFF R: SendNumArgsReg.
	self SubR: SendNumArgsReg R: Extra2Reg.
	self MoveR: Extra2Reg R: SendNumArgsReg.
	self LogicalShiftLeftCq: 3 R: SendNumArgsReg.
	self AddCq: 1 R: SendNumArgsReg.
	self MoveR: SendNumArgsReg R: ReceiverResultReg.
	self genPrimReturn.
	currentBlock := self Label.
	jump7 jmpTarget: currentBlock.
	self CmpCq: 8 R: SendNumArgsReg.
	jump7 := self JumpNonZero: 0.
	self genMoveConstant: objectMemory nilObject R: SendNumArgsReg.
	self MoveM64: 24 r: SendNumArgsReg R: SendNumArgsReg.
	self ArithmeticShiftRightCq: 3 R: SendNumArgsReg.
	self AndCq: 16rFFFF R: SendNumArgsReg.
	self SubR: SendNumArgsReg R: Extra2Reg.
	self MoveR: Extra2Reg R: SendNumArgsReg.
	self LogicalShiftLeftCq: 3 R: SendNumArgsReg.
	self AddCq: 1 R: SendNumArgsReg.
	self MoveR: SendNumArgsReg R: ReceiverResultReg.
	self genPrimReturn.
	currentBlock := self Label.
	jump8 jmpTarget: currentBlock.
	jump7 jmpTarget: currentBlock.
	self MoveR: SendNumArgsReg R: ClassReg.
	self LogicalShiftRightCq: 10 R: ClassReg.
	s159 := objectMemory hiddenRootsObject.
	self LogicalShiftLeftCq: 3 R: ClassReg.
	self AddCq: s159 R: ClassReg.
	self MoveM64: 8 r: ClassReg R: ClassReg.
	self genMoveConstant: objectMemory nilObject R: Extra0Reg.
	self CmpR: Extra0Reg R: ClassReg.
	jump7 := self JumpNonZero: 0.
	self genMoveConstant: objectMemory nilObject R: Extra0Reg.
	jump8 := self Jump: 0.
	currentBlock := self Label.
	jump7 jmpTarget: currentBlock.
	self AndCq: 1023 R: SendNumArgsReg.
	self LogicalShiftLeftCq: 3 R: SendNumArgsReg.
	self AddR: SendNumArgsReg R: ClassReg.
	self MoveM64: 8 r: ClassReg R: Extra0Reg.
	currentBlock := self Label.
	jump8 jmpTarget: currentBlock.
	self MoveM64: 24 r: Extra0Reg R: Extra0Reg.
	self ArithmeticShiftRightCq: 3 R: Extra0Reg.
	self AndCq: 16rFFFF R: Extra0Reg.
	self SubR: Extra0Reg R: Extra2Reg.
	self MoveR: Extra2Reg R: Extra0Reg.
	self LogicalShiftLeftCq: 3 R: Extra0Reg.
	self AddCq: 1 R: Extra0Reg.
	self MoveR: Extra0Reg R: ReceiverResultReg.
	self genPrimReturn.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	currentBlock := self Label.
	jump2 jmpTarget: currentBlock.
	^ 0
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveSizeofusqInt [
	"AutoGenerated by Druid"

	| currentBlock |
	self MoveCq: 8 R: ReceiverResultReg.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveSmallFloatDivide [
	"AutoGenerated by Druid"

	| jump1 jump7 jumpNext jump10 jump9 jump6 jump3 s122 s119 currentBlock s94 jump8 jump5 jump2 jumpTrue s90 jump4 |
	self mclassIsSmallFloat ifFalse: [ ^ UnimplementedPrimitive ].
	self MoveR: ReceiverResultReg R: ClassReg.
	self MoveR: Arg0Reg R: SendNumArgsReg.
	self MoveR: ClassReg R: Extra0Reg.
	self AndCq: 7 R: Extra0Reg.
	self CmpCq: 0 R: Extra0Reg.
	jump1 := self JumpZero: 0.
	self CmpCq: 4 R: Extra0Reg.
	jump2 := self JumpNonZero: 0.
	self MoveR: ClassReg R: Extra0Reg.
	self LogicalShiftRightCq: 3 R: Extra0Reg.
	self CmpCq: 1 R: Extra0Reg.
	jump3 := self JumpBelowOrEqual: 0.
	self AddCq: 16r7000000000000000 R: Extra0Reg.
	jump4 := self Jump: 0.
	currentBlock := self Label.
	jump3 jmpTarget: currentBlock.
	currentBlock := self Label.
	jump4 jmpTarget: currentBlock.
	self MoveR: Extra0Reg R: ClassReg.
	self LogicalShiftLeftCq: 63 R: ClassReg.
	self LogicalShiftRightCq: 1 R: Extra0Reg.
	self AddR: Extra0Reg R: ClassReg.
	self MoveR: ClassReg Rd: DPFPReg0.
	jump4 := self Jump: 0.
	currentBlock := self Label.
	jump2 jmpTarget: currentBlock.
	self CmpCq: 1 R: Extra0Reg.
	jump2 := self JumpNonZero: 0.
	self MoveR: ClassReg R: Extra0Reg.
	self LogicalShiftLeftCq: 9 R: Extra0Reg.
	self ArithmeticShiftRightCq: 9 R: Extra0Reg.
	self CmpR: ClassReg R: Extra0Reg.
	jump3 := self JumpNonZero: 0.
	self ArithmeticShiftRightCq: 3 R: ClassReg.
	self ConvertR: ClassReg Rd: DPFPReg0.
	jump5 := self Jump: 0.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	self MoveM64: 0 r: ClassReg R: Extra0Reg.
	self AndCq: 16r3FFFFF R: Extra0Reg.
	self CmpCq: 34 R: Extra0Reg.
	jump1 := self JumpNonZero: 0.
	self MoveM64: 8 r: ClassReg Rd: DPFPReg0.
	currentBlock := self Label.
	jump4 jmpTarget: currentBlock.
	jump5 jmpTarget: currentBlock.
	self MoveR: SendNumArgsReg R: Extra0Reg.
	self AndCq: 7 R: Extra0Reg.
	self CmpCq: 0 R: Extra0Reg.
	jump5 := self JumpZero: 0.
	self CmpCq: 4 R: Extra0Reg.
	jump4 := self JumpNonZero: 0.
	self MoveR: SendNumArgsReg R: Extra0Reg.
	self LogicalShiftRightCq: 3 R: Extra0Reg.
	self CmpCq: 1 R: Extra0Reg.
	jump6 := self JumpBelowOrEqual: 0.
	self AddCq: 16r7000000000000000 R: Extra0Reg.
	jump7 := self Jump: 0.
	currentBlock := self Label.
	jump6 jmpTarget: currentBlock.
	currentBlock := self Label.
	jump7 jmpTarget: currentBlock.
	self MoveR: Extra0Reg R: SendNumArgsReg.
	self LogicalShiftLeftCq: 63 R: SendNumArgsReg.
	self LogicalShiftRightCq: 1 R: Extra0Reg.
	self AddR: Extra0Reg R: SendNumArgsReg.
	self MoveR: SendNumArgsReg Rd: DPFPReg1.
	jump7 := self Jump: 0.
	currentBlock := self Label.
	jump4 jmpTarget: currentBlock.
	self CmpCq: 1 R: Extra0Reg.
	jump4 := self JumpNonZero: 0.
	self MoveR: SendNumArgsReg R: Extra0Reg.
	self LogicalShiftLeftCq: 9 R: Extra0Reg.
	self ArithmeticShiftRightCq: 9 R: Extra0Reg.
	self CmpR: SendNumArgsReg R: Extra0Reg.
	jump6 := self JumpNonZero: 0.
	self ArithmeticShiftRightCq: 3 R: SendNumArgsReg.
	self ConvertR: SendNumArgsReg Rd: DPFPReg1.
	jump8 := self Jump: 0.
	currentBlock := self Label.
	jump5 jmpTarget: currentBlock.
	self MoveM64: 0 r: SendNumArgsReg R: Extra0Reg.
	self AndCq: 16r3FFFFF R: Extra0Reg.
	self CmpCq: 34 R: Extra0Reg.
	jump5 := self JumpNonZero: 0.
	self MoveM64: 8 r: SendNumArgsReg Rd: DPFPReg1.
	currentBlock := self Label.
	jump7 jmpTarget: currentBlock.
	jump8 jmpTarget: currentBlock.
	self CmpCq: 0.0 Rd: DPFPReg1.
	jump8 := self JumpFPEqual: 0.
	self DivRd: DPFPReg1 Rd: DPFPReg0.
	self MoveRd: DPFPReg0 R: Extra0Reg.
	self MoveR: Extra0Reg R: SendNumArgsReg.
	self LogicalShiftRightCq: 52 R: SendNumArgsReg.
	self AndCq: 2047 R: SendNumArgsReg.
	self CmpCq: 896 R: SendNumArgsReg.
	jump7 := self JumpBelowOrEqual: 0.
	self CmpCq: 1151 R: SendNumArgsReg.
	jumpTrue := self JumpBelowOrEqual: 0.
	self MoveCq: 0 R: SendNumArgsReg.
	jumpNext := self Jump: 0.
	jumpTrue jmpTarget: self Label.
	self MoveCq: 1 R: SendNumArgsReg.
	jumpNext jmpTarget: self Label.
	jump9 := self Jump: 0.
	currentBlock := self Label.
	jump7 jmpTarget: currentBlock.
	self AndCq: 16rFFFFFFFFFFFFF R: Extra0Reg.
	self CmpCq: 0 R: Extra0Reg.
	jump7 := self JumpNonZero: 0.
	s90 := 0.
	self CmpCq: s90 R: SendNumArgsReg.
	jumpTrue := self JumpZero: 0.
	self MoveCq: 0 R: SendNumArgsReg.
	jumpNext := self Jump: 0.
	jumpTrue jmpTarget: self Label.
	self MoveCq: 1 R: SendNumArgsReg.
	jumpNext jmpTarget: self Label.
	jump10 := self Jump: 0.
	currentBlock := self Label.
	jump7 jmpTarget: currentBlock.
	s94 := 896.
	self CmpCq: s94 R: SendNumArgsReg.
	jumpTrue := self JumpZero: 0.
	self MoveCq: 0 R: SendNumArgsReg.
	jumpNext := self Jump: 0.
	jumpTrue jmpTarget: self Label.
	self MoveCq: 1 R: SendNumArgsReg.
	jumpNext jmpTarget: self Label.
	currentBlock := self Label.
	jump10 jmpTarget: currentBlock.
	currentBlock := self Label.
	jump9 jmpTarget: currentBlock.
	self CmpCq: 1 R: SendNumArgsReg.
	jump9 := self JumpNonZero: 0.
	self MoveRd: DPFPReg0 R: SendNumArgsReg.
	self RotateLeftCq: 1 R: SendNumArgsReg.
	self CmpCq: 1 R: SendNumArgsReg.
	jump10 := self JumpBelowOrEqual: 0.
	self SubCq: 16r7000000000000000 R: SendNumArgsReg.
	jump7 := self Jump: 0.
	currentBlock := self Label.
	jump10 jmpTarget: currentBlock.
	currentBlock := self Label.
	jump7 jmpTarget: currentBlock.
	self LogicalShiftLeftCq: 3 R: SendNumArgsReg.
	self AddCq: 4 R: SendNumArgsReg.
	self MoveR: SendNumArgsReg R: ReceiverResultReg.
	jump7 := self Jump: 0.
	currentBlock := self Label.
	jump9 jmpTarget: currentBlock.
	self MoveAw: objectMemory freeStartAddress R: SendNumArgsReg.
	self MoveAw: objectMemory freeStartAddress R: Extra0Reg.
	self AddCq: 16 R: Extra0Reg.
	s119 := objectMemory getScavengeThreshold.
	self CmpCq: s119 R: Extra0Reg.
	jump9 := self JumpAbove: 0.
	s122 := 72057594205700130.
	self MoveCq: s122 R: Extra0Reg.
	self MoveR: Extra0Reg M64: 0 r: SendNumArgsReg.
	self MoveAw: objectMemory freeStartAddress R: Extra0Reg.
	self AddCq: 16 R: Extra0Reg.
	self MoveR: Extra0Reg Aw: objectMemory freeStartAddress.
	self MoveRd: DPFPReg0 M64: 8 r: SendNumArgsReg.
	self MoveR: SendNumArgsReg R: ReceiverResultReg.
	currentBlock := self Label.
	jump7 jmpTarget: currentBlock.
	self genPrimReturn.
	currentBlock := self Label.
	jump2 jmpTarget: currentBlock.
	jump3 jmpTarget: currentBlock.
	jump1 jmpTarget: currentBlock.
	jump4 jmpTarget: currentBlock.
	jump6 jmpTarget: currentBlock.
	jump5 jmpTarget: currentBlock.
	jump8 jmpTarget: currentBlock.
	jump9 jmpTarget: currentBlock.
	^ 0
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveSmallOrEqualsThan [

	| currentBlock jump0 jump1 |
	self MoveCq: true asBit R: TempReg.
	self MoveCq: 10 R: ClassReg.
	self CmpCq: 10 R: ReceiverResultReg.
	jump0 := self JumpGreater: 0.
	self MoveCq: 5 R: Extra0Reg.
	self MoveCq: 5 R: Extra1Reg.
	self MoveR: Extra1Reg R: ClassReg.
	self MoveR: ReceiverResultReg R: SendNumArgsReg.
	jump1 := self Jump: 0.
	currentBlock := self Label.
	jump0 jmpTarget: currentBlock.
	self MoveCq: 11 R: Extra2Reg.
	self MoveCq: 11 R: TempReg.
	self MoveR: TempReg R: ClassReg.
	self MoveR: ReceiverResultReg R: SendNumArgsReg.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	self MoveCq: 1 R: Extra0Reg.
	self MoveR: ClassReg R: ReceiverResultReg.
	self RetN: 1 * objectMemory wordSize.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveSmallThan [

	| currentBlock jump0 jump1 |
	self MoveCq: true asBit R: TempReg.
	self MoveCq: 10 R: ClassReg.
	self CmpCq: 10 R: ReceiverResultReg.
	jump0 := self JumpGreaterOrEqual: 0.
	self MoveCq: 5 R: Extra0Reg.
	self MoveCq: 5 R: Extra1Reg.
	self MoveR: Extra1Reg R: ClassReg.
	self MoveR: ReceiverResultReg R: SendNumArgsReg.
	jump1 := self Jump: 0.
	currentBlock := self Label.
	jump0 jmpTarget: currentBlock.
	self MoveCq: 11 R: Extra2Reg.
	self MoveCq: 11 R: TempReg.
	self MoveR: TempReg R: ClassReg.
	self MoveR: ReceiverResultReg R: SendNumArgsReg.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	self MoveCq: 1 R: Extra0Reg.
	self MoveR: ClassReg R: ReceiverResultReg.
	self RetN: 1 * objectMemory wordSize.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveSubWithOverflow [
	"AutoGenerated by Druid"

	| jump1 currentBlock |
	self MoveR: ReceiverResultReg R: ClassReg.
	self MoveR: Arg0Reg R: SendNumArgsReg.
	self AddCq:  -1 R: SendNumArgsReg.
	self SubR: SendNumArgsReg R: ClassReg.
	jump1 := self JumpNoOverflow: 0.
	self MoveCq: 99 R: ReceiverResultReg.
	self genPrimReturn.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	self MoveR: ClassReg R: ReceiverResultReg.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveSumWithOverflow [
	"AutoGenerated by Druid"

	| jump1 currentBlock |
	self MoveR: ReceiverResultReg R: ClassReg.
	self MoveR: Arg0Reg R: SendNumArgsReg.
	self AddCq:  -1 R: ClassReg.
	self AddR: SendNumArgsReg R: ClassReg.
	jump1 := self JumpNoOverflow: 0.
	self MoveCq: 99 R: ReceiverResultReg.
	self genPrimReturn.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	self MoveR: ClassReg R: ReceiverResultReg.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveTrueAssignmentAsInteger [
	"AutoGenerated by Druid"

	| currentBlock |
	self MoveCq: 1 R: ReceiverResultReg.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveTrueAssignmentAsIntegerShifted [
	"AutoGenerated by Druid"

	| currentBlock |
	self MoveCq: 2 R: ReceiverResultReg.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveTrueNot [
	"AutoGenerated by Druid"

	| currentBlock |
	self MoveCq: 0 R: ReceiverResultReg.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveUint16At [
	"AutoGenerated by Druid"

	| currentBlock |
	self MoveR: ReceiverResultReg R: ClassReg.
	self MoveM64: 0 r: ClassReg R: ClassReg.
	self AndCq: 16rFFFF R: ClassReg.
	self MoveR: ClassReg R: ReceiverResultReg.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveUint16AtPut [
	"AutoGenerated by Druid"

	| currentBlock |
	self MoveR: ReceiverResultReg R: ClassReg.
	self MoveR: Arg0Reg R: SendNumArgsReg.
	self MoveR: SendNumArgsReg M64: 0 r: ClassReg.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveUint32At [
	"AutoGenerated by Druid"

	| currentBlock |
	self MoveR: ReceiverResultReg R: ClassReg.
	self MoveM64: 0 r: ClassReg R: ClassReg.
	self AndCq: 16rFFFFFFFF R: ClassReg.
	self MoveR: ClassReg R: ReceiverResultReg.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveUint32AtPut [
	"AutoGenerated by Druid"

	| currentBlock |
	self MoveR: ReceiverResultReg R: ClassReg.
	self MoveR: Arg0Reg R: SendNumArgsReg.
	self MoveR: SendNumArgsReg M64: 0 r: ClassReg.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveUint64At [
	"AutoGenerated by Druid"

	| currentBlock |
	self MoveR: ReceiverResultReg R: ClassReg.
	self MoveM64: 0 r: ClassReg R: ClassReg.
	self MoveR: ClassReg R: ReceiverResultReg.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveUint64AtPut [
	"AutoGenerated by Druid"

	| currentBlock |
	self MoveR: ReceiverResultReg R: ClassReg.
	self MoveR: Arg0Reg R: SendNumArgsReg.
	self MoveR: SendNumArgsReg M64: 0 r: ClassReg.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveUint8At [
	"AutoGenerated by Druid"

	| currentBlock |
	self MoveR: ReceiverResultReg R: ClassReg.
	self MoveM64: 0 r: ClassReg R: ClassReg.
	self AndCq: 255 R: ClassReg.
	self MoveR: ClassReg R: ReceiverResultReg.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveUint8AtPut [
	"AutoGenerated by Druid"

	| currentBlock |
	self MoveR: ReceiverResultReg R: ClassReg.
	self MoveR: Arg0Reg R: SendNumArgsReg.
	self MoveR: SendNumArgsReg M64: 0 r: ClassReg.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveWithConditionalCompilation [
	"AutoGenerated by Druid"

	| currentBlock |
	self MoveCq: 17 R: ReceiverResultReg.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveWithDeadCode [
	"AutoGenerated by Druid"

	| jump1 currentBlock |
	self MoveR: ReceiverResultReg R: ClassReg.
	self CmpCq: 0 R: ClassReg.
	jump1 := self JumpNonZero: 0.
	self MoveCq: 42 R: ReceiverResultReg.
	self genPrimReturn.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	self MoveCq: 55 R: ReceiverResultReg.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveWithIfAssigningValue [

	| currentBlock jump0 jump1 |
	self CmpCq: 0 R: ReceiverResultReg.
	jump0 := self JumpZero: 0.
	self MoveCq: 57 R: ReceiverResultReg.
	jump1 := self Jump: 0.
	
	currentBlock := self Label.
	jump0 jmpTarget: currentBlock.
	self MoveCq: 42 R: ReceiverResultReg.
	
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	self RetN: 1 * objectMemory wordSize.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveWithIfNilIfNotNilStatement [
	"AutoGenerated by Druid"

	| jump1 currentBlock |
	self MoveR: ReceiverResultReg R: ClassReg.
	self CmpCq: 0 R: ClassReg.
	jump1 := self JumpLessOrEqual: 0.
	self MoveCq: 17 R: ReceiverResultReg.
	self genPrimReturn.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	self MoveCq: 42 R: ReceiverResultReg.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveWithIfNotNilIfNilStatement [
	"AutoGenerated by Druid"

	| jump1 currentBlock |
	self MoveR: ReceiverResultReg R: ClassReg.
	self CmpCq: 0 R: ClassReg.
	jump1 := self JumpLessOrEqual: 0.
	self MoveCq: 17 R: ReceiverResultReg.
	self genPrimReturn.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	self MoveCq: 42 R: ReceiverResultReg.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveWithIfNotNilIfNilStatementWithArgument [
	"AutoGenerated by Druid"

	| jump1 currentBlock |
	self MoveR: ReceiverResultReg R: ClassReg.
	self CmpCq: 0 R: ClassReg.
	jump1 := self JumpLessOrEqual: 0.
	self MoveCq: 17 R: ReceiverResultReg.
	self genPrimReturn.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	self MoveCq: 42 R: ReceiverResultReg.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveWithIfNotNilStatement [
	"AutoGenerated by Druid"

	| jump1 currentBlock |
	self MoveR: ReceiverResultReg R: ClassReg.
	self CmpCq: 0 R: ClassReg.
	jump1 := self JumpLessOrEqual: 0.
	self MoveCq: 17 R: ReceiverResultReg.
	self genPrimReturn.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	self MoveCq: 42 R: ReceiverResultReg.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveWithIfReturningValue [

	| currentBlock jump0 jump1 |
	self CmpCq: 0 R: ReceiverResultReg.
	jump0 := self JumpZero: 0.
	self MoveCq: 57 R: ReceiverResultReg.
	jump1 := self Jump: 0.
	
	currentBlock := self Label.
	jump0 jmpTarget: currentBlock.
	self MoveCq: 42 R: ReceiverResultReg.
	
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveWithNonCompilableBranch [
	"AutoGenerated by Druid"

	| jump1 currentBlock |
	self MoveR: ReceiverResultReg R: ClassReg.
	self CmpCq: 0 R: ClassReg.
	jump1 := self JumpLessOrEqual: 0.
	self MoveCq: 11 R: ReceiverResultReg.
	self genPrimReturn.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	^ 0
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveWithSequentialExitPoint [
	"AutoGenerated by Druid"

	| currentBlock |
	^ 0
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveWithTwoArgs [
	"AutoGenerated by Druid"

	| jump1 currentBlock |
	self MoveR: ReceiverResultReg R: ClassReg.
	self MoveR: Arg0Reg R: SendNumArgsReg.
	self MoveR: Arg1Reg R: Extra0Reg.
	self CmpCq: 0 R: ClassReg.
	jump1 := self JumpLessOrEqual: 0.
	self MoveR: Extra0Reg R: ReceiverResultReg.
	self genPrimReturn.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	self MoveR: SendNumArgsReg R: ReceiverResultReg.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_pushConstantOneBytecode [
	"AutoGenerated by Druid"

	| live currentBlock s2 |
	live := 0.
	s2 := ConstOne.
	self ssPushConstant: s2.
	^ 0
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_pushConstantTrueBytecode [
	"AutoGenerated by Druid"

	| live currentBlock s2 |
	live := 0.
	s2 := objectMemory trueObject.
	self ssPushConstant: s2.
	^ 0
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_pushConstantZeroBytecode [
	"AutoGenerated by Druid"

	| live currentBlock s2 |
	live := 0.
	s2 := ConstZero.
	self ssPushConstant: s2.
	^ 0
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_pushLiteralConstantBytecode [
	"AutoGenerated by Druid"

	| s3 t0 s4 currentBlock live s5 |
	live := 0.
	t0 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t0).
	self genMoveConstant: methodObj R: t0.
	s3 := LiteralStart.
	s4 := s3 + 1.
	s5 := s4 << 3.
	self AddCq: s5 R: t0.
	self ssPushBase: t0 offset: 8.
	^ 0
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_pushLiteralVariable16CasesBytecode [
	"AutoGenerated by Druid"

	| jump1 s3 s28 t1 jump3 currentBlock t0 jump2 s4 s29 b233 live jump4 |
	live := 0.
	t0 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t0).
	self genMoveConstant: methodObj R: t0.
	s3 := LiteralStart.
	s4 := s3 << 3.
	self AddCq: s4 R: t0.
	self MoveM64: 8 r: t0 R: t0.
	t1 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t1).
	self MoveM64: 0 r: t0 R: t1.
	self AndCq: 16r3FFFF7 R: t1.
	self CmpCq: 0 R: t1.
	jump1 := self JumpNonZero: 0.
	self MoveM64: 8 r: t0 R: t1.
	b233 := self Label.
	self MoveR: t1 R: t0.
	self AndCq: 7 R: t0.
	self CmpCq: 0 R: t0.
	jump2 := self JumpNonZero: 0.
	self MoveM64: 0 r: t1 R: t0.
	self AndCq: 16r3FFFF7 R: t0.
	self CmpCq: 0 R: t0.
	jump3 := self JumpNonZero: 0.
	self MoveM64: 8 r: t1 R: t0.
	self MoveR: t0 R: t1.
	jump4 := self Jump: b233.
	currentBlock := self Label.
	jump2 jmpTarget: currentBlock.
	jump3 jmpTarget: currentBlock.
	self MoveR: t1 R: t0.
	jump3 := self Jump: 0.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	currentBlock := self Label.
	jump3 jmpTarget: currentBlock.
	s28 := ValueIndex.
	s29 := s28 << 3.
	self AddCq: s29 R: t0.
	self ssPushBase: t0 offset: 8.
	^ 0
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_pushReceiverBytecode [
	"AutoGenerated by Druid"

	| live currentBlock t0 |
	live := 0.
	self ensureReceiverResultRegContainsSelf.
	t0 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t0).
	self MoveR: ReceiverResultReg R: t0.
	self ssPushRegister: t0.
	^ 0
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_pushReceiverVariableBytecode [
	"AutoGenerated by Druid"

	| live currentBlock t0 |
	live := 0.
	self ensureReceiverResultRegContainsSelf.
	t0 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t0).
	self MoveR: ReceiverResultReg R: t0.
	self ssPushBase: t0 offset: 16.
	^ 0
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_pushTemporaryVariableBytecode [
	"AutoGenerated by Druid"

	| live currentBlock t0 |
	live := 0.
	t0 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t0).
	(self simStackTempAt: 2) copyToReg: t0.
	self ssPushRegister: t0.
	^ 0
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_returnFalse [
	"AutoGenerated by Druid"

	| live currentBlock s2 |
	live := 0.
	s2 := objectMemory falseObject.
	self MoveCq: s2 R: ReceiverResultReg.
	self genUpArrowReturn.
	^ 0
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_returnNil [
	"AutoGenerated by Druid"

	| live currentBlock t0 |
	live := 0.
	t0 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t0).
	self genMoveConstant: objectMemory nilObject R: t0.
	self MoveR: t0 R: ReceiverResultReg.
	self genUpArrowReturn.
	^ 0
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_returnReceiver [
	"AutoGenerated by Druid"

	| live currentBlock t0 |
	live := 0.
	self ensureReceiverResultRegContainsSelf.
	t0 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t0).
	self MoveR: ReceiverResultReg R: t0.
	self MoveR: t0 R: ReceiverResultReg.
	self genUpArrowReturn.
	^ 0
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_returnTopFromMethod [
	"AutoGenerated by Druid"

	| live currentBlock t0 |
	live := 0.
	t0 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t0).
	(self ssValue: 0) copyToReg: t0.
	self ssPop: 1.
	self MoveR: t0 R: ReceiverResultReg.
	self genUpArrowReturn.
	^ 0
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_returnTrue [
	"AutoGenerated by Druid"

	| live currentBlock s2 |
	live := 0.
	s2 := objectMemory trueObject.
	self MoveCq: s2 R: ReceiverResultReg.
	self genUpArrowReturn.
	^ 0
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_sendLiteralSelector0ArgsBytecode [
	"AutoGenerated by Druid"

	| live currentBlock |
	live := 0.
	self marshallSendArguments: 0.
	self
		genMarshalledSend: 1
		numArgs: 0
		sendTable: ordinarySendTrampolines.
	^ 0
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_shortConditionalJumpFalse [
	"AutoGenerated by Druid"

	| jump1 s8 s5 s2 jump3 currentBlock s12 t0 jump2 live s9 |
	live := 0.
	self annotateBytecode: self Label.
	t0 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t0).
	(self ssValue: 0) copyToReg: t0.
	self ssPop: 1.
	s5 := objectMemory falseObject.
	self ssFlushStack.
	self CmpCq: s5 R: t0.
	jump1 := self JumpNonZero: 0.
	s8 := bytecodePC.
	s9 := s8 + 2.
	self Jump: (self ensureFixupAt: s9).
	deadCode := true.
	jump2 := self Jump: 0.
	deadCode := false.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	s12 := objectMemory trueObject.
	self CmpCq: s12 R: t0.
	jump1 := self JumpNonZero: 0.
	jump3 := self Jump: 0.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	self MoveR: t0 R: TempReg.
	self CallRT: ceSendMustBeBooleanTrampoline.
	currentBlock := self Label.
	jump2 jmpTarget: currentBlock.
	jump3 jmpTarget: currentBlock.
	^ 0
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_shortConditionalJumpTrue [
	"AutoGenerated by Druid"

	| jump1 s8 s5 s2 jump3 currentBlock s12 t0 jump2 live s9 |
	live := 0.
	self annotateBytecode: self Label.
	t0 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t0).
	(self ssValue: 0) copyToReg: t0.
	self ssPop: 1.
	s5 := objectMemory trueObject.
	self ssFlushStack.
	self CmpCq: s5 R: t0.
	jump1 := self JumpNonZero: 0.
	s8 := bytecodePC.
	s9 := s8 + 2.
	self Jump: (self ensureFixupAt: s9).
	deadCode := true.
	jump2 := self Jump: 0.
	deadCode := false.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	s12 := objectMemory falseObject.
	self CmpCq: s12 R: t0.
	jump1 := self JumpNonZero: 0.
	jump3 := self Jump: 0.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	self MoveR: t0 R: TempReg.
	self CallRT: ceSendMustBeBooleanTrampoline.
	currentBlock := self Label.
	jump2 jmpTarget: currentBlock.
	jump3 jmpTarget: currentBlock.
	^ 0
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_shortUnconditionalJump [
	"AutoGenerated by Druid"

	| s5 s2 currentBlock live s3 |
	live := 0.
	s2 := bytecodePC.
	s3 := s2 + 2.
	self ssFlushStack.
	self Jump: (self ensureFixupAt: s3).
	deadCode := true.
	^ 0
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_storeAndPopReceiverVariableBytecode [
	"AutoGenerated by Druid"

	| jump5 s24 s16 jump3 s29 jump8 jump1 t1 s2 currentBlock s19 s27 jump6 s56 live jump4 jump2 t2 s52 jump7 t0 |
	live := 0.
	self annotateBytecode: self Label.
	self ensureReceiverResultRegContainsSelf.
	t0 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t0).
	self MoveR: ReceiverResultReg R: t0.
	t1 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t1).
	(self ssValue: 0) copyToReg: t1.
	t2 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t2).
	self MoveM64: 0 r: t0 R: t2.
	self LogicalShiftRightCq: 23 R: t2.
	self AndCq: 1 R: t2.
	self ssFlushStack.
	self CmpCq: 0 R: t2.
	jump1 := self JumpZero: 0.
	self deoptimize.
	jump2 := self Jump: 0.
	deadCode := false.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	self ssPop: 1.
	self MoveR: t0 R: t2.
	self AndCq: 7 R: t2.
	self CmpCq: 0 R: t2.
	jump1 := self JumpNonZero: 0.
	s16 := objectMemory getMemoryMap getSpaceMaskToUse.
	self MoveR: t0 R: t2.
	self AndCq: s16 R: t2.
	s19 := objectMemory getMemoryMap getOldSpaceMask.
	self CmpCq: s19 R: t2.
	jump3 := self JumpNonZero: 0.
	self MoveR: t1 R: t2.
	self AndCq: 7 R: t2.
	self CmpCq: 0 R: t2.
	jump4 := self JumpNonZero: 0.
	s24 := objectMemory getMemoryMap getSpaceMaskToUse.
	self MoveR: t1 R: t2.
	self AndCq: s24 R: t2.
	s27 := objectMemory getMemoryMap getNewSpaceMask.
	self CmpCq: s27 R: t2.
	jump5 := self JumpNonZero: 0.
	s29 := objectMemory getMemoryMap getNewSpaceStart.
	self CmpCq: s29 R: t1.
	jump6 := self JumpBelow: 0.
	self MoveM64: 0 r: t0 R: t2.
	self LogicalShiftRightCq: 29 R: t2.
	self AndCq: 1 R: t2.
	self CmpCq: 0 R: t2.
	jump7 := self JumpNonZero: 0.
	self MoveR: t0 R: TempReg.
	backEnd saveAndRestoreLinkRegAround: [
		self CallRT: ceStoreCheckTrampoline ].
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	jump3 jmpTarget: currentBlock.
	jump4 jmpTarget: currentBlock.
	jump5 jmpTarget: currentBlock.
	jump6 jmpTarget: currentBlock.
	jump7 jmpTarget: currentBlock.
	self MoveM64: 0 r: t0 R: t2.
	self LogicalShiftRightCq: 29 R: t2.
	self AndCq: 1 R: t2.
	self CmpCq: 0 R: t2.
	jump7 := self JumpZero: 0.
	self MoveR: t1 M64: 8 r: t0.
	jump6 := self Jump: 0.
	currentBlock := self Label.
	jump7 jmpTarget: currentBlock.
	self TstCq: 7 R: t1.
	jump7 := self JumpZero: 0.
	self MoveR: t1 M64: 8 r: t0.
	jump5 := self Jump: 0.
	currentBlock := self Label.
	jump7 jmpTarget: currentBlock.
	self CmpCq: 16r20000000000 R: t0.
	jump7 := self JumpLess: 0.
	self CmpCq: 16r20000000000 R: t1.
	jump4 := self JumpLess: 0.
	self MoveR: t1 M64: 8 r: t0.
	jump3 := self Jump: 0.
	currentBlock := self Label.
	jump4 jmpTarget: currentBlock.
	self genMoveConstant: objectMemory nilObject R: t2.
	self CmpR: t2 R: t1.
	jump4 := self JumpBelow: 0.
	s52 := objectMemory trueObject.
	self CmpCq: s52 R: t1.
	jump1 := self JumpAbove: 0.
	self MoveR: t1 M64: 8 r: t0.
	jump8 := self Jump: 0.
	currentBlock := self Label.
	jump4 jmpTarget: currentBlock.
	jump1 jmpTarget: currentBlock.
	s56 := objectMemory getMemoryMap getNewSpaceStart.
	self CmpCq: s56 R: t1.
	jump1 := self JumpBelow: 0.
	self MoveR: t0 R: TempReg.
	backEnd saveAndRestoreLinkRegAround: [
		self CallRT: ceStoreCheckTrampoline ].
	self MoveR: t1 M64: 8 r: t0.
	jump4 := self Jump: 0.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	self MoveR: t1 M64: 8 r: t0.
	jump1 := self Jump: 0.
	currentBlock := self Label.
	jump7 jmpTarget: currentBlock.
	self MoveR: t1 M64: 8 r: t0.
	currentBlock := self Label.
	jump2 jmpTarget: currentBlock.
	jump6 jmpTarget: currentBlock.
	jump5 jmpTarget: currentBlock.
	jump3 jmpTarget: currentBlock.
	jump8 jmpTarget: currentBlock.
	jump4 jmpTarget: currentBlock.
	jump1 jmpTarget: currentBlock.
	^ 0
]

{ #category : #query }
DruidTestRTLCompiler >> hasAnnotatedAbstractInstructions: annotation [

	0 to: opcodeIndex - 1 do: [ :i |
		| instruction |
		instruction := self abstractInstructionAt: i.
		instruction annotation = annotation ifTrue: [ ^ true ] ].
	^ false
]

{ #category : #'trait candidates' }
DruidTestRTLCompiler >> initialize [

	super initialize.
	deadCode := false
]

{ #category : #generated }
DruidTestRTLCompiler >> numRegArgs [

	^ 2 "Hardcoded?"
]

{ #category : #compatibility }
DruidTestRTLCompiler >> shouldAnnotateObjectReference: anOop [
	"Objects in newSpace or oldSpace except nil, true, false & classTableRootObj need to be annotated."
	^(objectMemory isNonImmediate: anOop)
	  and: [(self oop: anOop isGreaterThan: objectMemory classTableRootObj)
		or: [self oop: anOop isLessThan: objectMemory nilObject]]
]

{ #category : #generated }
DruidTestRTLCompiler >> smallFloatSpecialisedPreamble [ 

	self mclassIsSmallFloat ifFalse:
		[^UnimplementedPrimitive].
]

{ #category : #generated }
DruidTestRTLCompiler >> smallIntegerSpecialisedPreamble [ 

	self mclassIsSmallInteger ifFalse:
		[^UnimplementedPrimitive].
]
