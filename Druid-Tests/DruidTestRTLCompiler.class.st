Class {
	#name : #DruidTestRTLCompiler,
	#superclass : #DruidJIT,
	#category : #'Druid-Tests'
}

{ #category : #'class initialization' }
DruidTestRTLCompiler class >> bytecodeTable [

	<generated>
	^ { { 1. 0. 0. #gen_BytecodeWithNoFrameInstVarRefAnnotation.
	  #isInstVarRef. #needsFrameNever:. 1 } }
]

{ #category : #'class initialization' }
DruidTestRTLCompiler class >> initializeBytecodeTableForSistaV1 [

	<generated>
	numPushNilsFunction := #sistaV1:Num:Push:Nils:.
	pushNilSizeFunction := #sistaV1PushNilSize:numInitialNils:.
	BytecodeSetHasDirectedSuperSend := true.
	BytecodeSetHasExtensions := true.
	FirstSpecialSelector := 96.
	NumSpecialSelectors := 32.
	self generatorTableFrom: self bytecodeTable
]

{ #category : #'class initialization' }
DruidTestRTLCompiler class >> initializePrimitiveTable [

	<generated>
	MaxCompiledPrimitiveIndex := 0.
	primitiveTable := CArrayAccessor on: (Array new: MaxCompiledPrimitiveIndex + 1).
	self table: primitiveTable from: self primitiveTableArray.
	^ primitiveTable
]

{ #category : #'class initialization' }
DruidTestRTLCompiler class >> primitiveTableArray [

	<generated>
	^ {  }
]

{ #category : #deployment }
DruidTestRTLCompiler class >> replaceMethodOnJIT: selector [

| druidMethod cogMethod |
druidMethod := DruidTestRTLCompiler lookupSelector: (#gen_, selector).
cogMethod := druidMethod ast copy.

"Change selector"
cogMethod selector: (#gen, selector capitalized).

"Replace self by cogit variable"
cogMethod nodesDo: [ :n | n isSelfVariable ifTrue: [ n replaceWith: (RBVariableNode named: 'cogit') ] ].

"Add type anotations"
cogMethod pragmas: { }.
cogMethod temporaries do: [ :temp | |args|	
	args := {temp name. #'AbstractInstruction *'} collect: [ :arg | RBLiteralNode value: arg ].
	cogMethod addPragma: (RBPragmaNode selector: #var:type: arguments: args).	
].


CogObjectRepresentation compile: cogMethod formattedCode classified: 'primitive generators'
]

{ #category : #compiling }
DruidTestRTLCompiler >> compileAbort [
	"Fake method"

	stackOverflowCall := self Nop
]

{ #category : #compiling }
DruidTestRTLCompiler >> compileEntry [
	"Fake method"

	
]

{ #category : #accessing }
DruidTestRTLCompiler >> deadCode [

	^ deadCode
]

{ #category : #accessing }
DruidTestRTLCompiler >> extA [

	<doNotGenerate>
	^ extA
]

{ #category : #accessing }
DruidTestRTLCompiler >> extA: anObject [

	<doNotGenerate>
	^ extA := anObject
]

{ #category : #accessing }
DruidTestRTLCompiler >> extB [

	<doNotGenerate>
	^ extB
]

{ #category : #accessing }
DruidTestRTLCompiler >> extB: anObject [

	<doNotGenerate>
	^ extB := anObject
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_BytecodeWithNoFrameInstVarRefAnnotation [
	"AutoGenerated by Druid"

	| live currentBlock |
	live := 0.
	^ 0
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_BytecodeWithNoFrameInstVarRefAnnotation0 [
	"AutoGenerated by Druid"

	| live currentBlock |
	live := 0.
	^ 0
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_BytecodeWithNoFrameInstVarRefAnnotation1 [
	"AutoGenerated by Druid"

	| live currentBlock |
	live := 0.
	^ 0
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_BytecodeWithNoFrameInstVarRefAnnotation2 [
	"AutoGenerated by Druid"

	| live currentBlock |
	live := 0.
	^ 0
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_BytecodeWithNoFrameInstVarRefAnnotation3 [
	"AutoGenerated by Druid"

	| live currentBlock |
	live := 0.
	^ 0
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_PrimitiveAdd [
	"AutoGenerated by Druid"

	| jump1 jump2 currentBlock |
	self mclassIsSmallInteger ifFalse: [ ^ UnimplementedPrimitive ].
	self MoveR: ReceiverResultReg R: TempReg.
	self MoveR: Arg0Reg R: ClassReg.
	self TstCq: 1 R: ClassReg.
	jump1 := self JumpZero: 0.
	self AddCq:  -1 R: ClassReg.
	self AddR: TempReg R: ClassReg.
	jump2 := self JumpOverflow: 0.
	self MoveR: ClassReg R: ReceiverResultReg.
	self genPrimReturn.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	jump2 jmpTarget: currentBlock.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_PushReceiverVariableBytecode [
	"AutoGenerated by Druid"

	| live currentBlock t0 |
	live := 0.
	self ensureReceiverResultRegContainsSelf.
	t0 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t0).
	self MoveR: ReceiverResultReg R: t0.
	self ssPushBase: t0 offset: 8.
	^ 0
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_ReturnTopFromMethod [
	"AutoGenerated by Druid"

	| live currentBlock t0 |
	live := 0.
	t0 := self allocateRegNotConflictingWith: live ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t0).
	(self ssValue: 0) copyToReg: t0.
	self ssPop: 1.
	self MoveR: t0 R: ReceiverResultReg.
	self genUpArrowReturn.
	^ 0
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_StoreAndPopReceiverVariableBytecode0 [
	"AutoGenerated by Druid"

	| jump1 jump7 jumpNext t1 jump6 jump3 jump9 currentBlock t0 jump5 jump2 jumpTrue jump8 live t2 jump4 |
	live := 0.
	self annotateBytecode: self Label.
	self ensureReceiverResultRegContainsSelf.
	t0 := self allocateRegNotConflictingWith: live ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t0).
	self MoveR: ReceiverResultReg R: t0.
	t1 := self allocateRegNotConflictingWith: live ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t1).
	(self ssValue: 0) copyToReg: t1.
	t2 := self allocateRegNotConflictingWith: live ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t2).
	self MoveM64: 0 r: t0 R: t2.
	self ArithmeticShiftRightCq: 23 R: t2.
	self AndCq: 1 R: t2.
	self ssFlushStack.
	self CmpCq: 0 R: t2.
	jump1 := self JumpZero: 0.
	self deoptimize.
	jump2 := self Jump: 0.
	deadCode := false.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	self ssPop: 1.
	self MoveR: t0 R: t2.
	self AndCq: 7 R: t2.
	self CmpCq: 0 R: t2.
	jump1 := self JumpNonZero: 0.
	self MoveR: t0 R: t2.
	self AndCq: objectMemory getMemoryMap getSpaceMaskToUse R: t2.
	self CmpCq: objectMemory getMemoryMap getOldSpaceMask R: t2.
	jump3 := self JumpNonZero: 0.
	self MoveR: t1 R: t2.
	self AndCq: 7 R: t2.
	self CmpCq: 0 R: t2.
	jump4 := self JumpNonZero: 0.
	self MoveR: t1 R: t2.
	self AndCq: objectMemory getMemoryMap getSpaceMaskToUse R: t2.
	self CmpCq: objectMemory getMemoryMap getNewSpaceMask R: t2.
	jump5 := self JumpNonZero: 0.
	self MoveR: t1 R: t2.
	self CmpCq: objectMemory getMemoryMap getNewSpaceStart R: t2.
	jumpTrue := self JumpGreaterOrEqual: 0.
	self MoveCq: 0 R: t2.
	jumpNext := self Jump: 0.
	jumpTrue jmpTarget: self Label.
	self MoveCq: 1 R: t2.
	jumpNext jmpTarget: self Label.
	self CmpCq: 1 R: t2.
	jump6 := self JumpNonZero: 0.
	self MoveM64: 0 r: t0 R: t2.
	self ArithmeticShiftRightCq: 29 R: t2.
	self AndCq: 1 R: t2.
	self CmpCq: 0 R: t2.
	jump7 := self JumpNonZero: 0.
	self MoveR: t0 R: TempReg.
	backEnd saveAndRestoreLinkRegAround: [ self CallRT: ceStoreCheckTrampoline ].
	self TstCq: 7 R: t1.
	jump8 := self JumpNonZero: 0.
	jump9 := self JumpZero: 0.
	currentBlock := self Label.
	jump5 jmpTarget: currentBlock.
	self MoveCq: 0 R: t2.
	currentBlock := self Label.
	jump6 jmpTarget: currentBlock.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	jump3 jmpTarget: currentBlock.
	jump4 jmpTarget: currentBlock.
	jump7 jmpTarget: currentBlock.
	self TstCq: 7 R: t1.
	jump7 := self JumpNonZero: 0.
	currentBlock := self Label.
	jump9 jmpTarget: currentBlock.
	self CmpCq: objectMemory nilObject R: t1.
	jump9 := self JumpBelow: 0.
	self MoveR: t1 R: t2.
	self CmpCq: objectMemory trueObject R: t2.
	jumpTrue := self JumpLessOrEqual: 0.
	self MoveCq: 0 R: t2.
	jumpNext := self Jump: 0.
	jumpTrue jmpTarget: self Label.
	self MoveCq: 1 R: t2.
	jumpNext jmpTarget: self Label.
	jump4 := self Jump: 0.
	currentBlock := self Label.
	jump9 jmpTarget: currentBlock.
	self MoveCq: 0 R: t2.
	currentBlock := self Label.
	jump4 jmpTarget: currentBlock.
	self CmpCq: 1 R: t2.
	jump4 := self JumpZero: 0.
	self CmpCq: objectMemory getMemoryMap getNewSpaceStart R: t1.
	jump9 := self JumpLess: 0.
	self MoveM64: 0 r: t0 R: t2.
	self ArithmeticShiftRightCq: 29 R: t2.
	self AndCq: 1 R: t2.
	self CmpCq: 0 R: t2.
	jump3 := self JumpNonZero: 0.
	self MoveR: t0 R: t2.
	self AndCq: 7 R: t2.
	self CmpCq: 0 R: t2.
	jump1 := self JumpNonZero: 0.
	self MoveR: t0 R: t2.
	self AndCq: objectMemory getMemoryMap getSpaceMaskToUse R: t2.
	self CmpCq: objectMemory getMemoryMap getPermSpaceMask R: t2.
	jumpTrue := self JumpZero: 0.
	self MoveCq: 0 R: t2.
	jumpNext := self Jump: 0.
	jumpTrue jmpTarget: self Label.
	self MoveCq: 1 R: t2.
	jumpNext jmpTarget: self Label.
	jump6 := self Jump: 0.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	self MoveCq: 0 R: t2.
	currentBlock := self Label.
	jump6 jmpTarget: currentBlock.
	self CmpCq: 1 R: t2.
	jump6 := self JumpNonZero: 0.
	self MoveR: t1 R: t2.
	self AndCq: objectMemory getMemoryMap getSpaceMaskToUse R: t2.
	self CmpCq: objectMemory getMemoryMap getPermSpaceMask R: t2.
	jump1 := self JumpZero: 0.
	self MoveR: t0 R: TempReg.
	backEnd saveAndRestoreLinkRegAround: [ self CallRT: ceStoreCheckTrampoline ].
	currentBlock := self Label.
	jump8 jmpTarget: currentBlock.
	jump7 jmpTarget: currentBlock.
	jump4 jmpTarget: currentBlock.
	jump9 jmpTarget: currentBlock.
	jump3 jmpTarget: currentBlock.
	jump6 jmpTarget: currentBlock.
	jump1 jmpTarget: currentBlock.
	self MoveR: t1 M64: 8 r: t0.
	currentBlock := self Label.
	jump2 jmpTarget: currentBlock.
	^ 0
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_StoreAndPopReceiverVariableBytecode1 [
	"AutoGenerated by Druid"

	| jump1 jump7 jumpNext t1 jump6 jump3 jump9 currentBlock t0 jump5 jump2 jumpTrue jump8 live t2 jump4 |
	live := 0.
	self annotateBytecode: self Label.
	self ensureReceiverResultRegContainsSelf.
	t0 := self allocateRegNotConflictingWith: live ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t0).
	self MoveR: ReceiverResultReg R: t0.
	t1 := self allocateRegNotConflictingWith: live ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t1).
	(self ssValue: 0) copyToReg: t1.
	t2 := self allocateRegNotConflictingWith: live ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t2).
	self MoveM64: 0 r: t0 R: t2.
	self ArithmeticShiftRightCq: 23 R: t2.
	self AndCq: 1 R: t2.
	self ssFlushStack.
	self CmpCq: 0 R: t2.
	jump1 := self JumpZero: 0.
	self deoptimize.
	jump2 := self Jump: 0.
	deadCode := false.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	self ssPop: 1.
	self MoveR: t0 R: t2.
	self AndCq: 7 R: t2.
	self CmpCq: 0 R: t2.
	jump1 := self JumpNonZero: 0.
	self MoveR: t0 R: t2.
	self AndCq: objectMemory getMemoryMap getSpaceMaskToUse R: t2.
	self CmpCq: objectMemory getMemoryMap getOldSpaceMask R: t2.
	jump3 := self JumpNonZero: 0.
	self MoveR: t1 R: t2.
	self AndCq: 7 R: t2.
	self CmpCq: 0 R: t2.
	jump4 := self JumpNonZero: 0.
	self MoveR: t1 R: t2.
	self AndCq: objectMemory getMemoryMap getSpaceMaskToUse R: t2.
	self CmpCq: objectMemory getMemoryMap getNewSpaceMask R: t2.
	jump5 := self JumpNonZero: 0.
	self MoveR: t1 R: t2.
	self CmpCq: objectMemory getMemoryMap getNewSpaceStart R: t2.
	jumpTrue := self JumpGreaterOrEqual: 0.
	self MoveCq: 0 R: t2.
	jumpNext := self Jump: 0.
	jumpTrue jmpTarget: self Label.
	self MoveCq: 1 R: t2.
	jumpNext jmpTarget: self Label.
	self CmpCq: 1 R: t2.
	jump6 := self JumpNonZero: 0.
	self MoveM64: 0 r: t0 R: t2.
	self ArithmeticShiftRightCq: 29 R: t2.
	self AndCq: 1 R: t2.
	self CmpCq: 0 R: t2.
	jump7 := self JumpNonZero: 0.
	self MoveR: t0 R: TempReg.
	backEnd saveAndRestoreLinkRegAround: [ self CallRT: ceStoreCheckTrampoline ].
	self TstCq: 7 R: t1.
	jump8 := self JumpNonZero: 0.
	jump9 := self JumpZero: 0.
	currentBlock := self Label.
	jump5 jmpTarget: currentBlock.
	self MoveCq: 0 R: t2.
	currentBlock := self Label.
	jump6 jmpTarget: currentBlock.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	jump3 jmpTarget: currentBlock.
	jump4 jmpTarget: currentBlock.
	jump7 jmpTarget: currentBlock.
	self TstCq: 7 R: t1.
	jump7 := self JumpNonZero: 0.
	currentBlock := self Label.
	jump9 jmpTarget: currentBlock.
	self CmpCq: objectMemory nilObject R: t1.
	jump9 := self JumpBelow: 0.
	self MoveR: t1 R: t2.
	self CmpCq: objectMemory trueObject R: t2.
	jumpTrue := self JumpLessOrEqual: 0.
	self MoveCq: 0 R: t2.
	jumpNext := self Jump: 0.
	jumpTrue jmpTarget: self Label.
	self MoveCq: 1 R: t2.
	jumpNext jmpTarget: self Label.
	jump4 := self Jump: 0.
	currentBlock := self Label.
	jump9 jmpTarget: currentBlock.
	self MoveCq: 0 R: t2.
	currentBlock := self Label.
	jump4 jmpTarget: currentBlock.
	self CmpCq: 1 R: t2.
	jump4 := self JumpZero: 0.
	self CmpCq: objectMemory getMemoryMap getNewSpaceStart R: t1.
	jump9 := self JumpLess: 0.
	self MoveM64: 0 r: t0 R: t2.
	self ArithmeticShiftRightCq: 29 R: t2.
	self AndCq: 1 R: t2.
	self CmpCq: 0 R: t2.
	jump3 := self JumpNonZero: 0.
	self MoveR: t0 R: t2.
	self AndCq: 7 R: t2.
	self CmpCq: 0 R: t2.
	jump1 := self JumpNonZero: 0.
	self MoveR: t0 R: t2.
	self AndCq: objectMemory getMemoryMap getSpaceMaskToUse R: t2.
	self CmpCq: objectMemory getMemoryMap getPermSpaceMask R: t2.
	jumpTrue := self JumpZero: 0.
	self MoveCq: 0 R: t2.
	jumpNext := self Jump: 0.
	jumpTrue jmpTarget: self Label.
	self MoveCq: 1 R: t2.
	jumpNext jmpTarget: self Label.
	jump6 := self Jump: 0.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	self MoveCq: 0 R: t2.
	currentBlock := self Label.
	jump6 jmpTarget: currentBlock.
	self CmpCq: 1 R: t2.
	jump6 := self JumpNonZero: 0.
	self MoveR: t1 R: t2.
	self AndCq: objectMemory getMemoryMap getSpaceMaskToUse R: t2.
	self CmpCq: objectMemory getMemoryMap getPermSpaceMask R: t2.
	jump1 := self JumpZero: 0.
	self MoveR: t0 R: TempReg.
	backEnd saveAndRestoreLinkRegAround: [ self CallRT: ceStoreCheckTrampoline ].
	currentBlock := self Label.
	jump8 jmpTarget: currentBlock.
	jump7 jmpTarget: currentBlock.
	jump4 jmpTarget: currentBlock.
	jump9 jmpTarget: currentBlock.
	jump3 jmpTarget: currentBlock.
	jump6 jmpTarget: currentBlock.
	jump1 jmpTarget: currentBlock.
	self MoveR: t1 M64: 16 r: t0.
	currentBlock := self Label.
	jump2 jmpTarget: currentBlock.
	^ 0
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_StoreAndPopReceiverVariableBytecode2 [
	"AutoGenerated by Druid"

	| jump1 jump7 jumpNext t1 jump6 jump3 jump9 currentBlock t0 jump5 jump2 jumpTrue jump8 live t2 jump4 |
	live := 0.
	self annotateBytecode: self Label.
	self ensureReceiverResultRegContainsSelf.
	t0 := self allocateRegNotConflictingWith: live ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t0).
	self MoveR: ReceiverResultReg R: t0.
	t1 := self allocateRegNotConflictingWith: live ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t1).
	(self ssValue: 0) copyToReg: t1.
	t2 := self allocateRegNotConflictingWith: live ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t2).
	self MoveM64: 0 r: t0 R: t2.
	self ArithmeticShiftRightCq: 23 R: t2.
	self AndCq: 1 R: t2.
	self ssFlushStack.
	self CmpCq: 0 R: t2.
	jump1 := self JumpZero: 0.
	self deoptimize.
	jump2 := self Jump: 0.
	deadCode := false.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	self ssPop: 1.
	self MoveR: t0 R: t2.
	self AndCq: 7 R: t2.
	self CmpCq: 0 R: t2.
	jump1 := self JumpNonZero: 0.
	self MoveR: t0 R: t2.
	self AndCq: objectMemory getMemoryMap getSpaceMaskToUse R: t2.
	self CmpCq: objectMemory getMemoryMap getOldSpaceMask R: t2.
	jump3 := self JumpNonZero: 0.
	self MoveR: t1 R: t2.
	self AndCq: 7 R: t2.
	self CmpCq: 0 R: t2.
	jump4 := self JumpNonZero: 0.
	self MoveR: t1 R: t2.
	self AndCq: objectMemory getMemoryMap getSpaceMaskToUse R: t2.
	self CmpCq: objectMemory getMemoryMap getNewSpaceMask R: t2.
	jump5 := self JumpNonZero: 0.
	self MoveR: t1 R: t2.
	self CmpCq: objectMemory getMemoryMap getNewSpaceStart R: t2.
	jumpTrue := self JumpGreaterOrEqual: 0.
	self MoveCq: 0 R: t2.
	jumpNext := self Jump: 0.
	jumpTrue jmpTarget: self Label.
	self MoveCq: 1 R: t2.
	jumpNext jmpTarget: self Label.
	self CmpCq: 1 R: t2.
	jump6 := self JumpNonZero: 0.
	self MoveM64: 0 r: t0 R: t2.
	self ArithmeticShiftRightCq: 29 R: t2.
	self AndCq: 1 R: t2.
	self CmpCq: 0 R: t2.
	jump7 := self JumpNonZero: 0.
	self MoveR: t0 R: TempReg.
	backEnd saveAndRestoreLinkRegAround: [ self CallRT: ceStoreCheckTrampoline ].
	self TstCq: 7 R: t1.
	jump8 := self JumpNonZero: 0.
	jump9 := self JumpZero: 0.
	currentBlock := self Label.
	jump5 jmpTarget: currentBlock.
	self MoveCq: 0 R: t2.
	currentBlock := self Label.
	jump6 jmpTarget: currentBlock.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	jump3 jmpTarget: currentBlock.
	jump4 jmpTarget: currentBlock.
	jump7 jmpTarget: currentBlock.
	self TstCq: 7 R: t1.
	jump7 := self JumpNonZero: 0.
	currentBlock := self Label.
	jump9 jmpTarget: currentBlock.
	self CmpCq: objectMemory nilObject R: t1.
	jump9 := self JumpBelow: 0.
	self MoveR: t1 R: t2.
	self CmpCq: objectMemory trueObject R: t2.
	jumpTrue := self JumpLessOrEqual: 0.
	self MoveCq: 0 R: t2.
	jumpNext := self Jump: 0.
	jumpTrue jmpTarget: self Label.
	self MoveCq: 1 R: t2.
	jumpNext jmpTarget: self Label.
	jump4 := self Jump: 0.
	currentBlock := self Label.
	jump9 jmpTarget: currentBlock.
	self MoveCq: 0 R: t2.
	currentBlock := self Label.
	jump4 jmpTarget: currentBlock.
	self CmpCq: 1 R: t2.
	jump4 := self JumpZero: 0.
	self CmpCq: objectMemory getMemoryMap getNewSpaceStart R: t1.
	jump9 := self JumpLess: 0.
	self MoveM64: 0 r: t0 R: t2.
	self ArithmeticShiftRightCq: 29 R: t2.
	self AndCq: 1 R: t2.
	self CmpCq: 0 R: t2.
	jump3 := self JumpNonZero: 0.
	self MoveR: t0 R: t2.
	self AndCq: 7 R: t2.
	self CmpCq: 0 R: t2.
	jump1 := self JumpNonZero: 0.
	self MoveR: t0 R: t2.
	self AndCq: objectMemory getMemoryMap getSpaceMaskToUse R: t2.
	self CmpCq: objectMemory getMemoryMap getPermSpaceMask R: t2.
	jumpTrue := self JumpZero: 0.
	self MoveCq: 0 R: t2.
	jumpNext := self Jump: 0.
	jumpTrue jmpTarget: self Label.
	self MoveCq: 1 R: t2.
	jumpNext jmpTarget: self Label.
	jump6 := self Jump: 0.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	self MoveCq: 0 R: t2.
	currentBlock := self Label.
	jump6 jmpTarget: currentBlock.
	self CmpCq: 1 R: t2.
	jump6 := self JumpNonZero: 0.
	self MoveR: t1 R: t2.
	self AndCq: objectMemory getMemoryMap getSpaceMaskToUse R: t2.
	self CmpCq: objectMemory getMemoryMap getPermSpaceMask R: t2.
	jump1 := self JumpZero: 0.
	self MoveR: t0 R: TempReg.
	backEnd saveAndRestoreLinkRegAround: [ self CallRT: ceStoreCheckTrampoline ].
	currentBlock := self Label.
	jump8 jmpTarget: currentBlock.
	jump7 jmpTarget: currentBlock.
	jump4 jmpTarget: currentBlock.
	jump9 jmpTarget: currentBlock.
	jump3 jmpTarget: currentBlock.
	jump6 jmpTarget: currentBlock.
	jump1 jmpTarget: currentBlock.
	self MoveR: t1 M64: 24 r: t0.
	currentBlock := self Label.
	jump2 jmpTarget: currentBlock.
	^ 0
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_StoreAndPopReceiverVariableBytecode3 [
	"AutoGenerated by Druid"

	| jump1 jump7 jumpNext t1 jump6 jump3 jump9 currentBlock t0 jump5 jump2 jumpTrue jump8 live t2 jump4 |
	live := 0.
	self annotateBytecode: self Label.
	self ensureReceiverResultRegContainsSelf.
	t0 := self allocateRegNotConflictingWith: live ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t0).
	self MoveR: ReceiverResultReg R: t0.
	t1 := self allocateRegNotConflictingWith: live ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t1).
	(self ssValue: 0) copyToReg: t1.
	t2 := self allocateRegNotConflictingWith: live ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t2).
	self MoveM64: 0 r: t0 R: t2.
	self ArithmeticShiftRightCq: 23 R: t2.
	self AndCq: 1 R: t2.
	self ssFlushStack.
	self CmpCq: 0 R: t2.
	jump1 := self JumpZero: 0.
	self deoptimize.
	jump2 := self Jump: 0.
	deadCode := false.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	self ssPop: 1.
	self MoveR: t0 R: t2.
	self AndCq: 7 R: t2.
	self CmpCq: 0 R: t2.
	jump1 := self JumpNonZero: 0.
	self MoveR: t0 R: t2.
	self AndCq: objectMemory getMemoryMap getSpaceMaskToUse R: t2.
	self CmpCq: objectMemory getMemoryMap getOldSpaceMask R: t2.
	jump3 := self JumpNonZero: 0.
	self MoveR: t1 R: t2.
	self AndCq: 7 R: t2.
	self CmpCq: 0 R: t2.
	jump4 := self JumpNonZero: 0.
	self MoveR: t1 R: t2.
	self AndCq: objectMemory getMemoryMap getSpaceMaskToUse R: t2.
	self CmpCq: objectMemory getMemoryMap getNewSpaceMask R: t2.
	jump5 := self JumpNonZero: 0.
	self MoveR: t1 R: t2.
	self CmpCq: objectMemory getMemoryMap getNewSpaceStart R: t2.
	jumpTrue := self JumpGreaterOrEqual: 0.
	self MoveCq: 0 R: t2.
	jumpNext := self Jump: 0.
	jumpTrue jmpTarget: self Label.
	self MoveCq: 1 R: t2.
	jumpNext jmpTarget: self Label.
	self CmpCq: 1 R: t2.
	jump6 := self JumpNonZero: 0.
	self MoveM64: 0 r: t0 R: t2.
	self ArithmeticShiftRightCq: 29 R: t2.
	self AndCq: 1 R: t2.
	self CmpCq: 0 R: t2.
	jump7 := self JumpNonZero: 0.
	self MoveR: t0 R: TempReg.
	backEnd saveAndRestoreLinkRegAround: [ self CallRT: ceStoreCheckTrampoline ].
	self TstCq: 7 R: t1.
	jump8 := self JumpNonZero: 0.
	jump9 := self JumpZero: 0.
	currentBlock := self Label.
	jump5 jmpTarget: currentBlock.
	self MoveCq: 0 R: t2.
	currentBlock := self Label.
	jump6 jmpTarget: currentBlock.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	jump3 jmpTarget: currentBlock.
	jump4 jmpTarget: currentBlock.
	jump7 jmpTarget: currentBlock.
	self TstCq: 7 R: t1.
	jump7 := self JumpNonZero: 0.
	currentBlock := self Label.
	jump9 jmpTarget: currentBlock.
	self CmpCq: objectMemory nilObject R: t1.
	jump9 := self JumpBelow: 0.
	self MoveR: t1 R: t2.
	self CmpCq: objectMemory trueObject R: t2.
	jumpTrue := self JumpLessOrEqual: 0.
	self MoveCq: 0 R: t2.
	jumpNext := self Jump: 0.
	jumpTrue jmpTarget: self Label.
	self MoveCq: 1 R: t2.
	jumpNext jmpTarget: self Label.
	jump4 := self Jump: 0.
	currentBlock := self Label.
	jump9 jmpTarget: currentBlock.
	self MoveCq: 0 R: t2.
	currentBlock := self Label.
	jump4 jmpTarget: currentBlock.
	self CmpCq: 1 R: t2.
	jump4 := self JumpZero: 0.
	self CmpCq: objectMemory getMemoryMap getNewSpaceStart R: t1.
	jump9 := self JumpLess: 0.
	self MoveM64: 0 r: t0 R: t2.
	self ArithmeticShiftRightCq: 29 R: t2.
	self AndCq: 1 R: t2.
	self CmpCq: 0 R: t2.
	jump3 := self JumpNonZero: 0.
	self MoveR: t0 R: t2.
	self AndCq: 7 R: t2.
	self CmpCq: 0 R: t2.
	jump1 := self JumpNonZero: 0.
	self MoveR: t0 R: t2.
	self AndCq: objectMemory getMemoryMap getSpaceMaskToUse R: t2.
	self CmpCq: objectMemory getMemoryMap getPermSpaceMask R: t2.
	jumpTrue := self JumpZero: 0.
	self MoveCq: 0 R: t2.
	jumpNext := self Jump: 0.
	jumpTrue jmpTarget: self Label.
	self MoveCq: 1 R: t2.
	jumpNext jmpTarget: self Label.
	jump6 := self Jump: 0.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	self MoveCq: 0 R: t2.
	currentBlock := self Label.
	jump6 jmpTarget: currentBlock.
	self CmpCq: 1 R: t2.
	jump6 := self JumpNonZero: 0.
	self MoveR: t1 R: t2.
	self AndCq: objectMemory getMemoryMap getSpaceMaskToUse R: t2.
	self CmpCq: objectMemory getMemoryMap getPermSpaceMask R: t2.
	jump1 := self JumpZero: 0.
	self MoveR: t0 R: TempReg.
	backEnd saveAndRestoreLinkRegAround: [ self CallRT: ceStoreCheckTrampoline ].
	currentBlock := self Label.
	jump8 jmpTarget: currentBlock.
	jump7 jmpTarget: currentBlock.
	jump4 jmpTarget: currentBlock.
	jump9 jmpTarget: currentBlock.
	jump3 jmpTarget: currentBlock.
	jump6 jmpTarget: currentBlock.
	jump1 jmpTarget: currentBlock.
	self MoveR: t1 M64: 32 r: t0.
	currentBlock := self Label.
	jump2 jmpTarget: currentBlock.
	^ 0
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_assertIsIgnored [

	| currentBlock |
	self MoveCq: 17 R: ReceiverResultReg.
	self RetN: 1 * objectMemory wordSize.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_branchingWithAssigments [

	| currentBlock jump0 jump1 |
	self CmpCq: 0 R: ReceiverResultReg.
	jump0 := self JumpLessOrEqual: 0.
	self MoveCq: 17 R: ReceiverResultReg.
	jump1 := self Jump: 0.
	currentBlock := self Label.
	jump0 jmpTarget: currentBlock.
	self MoveCq: 42 R: ReceiverResultReg.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	self RetN: 1 * objectMemory wordSize.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_bytecodePrimAdd [
	"AutoGenerated by Druid"

	| live currentBlock |
	live := 0.
	self marshallSendArguments: 1.
	self genMarshalledSend: -1 numArgs: 1 sendTable: ordinarySendTrampolines.
	^ 0
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_bytecodeWithDeoptimisation [
	"AutoGenerated by Druid"

	| live currentBlock |
	live := 0.
	self ssFlushStack.
	self deoptimize.
	^ 0
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_bytecodeWithFlushStackOnDominator [
	"AutoGenerated by Druid"

	| t0 jump1 currentBlock jump2 live |
	live := 0.
	self annotateBytecode: self Label.
	t0 := self allocateRegNotConflictingWith: live ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t0).
	(self ssValue: 0) copyToReg: t0.
	self ssFlushStack.
	self CmpCq: 0 R: t0.
	jump1 := self JumpLessOrEqual: 0.
	self deoptimize.
	jump2 := self Jump: 0.
	deadCode := false.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	(self ssValue: 0) copyToReg: t0.
	self MoveR: t0 R: TempReg.
	self CallRT: ceSendMustBeBooleanTrampoline.
	currentBlock := self Label.
	jump2 jmpTarget: currentBlock.
	^ 0
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_bytecodeWithPop [
	"AutoGenerated by Druid"

	| live currentBlock |
	live := 0.
	self ssPop: 1.
	^ 0
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_bytecodeWithUnknownBytecodeSend [
	"AutoGenerated by Druid"

	| live currentBlock |
	live := 0.
	self deoptimize.
	^ 0
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_duplicateTopBytecode [
	"AutoGenerated by Druid"

	| live currentBlock t0 |
	live := 0.
	t0 := self allocateRegNotConflictingWith: live ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t0).
	(self ssValue: 0) copyToReg: t0.
	self ssPushRegister: t0.
	^ 0
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_emptyPrimitive [
	"AutoGenerated by Druid"

	| currentBlock |
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_emptyPrimitiveWithArguments [
	"AutoGenerated by Druid"

	| currentBlock |
	self MoveR: Arg0Reg R: TempReg.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_extBBytecode [
	"AutoGenerated by Druid"

	| r54 r4 currentBlock live r115 |
	live := 0.
	r4 := numExtB.
	r4=0 ifTrue: [
		| r115 r54 |
		(byte1 > 127) ifTrue: [
			| r115 |
			extB := byte1 - 256.
			r115 := numExtB.
			numExtB := r115 + 1.
			^ 0 ].
		r54 := extB.
		extB := r54 << 8 + byte1.
		r115 := numExtB.
		numExtB := r115 + 1.
		^ 0 ].
	r54 := extB.
	extB := r54 << 8 + byte1.
	r115 := numExtB.
	numExtB := r115 + 1.
	^ 0
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_extPushIntegerBytecode [
	"AutoGenerated by Druid"

	| live r2 currentBlock |
	live := 0.
	r2 := extB.
	extB := 0.
	numExtB := 0.
	self ssPushConstant: (((byte1 + (r2 << 8)) << 3) + 1).
	^ 0
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_extSendSuperBytecode [
	"AutoGenerated by Druid"

	| live r5 r46 currentBlock |
	live := 0.
	r5 := extA.
	extA := 0.
	BytecodeSetHasDirectedSuperSend ifTrue: [
		| r12 r46 |
		r12 := extB.
		r12>=64 ifTrue: [
			self ssFlushStack.
			self deoptimize.
			deadCode := false.
			^ 0 ].
		r46 := extB.
		extB := 0.
		numExtB := 0.
		self marshallSendArguments: ((byte1 bitAnd: 7) + (r46 << 3)).
		self
			genMarshalledSend: ((byte1 >> 3) + (r5 << 5))
			numArgs: ((byte1 bitAnd: 7) + (r46 << 3))
			sendTable: superSendTrampolines.
		^ 0 ].
	r46 := extB.
	extB := 0.
	numExtB := 0.
	self marshallSendArguments: ((byte1 bitAnd: 7) + (r46 << 3)).
	self
		genMarshalledSend: ((byte1 >> 3) + (r5 << 5))
		numArgs: ((byte1 bitAnd: 7) + (r46 << 3))
		sendTable: superSendTrampolines.
	^ 0
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_extUnconditionalJump [
	"AutoGenerated by Druid"

	| t0 jump1 t1 currentBlock r3 live |
	live := 0.
	self annotateBytecode: self Label.
	r3 := extB.
	self ssFlushStack.
	t0 := self allocateRegNotConflictingWith: live ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t0).
	t1 := self allocateRegNotConflictingWith: live ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t1).
	(byte1 + (r3 << 8))<0 ifTrue: [
		| r11 jump1 |
		r11 := numExtB.
		extB := 0.
		numExtB := 0.
		((byte1 + (r3 << 8)) + (r11 * 2))>=0 ifTrue: [
			self Jump: (self ensureFixupAt: bytecodePC + 1 + (byte1 + (r3 << 8)) + 1).
			deadCode := true.
			^ 0 ].
		self MoveR: SPReg R: t0.
		self MoveAw: coInterpreter stackLimitAddress R: t1.
		self CmpR: t1 R: t0.
		jump1 := self JumpAboveOrEqual: 0.
		self CallRT: ceCheckForInterruptTrampoline.
		currentBlock := self Label.
		jump1 jmpTarget: currentBlock.
		self Jump: (self ensureFixupAt: bytecodePC + 1 + (byte1 + (r3 << 8)) + 1).
		deadCode := true.
		^ 0 ].
	extB := 0.
	numExtB := 0.
	((byte1 + (r3 << 8)) + 0)>=0 ifTrue: [
		self Jump: (self ensureFixupAt: bytecodePC + 1 + (byte1 + (r3 << 8)) + 1).
		deadCode := true.
		^ 0 ].
	self MoveR: SPReg R: t0.
	self MoveAw: coInterpreter stackLimitAddress R: t1.
	self CmpR: t1 R: t0.
	jump1 := self JumpAboveOrEqual: 0.
	self CallRT: ceCheckForInterruptTrampoline.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	self Jump: (self ensureFixupAt: bytecodePC + 1 + (byte1 + (r3 << 8)) + 1).
	deadCode := true.
	^ 0
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_extendedPushBytecode [
	"AutoGenerated by Druid"

	| t0 t1 currentBlock live t2 |
	live := 0.
	t0 := self allocateRegNotConflictingWith: live ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t0).
	((byte1 >> 6) bitAnd: 3)=0 ifTrue: [
		self ensureReceiverResultRegContainsSelf.
		self MoveR: ReceiverResultReg R: t0.
		self ssPushBase: t0 offset: (byte1 bitAnd: 63) << 3 + 8.
		^ 0 ].
	((byte1 >> 6) bitAnd: 3)=1 ifTrue: [
		(self simStackTempAt: (byte1 bitAnd: 63)) copyToReg: t0.
		self ssPushRegister: t0.
		^ 0 ].
	((byte1 >> 6) bitAnd: 3)=2 ifTrue: [
		self genMoveConstant: methodObj R: t0.
		self ssPushConstant:
			(coInterpreter int64AtPointer:  ((methodObj + 8) + (((byte1 bitAnd: 63) + LiteralStart) << 3))).
		^ 0 ].
	t1 := self allocateRegNotConflictingWith: live ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t1).
	t2 := self allocateRegNotConflictingWith: live ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t2).
	((byte1 >> 6) bitAnd: 3)=3 ifTrue: [
		self genMoveConstant: methodObj R: t0.
		0=((coInterpreter int64AtPointer:  (coInterpreter int64AtPointer:  ((methodObj + 8) + (((byte1 bitAnd: 63) + LiteralStart) << 3)))) bitAnd: 4194295)
			ifTrue: [
				| jumpTrue jumpNext jump1 jump3 b316 jump2 |
				self
					MoveCq:
					(coInterpreter int64AtPointer:  (((coInterpreter int64AtPointer:  ((methodObj + 8) + (((byte1 bitAnd: 63) + LiteralStart) << 3))) + 8) + 0))
					R: t0.
				b316 := self Label.
				self MoveR: t0 R: t1.
				self AndCq: 7 R: t1.
				self CmpCq: 0 R: t1.
				jump1 := self JumpNonZero: 0.
				self MoveM64: 0 r: t0 R: t1.
				self AndCq: 16r3FFFF7 R: t1.
				self MoveR: t1 R: t2.
				self CmpCq: 0 R: t2.
				jumpTrue := self JumpZero: 0.
				self MoveCq: 0 R: t2.
				jumpNext := self Jump: 0.
				jumpTrue jmpTarget: self Label.
				self MoveCq: 1 R: t2.
				jumpNext jmpTarget: self Label.
				self CmpCq: 0 R: t1.
				jump2 := self JumpNonZero: 0.
				self MoveM64: 8 r: t0 R: t2.
				self MoveR: t2 R: t0.
				jump3 := self Jump: b316.
				currentBlock := self Label.
				jump1 jmpTarget: currentBlock.
				jump2 jmpTarget: currentBlock.
				self ssPushConstant:
					(coInterpreter int64AtPointer:  (((coInterpreter int64AtPointer:  ((methodObj + 8) + (((byte1 bitAnd: 63) + LiteralStart) << 3))) + 8) + (ValueIndex << 3))).
				^ 0 ].
		self ssPushConstant:
			(coInterpreter int64AtPointer:  (((coInterpreter int64AtPointer:  ((methodObj + 8) + (((byte1 bitAnd: 63) + LiteralStart) << 3))) + 8) + (ValueIndex << 3))).
		^ 0 ].
	^ 0
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_failingPrimitive [
	"AutoGenerated by Druid"

	| currentBlock |
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_failingPrimitive2 [

	| currentBlock |
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_failingPrimitiveWithArg [
	"AutoGenerated by Druid"

	| currentBlock |
	self MoveR: Arg0Reg R: TempReg.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_failingSuccess [
	"AutoGenerated by Druid"

	| currentBlock |
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_ifZeroFailPrimitive [
	"AutoGenerated by Druid"

	| jump1 currentBlock |
	self MoveR: ReceiverResultReg R: TempReg.
	self MoveR: Arg0Reg R: ClassReg.
	self CmpCq: 0 R: TempReg.
	jump1 := self JumpZero: 0.
	self MoveCq: 42 R: ReceiverResultReg.
	self genPrimReturn.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_passingSuccess [
	"AutoGenerated by Druid"

	| currentBlock |
	self MoveCq: 1 R: ReceiverResultReg.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveAccessTempAfterCall [
	"AutoGenerated by Druid"

	| currentBlock |
	self MoveCq: 17 R: ReceiverResultReg.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveAdd [
	"AutoGenerated by Druid"

	| jump1 jump2 currentBlock |
	self mclassIsSmallInteger ifFalse: [ ^ UnimplementedPrimitive ].
	self MoveR: ReceiverResultReg R: TempReg.
	self MoveR: Arg0Reg R: ClassReg.
	self TstCq: 1 R: ClassReg.
	jump1 := self JumpZero: 0.
	self AddCq:  -1 R: ClassReg.
	self AddR: TempReg R: ClassReg.
	jump2 := self JumpOverflow: 0.
	self MoveR: ClassReg R: ReceiverResultReg.
	self genPrimReturn.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	jump2 jmpTarget: currentBlock.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveAnd [
	"AutoGenerated by Druid"

	| jump1 jump2 jump3 currentBlock |
	self MoveR: ReceiverResultReg R: TempReg.
	self CmpCq: 0 R: TempReg.
	jump1 := self JumpLessOrEqual: 0.
	self CmpCq: 10 R: TempReg.
	jump2 := self JumpLessOrEqual: 0.
	self MoveCq: 42 R: ReceiverResultReg.
	jump3 := self Jump: 0.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	jump2 jmpTarget: currentBlock.
	self MoveCq: 10 R: ReceiverResultReg.
	currentBlock := self Label.
	jump3 jmpTarget: currentBlock.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveAndIfTrue [
	"AutoGenerated by Druid"

	| jump1 jump2 jump3 currentBlock |
	self MoveR: ReceiverResultReg R: TempReg.
	self CmpCq: 1 R: TempReg.
	jump1 := self JumpLessOrEqual: 0.
	self AndCq: 1 R: TempReg.
	self CmpCq: 1 R: TempReg.
	jump2 := self JumpNonZero: 0.
	self MoveCq: 1 R: ReceiverResultReg.
	jump3 := self Jump: 0.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	jump2 jmpTarget: currentBlock.
	self MoveCq: 2 R: ReceiverResultReg.
	currentBlock := self Label.
	jump3 jmpTarget: currentBlock.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveArithmeticBitShiftRight [
	"AutoGenerated by Druid"

	| currentBlock |
	self MoveR: ReceiverResultReg R: TempReg.
	self MoveR: Arg0Reg R: ClassReg.
	self ArithmeticShiftRightR: ClassReg R: TempReg.
	self MoveR: TempReg R: ReceiverResultReg.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveAsInteger [
	"AutoGenerated by Druid"

	| currentBlock |
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveAssertDeferredInline [
	"AutoGenerated by Druid"

	| jump1 jump2 jump3 currentBlock |
	self MoveCq: 0 R: TempReg.
	self MoveR: TempReg Aw: coInterpreter primitiveFailureCodeAddress.
	self MoveAw: coInterpreter primitiveFailureCodeAddress R: TempReg.
	self MoveR: ReceiverResultReg R: ClassReg.
	self CmpCq: 0 R: ClassReg.
	jump1 := self JumpNonZero: 0.
	self MoveR: TempReg Aw: coInterpreter primitiveFailureCodeAddress.
	self MoveCq: 1 R: ClassReg.
	self MoveR: ClassReg Aw: coInterpreter primitiveFailureCodeAddress.
	self MoveAw: coInterpreter primitiveFailureCodeAddress R: ClassReg.
	self MoveR: ClassReg Aw: coInterpreter primitiveFailureCodeAddress.
	self MoveAw: coInterpreter primitiveFailureCodeAddress R: ClassReg.
	self MoveCq: 42 R: ReceiverResultReg.
	self CmpCq: 0 R: ClassReg.
	jump2 := self JumpZero: 0.
	jump3 := self JumpNonZero: 0.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	self MoveR: TempReg Aw: coInterpreter primitiveFailureCodeAddress.
	self MoveAw: coInterpreter primitiveFailureCodeAddress R: ClassReg.
	self MoveCq: 42 R: ReceiverResultReg.
	self CmpCq: 0 R: ClassReg.
	jump1 := self JumpNonZero: 0.
	currentBlock := self Label.
	jump2 jmpTarget: currentBlock.
	self genPrimReturn.
	currentBlock := self Label.
	jump3 jmpTarget: currentBlock.
	jump1 jmpTarget: currentBlock.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveAssertIsIgnored [
	"AutoGenerated by Druid"

	| currentBlock |
	self MoveCq: 17 R: ReceiverResultReg.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveAt [
	"AutoGenerated by Druid"

	| jump1 jumpNext jump9 jump6 jump3 currentBlock jump8 jump5 jumpTrue jump2 jump7 jump4 |
	self AddCq: 8 R: SPReg.
	self MoveR: ReceiverResultReg R: Extra3Reg.
	self MoveR: Extra3Reg Mw: 8 r: SPReg.
	self MoveR: Arg0Reg R: ClassReg.
	self MoveMw: 8 r: SPReg R: Extra3Reg.
	self TstCq: 7 R: Extra3Reg.
	jump1 := self JumpNonZero: 0.
	self MoveR: ClassReg R: SendNumArgsReg.
	self AndCq: 1 R: SendNumArgsReg.
	self MoveR: SendNumArgsReg R: Extra0Reg.
	self CmpCq: 0 R: Extra0Reg.
	jumpTrue := self JumpZero: 0.
	self MoveCq: 0 R: Extra0Reg.
	jumpNext := self Jump: 0.
	jumpTrue jmpTarget: self Label.
	self MoveCq: 1 R: Extra0Reg.
	jumpNext jmpTarget: self Label.
	self CmpCq: 0 R: SendNumArgsReg.
	jump2 := self JumpNonZero: 0.
	jump3 := self Jump: 0.
	currentBlock := self Label.
	jump2 jmpTarget: currentBlock.
	self MoveCq: 0 R: Extra0Reg.
	currentBlock := self Label.
	jump3 jmpTarget: currentBlock.
	self CmpCq: 1 R: Extra0Reg.
	jump3 := self JumpZero: 0.
	self ArithmeticShiftRightCq: 3 R: ClassReg.
	self MoveM64: 0 r: Extra3Reg R: Extra0Reg.
	self MoveR: Extra0Reg R: SendNumArgsReg.
	self ArithmeticShiftRightCq: 24 R: SendNumArgsReg.
	self AndCq: 31 R: SendNumArgsReg.
	self MoveMb: 7 r: Extra3Reg R: Extra1Reg.
	self AndCq: 255 R: Extra1Reg.
	self CmpCq: 255 R: Extra1Reg.
	jump2 := self JumpNonZero: 0.
	self MoveM64: -8 r: Extra3Reg R: Extra1Reg.
	self LogicalShiftLeftCq: 8 R: Extra1Reg.
	self ArithmeticShiftRightCq: 8 R: Extra1Reg.
	jump4 := self Jump: 0.
	currentBlock := self Label.
	jump2 jmpTarget: currentBlock.
	currentBlock := self Label.
	jump4 jmpTarget: currentBlock.
	self CmpCq: 5 R: SendNumArgsReg.
	jump4 := self JumpAbove: 0.
	jump2 := self Jump: 0.
	currentBlock := self Label.
	jump4 jmpTarget: currentBlock.
	self CmpCq: 16 R: SendNumArgsReg.
	jump4 := self JumpBelow: 0.
	self LogicalShiftLeftCq: 3 R: Extra1Reg.
	self MoveR: SendNumArgsReg R: Extra2Reg.
	self AndCq: 7 R: Extra2Reg.
	self SubR: Extra2Reg R: Extra1Reg.
	self MoveR: SendNumArgsReg R: Extra2Reg.
	self CmpCq: 9 R: Extra2Reg.
	jumpTrue := self JumpAboveOrEqual: 0.
	self MoveCq: 0 R: Extra2Reg.
	jumpNext := self Jump: 0.
	jumpTrue jmpTarget: self Label.
	self MoveCq: 1 R: Extra2Reg.
	jumpNext jmpTarget: self Label.
	jump5 := self Jump: 0.
	currentBlock := self Label.
	jump4 jmpTarget: currentBlock.
	self CmpCq: 12 R: SendNumArgsReg.
	jump4 := self JumpBelow: 0.
	self LogicalShiftLeftCq: 2 R: Extra1Reg.
	self MoveR: SendNumArgsReg R: Extra2Reg.
	self AndCq: 3 R: Extra2Reg.
	self SubR: Extra2Reg R: Extra1Reg.
	self MoveR: Extra1Reg R: Extra2Reg.
	self MoveR: SendNumArgsReg R: Extra1Reg.
	self CmpCq: 9 R: Extra1Reg.
	jumpTrue := self JumpAboveOrEqual: 0.
	self MoveCq: 0 R: Extra1Reg.
	jumpNext := self Jump: 0.
	jumpTrue jmpTarget: self Label.
	self MoveCq: 1 R: Extra1Reg.
	jumpNext jmpTarget: self Label.
	self MoveR: Extra1Reg R: TempReg.
	jump6 := self Jump: 0.
	currentBlock := self Label.
	jump4 jmpTarget: currentBlock.
	self CmpCq: 10 R: SendNumArgsReg.
	jump4 := self JumpBelow: 0.
	self LogicalShiftLeftCq: 1 R: Extra1Reg.
	self MoveR: SendNumArgsReg R: TempReg.
	self AndCq: 1 R: TempReg.
	self SubR: TempReg R: Extra1Reg.
	self MoveR: Extra1Reg R: TempReg.
	jump7 := self Jump: 0.
	currentBlock := self Label.
	jump4 jmpTarget: currentBlock.
	self CmpCq: 9 R: SendNumArgsReg.
	jump4 := self JumpNonZero: 0.
	self MoveR: Extra1Reg R: TempReg.
	jump8 := self Jump: 0.
	currentBlock := self Label.
	jump4 jmpTarget: currentBlock.
	self MoveCq: 0 R: TempReg.
	currentBlock := self Label.
	jump7 jmpTarget: currentBlock.
	jump8 jmpTarget: currentBlock.
	self MoveR: SendNumArgsReg R: Extra1Reg.
	self CmpCq: 9 R: Extra1Reg.
	jumpTrue := self JumpAboveOrEqual: 0.
	self MoveCq: 0 R: Extra1Reg.
	jumpNext := self Jump: 0.
	jumpTrue jmpTarget: self Label.
	self MoveCq: 1 R: Extra1Reg.
	jumpNext jmpTarget: self Label.
	self CmpCq: 9 R: SendNumArgsReg.
	jump8 := self JumpBelow: 0.
	self MoveR: TempReg R: Extra2Reg.
	self MoveR: Extra1Reg R: TempReg.
	currentBlock := self Label.
	jump6 jmpTarget: currentBlock.
	self MoveR: Extra2Reg R: Extra1Reg.
	self MoveR: TempReg R: Extra2Reg.
	currentBlock := self Label.
	jump5 jmpTarget: currentBlock.
	self MoveR: Extra2Reg R: TempReg.
	jump5 := self Jump: 0.
	currentBlock := self Label.
	jump8 jmpTarget: currentBlock.
	self MoveR: TempReg R: Extra1Reg.
	currentBlock := self Label.
	jump2 jmpTarget: currentBlock.
	self MoveR: SendNumArgsReg R: TempReg.
	self CmpCq: 2 R: TempReg.
	jumpTrue := self JumpZero: 0.
	self MoveCq: 0 R: TempReg.
	jumpNext := self Jump: 0.
	jumpTrue jmpTarget: self Label.
	self MoveCq: 1 R: TempReg.
	jumpNext jmpTarget: self Label.
	currentBlock := self Label.
	jump5 jmpTarget: currentBlock.
	self CmpCq: 1 R: TempReg.
	jump5 := self JumpNonZero: 0.
	self MoveCq: 0 R: TempReg.
	jump2 := self Jump: 0.
	currentBlock := self Label.
	jump5 jmpTarget: currentBlock.
	self CmpCq: 2 R: SendNumArgsReg.
	jump5 := self JumpAboveOrEqual: 0.
	self MoveR: Extra1Reg R: TempReg.
	jump8 := self Jump: 0.
	currentBlock := self Label.
	jump5 jmpTarget: currentBlock.
	self MoveM64: 0 r: Extra3Reg R: TempReg.
	self AndCq: 16r3FFFFF R: TempReg.
	self CmpCq: 31 R: TempReg.
	jump5 := self JumpAbove: 0.
	self CmpCq: 31 R: TempReg.
	jump6 := self JumpNonZero: 0.
	self MoveMw: 8 r: SPReg R: Extra3Reg.
	self MoveR: Extra3Reg R: TempReg.
	jump7 := self Jump: 0.
	currentBlock := self Label.
	jump6 jmpTarget: currentBlock.
	self CmpCq: 8 R: TempReg.
	jump6 := self JumpNonZero: 0.
	self MoveCq: objectMemory nilObject R: TempReg.
	jump4 := self Jump: 0.
	currentBlock := self Label.
	jump5 jmpTarget: currentBlock.
	jump6 jmpTarget: currentBlock.
	self MoveR: TempReg R: Extra2Reg.
	self ArithmeticShiftRightCq: 10 R: Extra2Reg.
	self LogicalShiftLeftCq: 3 R: Extra2Reg.
	self MoveM64: objectMemory nilObject + 8 r: Extra2Reg R: Extra2Reg.
	self CmpCq: objectMemory nilObject R: Extra2Reg.
	jump6 := self JumpNonZero: 0.
	self MoveCq: objectMemory nilObject R: Extra2Reg.
	jump5 := self Jump: 0.
	currentBlock := self Label.
	jump6 jmpTarget: currentBlock.
	self AndCq: 1023 R: TempReg.
	self LogicalShiftLeftCq: 3 R: TempReg.
	self AddR: TempReg R: Extra2Reg.
	self MoveM64: 8 r: Extra2Reg R: Extra2Reg.
	currentBlock := self Label.
	jump5 jmpTarget: currentBlock.
	self MoveR: Extra2Reg R: TempReg.
	currentBlock := self Label.
	jump7 jmpTarget: currentBlock.
	jump4 jmpTarget: currentBlock.
	self MoveM64: 24 r: TempReg R: Extra2Reg.
	self ArithmeticShiftRightCq: 3 R: Extra2Reg.
	self AndCq: 16rFFFF R: Extra2Reg.
	self MoveR: Extra2Reg R: TempReg.
	currentBlock := self Label.
	jump2 jmpTarget: currentBlock.
	jump8 jmpTarget: currentBlock.
	self CmpCq: 3 R: SendNumArgsReg.
	jump8 := self JumpNonZero: 0.
	self AndCq: 16r3FFFFF R: Extra0Reg.
	self CmpCq: 36 R: Extra0Reg.
	jumpTrue := self JumpZero: 0.
	self MoveCq: 0 R: Extra0Reg.
	jumpNext := self Jump: 0.
	jumpTrue jmpTarget: self Label.
	self MoveCq: 1 R: Extra0Reg.
	jumpNext jmpTarget: self Label.
	self MoveR: Extra0Reg R: Extra2Reg.
	jump2 := self Jump: 0.
	currentBlock := self Label.
	jump8 jmpTarget: currentBlock.
	self MoveCq: 0 R: Extra2Reg.
	currentBlock := self Label.
	jump2 jmpTarget: currentBlock.
	self CmpCq: 1 R: Extra2Reg.
	jump2 := self JumpZero: 0.
	self SubR: TempReg R: Extra1Reg.
	self CmpCq: 24 R: SendNumArgsReg.
	jump8 := self JumpAboveOrEqual: 0.
	self CmpCq: 1 R: ClassReg.
	jump4 := self JumpLess: 0.
	self MoveR: ClassReg R: Extra2Reg.
	self CmpR: Extra1Reg R: Extra2Reg.
	jumpTrue := self JumpLessOrEqual: 0.
	self MoveCq: 0 R: Extra2Reg.
	jumpNext := self Jump: 0.
	jumpTrue jmpTarget: self Label.
	self MoveCq: 1 R: Extra2Reg.
	jumpNext jmpTarget: self Label.
	jump7 := self Jump: 0.
	currentBlock := self Label.
	jump4 jmpTarget: currentBlock.
	self MoveCq: 0 R: Extra2Reg.
	currentBlock := self Label.
	jump7 jmpTarget: currentBlock.
	self CmpCq: 1 R: Extra2Reg.
	jump7 := self JumpNonZero: 0.
	self AddR: TempReg R: ClassReg.
	self CmpCq: 5 R: SendNumArgsReg.
	jump4 := self JumpAbove: 0.
	self SubCq: 1 R: ClassReg.
	self LogicalShiftLeftCq: 3 R: ClassReg.
	self MoveMw: 8 r: SPReg R: Extra3Reg.
	self AddR: ClassReg R: Extra3Reg.
	self MoveR: Extra3Reg Mw: 8 r: SPReg.
	self MoveM64: 8 r: Extra3Reg R: Extra2Reg.
	self MoveR: Extra2Reg R: ReceiverResultReg.
	jump5 := self Jump: 0.
	currentBlock := self Label.
	jump4 jmpTarget: currentBlock.
	self CmpCq: 16 R: SendNumArgsReg.
	jump4 := self JumpBelow: 0.
	self MoveMw: 8 r: SPReg R: Extra3Reg.
	self AddR: Extra3Reg R: ClassReg.
	self AddCq:  -1 R: ClassReg.
	self MoveMb: 8 r: ClassReg R: Extra2Reg.
	self AndCq: 255 R: Extra2Reg.
	self LogicalShiftLeftCq: 3 R: Extra2Reg.
	self AddCq: 1 R: Extra2Reg.
	self MoveR: Extra2Reg R: ReceiverResultReg.
	jump6 := self Jump: 0.
	currentBlock := self Label.
	jump4 jmpTarget: currentBlock.
	self CmpCq: 12 R: SendNumArgsReg.
	jump4 := self JumpBelow: 0.
	self SubCq: 1 R: ClassReg.
	self LogicalShiftLeftCq: 1 R: ClassReg.
	self MoveMw: 8 r: SPReg R: Extra3Reg.
	self AddR: ClassReg R: Extra3Reg.
	self MoveR: Extra3Reg Mw: 8 r: SPReg.
	self MoveM16: 8 r: Extra3Reg R: Extra2Reg.
	self AndCq: 16rFFFF R: Extra2Reg.
	self LogicalShiftLeftCq: 3 R: Extra2Reg.
	self AddCq: 1 R: Extra2Reg.
	self MoveR: Extra2Reg R: ReceiverResultReg.
	jump9 := self Jump: 0.
	currentBlock := self Label.
	jump4 jmpTarget: currentBlock.
	self CmpCq: 9 R: SendNumArgsReg.
	jump4 := self JumpZero: 0.
	self MoveCq: 0 R: ReceiverResultReg.
	currentBlock := self Label.
	jump5 jmpTarget: currentBlock.
	jump6 jmpTarget: currentBlock.
	jump9 jmpTarget: currentBlock.
	self SubCq: 8 R: SPReg.
	self genPrimReturn.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	jump3 jmpTarget: currentBlock.
	jump2 jmpTarget: currentBlock.
	jump8 jmpTarget: currentBlock.
	jump7 jmpTarget: currentBlock.
	jump4 jmpTarget: currentBlock.
	self SubCq: 8 R: SPReg.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveBitShift [
	"AutoGenerated by Druid"

	| jump1 jump2 currentBlock |
	self MoveR: ReceiverResultReg R: TempReg.
	self MoveR: Arg0Reg R: ClassReg.
	self CmpCq: 0 R: ClassReg.
	jump1 := self JumpLessOrEqual: 0.
	self LogicalShiftLeftR: ClassReg R: TempReg.
	self MoveR: TempReg R: ReceiverResultReg.
	jump2 := self Jump: 0.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	self MoveR: ClassReg R: ClassReg.
	self NegateR: ClassReg.
	self ArithmeticShiftRightR: ClassReg R: TempReg.
	self MoveR: TempReg R: ReceiverResultReg.
	currentBlock := self Label.
	jump2 jmpTarget: currentBlock.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveBitXor [
	"AutoGenerated by Druid"

	| currentBlock |
	self MoveR: ReceiverResultReg R: TempReg.
	self MoveR: Arg0Reg R: ClassReg.
	self XorR: TempReg R: ClassReg.
	self MoveR: ClassReg R: ReceiverResultReg.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveBranchingWithAssigments [
	"AutoGenerated by Druid"

	| jump1 jump2 currentBlock |
	self MoveR: ReceiverResultReg R: TempReg.
	self CmpCq: 0 R: TempReg.
	jump1 := self JumpLessOrEqual: 0.
	self MoveCq: 17 R: ReceiverResultReg.
	jump2 := self Jump: 0.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	self MoveCq: 42 R: ReceiverResultReg.
	currentBlock := self Label.
	jump2 jmpTarget: currentBlock.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveByteAt [

	| currentBlock |
	self MoveCq: 0 R: TempReg.
	self MoveMb: 0 r: ReceiverResultReg R: TempReg.
	self MoveR: TempReg R: ReceiverResultReg.
	self RetN: 1 * objectMemory wordSize.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveCallingBlockReadingExternalTemp [
	"AutoGenerated by Druid"

	| currentBlock |
	self MoveCq: 17 R: ReceiverResultReg.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveCallingBlockReturningArgument [
	"AutoGenerated by Druid"

	| currentBlock |
	self MoveCq: 17 R: ReceiverResultReg.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveCallingBlockReturningConstant [
	"AutoGenerated by Druid"

	| currentBlock |
	self MoveCq: 17 R: ReceiverResultReg.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveCallingBlockWithNonLocalReturn [
	"AutoGenerated by Druid"

	| currentBlock |
	self MoveCq: 17 R: ReceiverResultReg.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveCallingBlockWritingExternalTemp [
	"AutoGenerated by Druid"

	| currentBlock |
	self MoveCq: 17 R: ReceiverResultReg.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveCallingEmptyBlock [
	"AutoGenerated by Druid"

	| currentBlock |
	self MoveCq: 18 R: ReceiverResultReg.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveCallingMethodReturningConstant [
	"AutoGenerated by Druid"

	| currentBlock |
	self MoveCq: 73 R: ReceiverResultReg.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveCallingMethodWithEarlyReturn [
	"AutoGenerated by Druid"

	| jump1 jump2 currentBlock |
	self MoveR: ReceiverResultReg R: TempReg.
	self CmpCq: 0 R: TempReg.
	jump1 := self JumpNonZero: 0.
	self MoveCq: 42 R: ReceiverResultReg.
	jump2 := self Jump: 0.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	self MoveCq: 57 R: ReceiverResultReg.
	currentBlock := self Label.
	jump2 jmpTarget: currentBlock.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveCascadedUint16AtPut [
	"AutoGenerated by Druid"

	| currentBlock |
	self MoveR: ReceiverResultReg R: TempReg.
	self MoveCq: 1 R: ClassReg.
	self MoveR: ClassReg M16: 0 r: TempReg.
	self MoveCq: 2 R: ClassReg.
	self MoveR: ClassReg M16: 2 r: TempReg.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveCaseOfOtherwiseValue [
	"AutoGenerated by Druid"

	| jump1 jump2 jump3 currentBlock |
	self MoveR: ReceiverResultReg R: TempReg.
	self CmpCq: 0 R: TempReg.
	jump1 := self JumpNonZero: 0.
	self MoveCq: 57 R: ReceiverResultReg.
	jump2 := self Jump: 0.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	self CmpCq: 1 R: TempReg.
	jump1 := self JumpNonZero: 0.
	self MoveCq: 42 R: ReceiverResultReg.
	jump3 := self Jump: 0.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	self MoveCq: 77 R: ReceiverResultReg.
	currentBlock := self Label.
	jump2 jmpTarget: currentBlock.
	jump3 jmpTarget: currentBlock.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveClassVariable [
	"AutoGenerated by Druid"

	| currentBlock |
	self MoveCq: 34 R: ReceiverResultReg.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveClassVariableWithBranch [
	"AutoGenerated by Druid"

	| jump1 jump2 currentBlock |
	self MoveR: ReceiverResultReg R: TempReg.
	self CmpCq: 0 R: TempReg.
	jump1 := self JumpNonZero: 0.
	self MoveCq: 35 R: ReceiverResultReg.
	jump2 := self Jump: 0.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	self MoveCq: 36 R: ReceiverResultReg.
	currentBlock := self Label.
	jump2 jmpTarget: currentBlock.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveConditionWithAnyMask [
	"AutoGenerated by Druid"

	| jump1 jump2 currentBlock |
	self MoveR: ReceiverResultReg R: TempReg.
	self TstCq: 1 R: TempReg.
	jump1 := self JumpZero: 0.
	self MoveCq: 1 R: ReceiverResultReg.
	jump2 := self Jump: 0.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	self MoveCq: 2 R: ReceiverResultReg.
	currentBlock := self Label.
	jump2 jmpTarget: currentBlock.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveConditionWithAnyMaskInverted [
	"AutoGenerated by Druid"

	| jump1 jump2 currentBlock |
	self MoveR: ReceiverResultReg R: TempReg.
	self TstCq: 1 R: TempReg.
	jump1 := self JumpZero: 0.
	self MoveCq: 1 R: ReceiverResultReg.
	jump2 := self Jump: 0.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	self MoveCq: 2 R: ReceiverResultReg.
	currentBlock := self Label.
	jump2 jmpTarget: currentBlock.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveConditionWithObjectReference [
	"AutoGenerated by Druid"

	| jump1 jump2 currentBlock |
	self MoveR: ReceiverResultReg R: TempReg.
	self MoveCq: objectMemory trueObject R: ClassReg.
	self CmpR: TempReg R: ClassReg.
	jump1 := self JumpLessOrEqual: 0.
	self MoveCq: 1 R: ReceiverResultReg.
	jump2 := self Jump: 0.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	self MoveCq: 2 R: ReceiverResultReg.
	currentBlock := self Label.
	jump2 jmpTarget: currentBlock.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveDNA [
	"AutoGenerated by Druid"

	| jump1 jump2 jump3 currentBlock |
	self MoveR: ReceiverResultReg R: TempReg.
	self CmpCq: 10 R: TempReg.
	jump1 := self JumpLessOrEqual: 0.
	self MoveCq: 1 R: TempReg.
	self MoveCq: 5 R: ClassReg.
	jump2 := self Jump: 0.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	self MoveCq: 99 R: ClassReg.
	self CmpCq: 0 R: TempReg.
	jump1 := self JumpLessOrEqual: 0.
	self MoveCq: 5 R: SendNumArgsReg.
	self CmpCq: 7 R: TempReg.
	jump3 := self JumpLessOrEqual: 0.
	self MoveR: ClassReg R: TempReg.
	self MoveR: SendNumArgsReg R: ClassReg.
	currentBlock := self Label.
	jump2 jmpTarget: currentBlock.
	self AddCq: 20 R: TempReg.
	self MoveR: TempReg R: ReceiverResultReg.
	jump2 := self Jump: 0.
	currentBlock := self Label.
	jump3 jmpTarget: currentBlock.
	jump3 := self Jump: 0.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	self MoveCq: 99 R: SendNumArgsReg.
	self MoveCq: 17 R: TempReg.
	self MoveR: SendNumArgsReg R: ClassReg.
	self MoveR: TempReg R: SendNumArgsReg.
	currentBlock := self Label.
	jump3 jmpTarget: currentBlock.
	self AddR: SendNumArgsReg R: ClassReg.
	self AddCq: 42 R: ClassReg.
	self MoveR: ClassReg R: ReceiverResultReg.
	currentBlock := self Label.
	jump2 jmpTarget: currentBlock.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveDeadBranchWithError [
	"AutoGenerated by Druid"

	| currentBlock |
	self MoveCq: 17 R: ReceiverResultReg.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveDecrement [

	| currentBlock |
	self MoveR: ReceiverResultReg R: TempReg.
	self SubCq: 1 R: TempReg.
	self MoveR: TempReg R: ReceiverResultReg.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveDecrementConstantArgument [
	"AutoGenerated by Druid"

	| currentBlock |
	self MoveR: ReceiverResultReg R: TempReg.
	self SubCq: 1 R: TempReg.
	self MoveR: TempReg R: ReceiverResultReg.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveDecrementConstantReceiver [
	"AutoGenerated by Druid"

	| currentBlock |
	self MoveR: ReceiverResultReg R: TempReg.
	self MoveCq: 42 R: ClassReg.
	self SubR: TempReg R: ClassReg.
	self MoveR: ClassReg R: ReceiverResultReg.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveDivide [
	"AutoGenerated by Druid"

	| currentBlock |
	self MoveR: ReceiverResultReg R: TempReg.
	self MoveR: Arg0Reg R: ClassReg.
	self
		DivR: ClassReg
		R: TempReg
		Quo: ClassReg
		Rem: TempReg.
	self MoveR: ClassReg R: ReceiverResultReg.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveDivideByConstant [
	"AutoGenerated by Druid"

	| currentBlock |
	self MoveR: ReceiverResultReg R: TempReg.
	self MoveCq: 2 R: ClassReg.
	self
		DivR: ClassReg
		R: TempReg
		Quo: ClassReg
		Rem: TempReg.
	self MoveR: ClassReg R: ReceiverResultReg.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveDoubleDeferredInline [
	"AutoGenerated by Druid"

	| jump1 currentBlock |
	self MoveR: ReceiverResultReg R: TempReg.
	self MoveCq: 0 R: ClassReg.
	self MoveR: ClassReg Aw: coInterpreter primitiveFailureCodeAddress.
	self MoveAw: coInterpreter primitiveFailureCodeAddress R: ClassReg.
	self MoveR: Arg0Reg R: SendNumArgsReg.
	self MoveCq: 2 R: SendNumArgsReg.
	self MulR: TempReg R: SendNumArgsReg.
	self MoveR: ClassReg Aw: coInterpreter primitiveFailureCodeAddress.
	self MoveAw: coInterpreter primitiveFailureCodeAddress R: ClassReg.
	self MoveR: SendNumArgsReg R: ReceiverResultReg.
	self CmpCq: 0 R: ClassReg.
	jump1 := self JumpNonZero: 0.
	self genPrimReturn.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveEqualsThan [
	"AutoGenerated by Druid"

	| jump1 jump2 currentBlock |
	self MoveR: ReceiverResultReg R: TempReg.
	self CmpCq: 10 R: TempReg.
	jump1 := self JumpNonZero: 0.
	self MoveCq: 5 R: ReceiverResultReg.
	jump2 := self Jump: 0.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	self MoveCq: 11 R: ReceiverResultReg.
	currentBlock := self Label.
	jump2 jmpTarget: currentBlock.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveEqualsThanFloats [
	"AutoGenerated by Druid"

	| jumpNext currentBlock jumpTrue |
	self MoveR: ReceiverResultReg R: TempReg.
	self MoveR: Arg0Reg R: ClassReg.
	self ConvertR: ClassReg Rd: DPFPReg0.
	self ConvertR: TempReg Rd: DPFPReg1.
	self CmpRd: DPFPReg1 Rd: DPFPReg0.
	jumpTrue := self JumpFPEqual: 0.
	self MoveCq: 0 R: TempReg.
	jumpNext := self Jump: 0.
	jumpTrue jmpTarget: self Label.
	self MoveCq: 1 R: TempReg.
	jumpNext jmpTarget: self Label.
	self MoveR: TempReg R: ReceiverResultReg.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveEqualsThanInverted [
	"AutoGenerated by Druid"

	| jump1 jump2 currentBlock |
	self MoveR: ReceiverResultReg R: TempReg.
	self CmpCq: 10 R: TempReg.
	jump1 := self JumpNonZero: 0.
	self MoveCq: 5 R: ReceiverResultReg.
	jump2 := self Jump: 0.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	self MoveCq: 11 R: ReceiverResultReg.
	currentBlock := self Label.
	jump2 jmpTarget: currentBlock.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveEqualsThanReferenceValue [

	| jumpNext currentBlock jumpTrue |
	self MoveR: ReceiverResultReg R: TempReg.
	self CmpCw: objectMemory trueObject R: TempReg.
	jumpTrue := self JumpZero: 0.
	self MoveCq: 0 R: TempReg.
	jumpNext := self Jump: 0.
	jumpTrue jmpTarget: self Label.
	self MoveCq: 1 R: TempReg.
	jumpNext jmpTarget: self Label.
	self MoveR: TempReg R: ReceiverResultReg.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveEqualsThanValue [
	"AutoGenerated by Druid"

	| jumpNext currentBlock jumpTrue |
	self MoveR: ReceiverResultReg R: TempReg.
	self CmpCq: 0 R: TempReg.
	jumpTrue := self JumpZero: 0.
	self MoveCq: 0 R: TempReg.
	jumpNext := self Jump: 0.
	jumpTrue jmpTarget: self Label.
	self MoveCq: 1 R: TempReg.
	jumpNext jmpTarget: self Label.
	self MoveR: TempReg R: ReceiverResultReg.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveFalseAsInteger [
	"AutoGenerated by Druid"

	| currentBlock |
	self MoveCq: 0 R: ReceiverResultReg.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveFalseAssignmentAsInteger [
	"AutoGenerated by Druid"

	| currentBlock |
	self MoveCq: 0 R: ReceiverResultReg.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveFalseNot [
	"AutoGenerated by Druid"

	| currentBlock |
	self MoveCq: 1 R: ReceiverResultReg.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveFloat64At [
	"AutoGenerated by Druid"

	| currentBlock |
	self MoveR: ReceiverResultReg R: TempReg.
	self MoveM64: 0 r: TempReg Rd: DPFPReg0.
	self MoveRd: DPFPReg0 R: TempReg.
	self MoveR: TempReg R: ReceiverResultReg.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveFloat64AtPut [
	"AutoGenerated by Druid"

	| currentBlock |
	self MoveR: ReceiverResultReg R: TempReg.
	self MoveR: Arg0Reg R: ClassReg.
	self ConvertR: ClassReg Rd: DPFPReg0.
	self MoveRd: DPFPReg0 M64: 0 r: TempReg.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveFloatAdd [
	"AutoGenerated by Druid"

	| currentBlock |
	self MoveR: ReceiverResultReg R: TempReg.
	self MoveR: Arg0Reg R: ClassReg.
	self ConvertR: ClassReg Rd: DPFPReg0.
	self ConvertR: TempReg Rd: DPFPReg1.
	self AddRd: DPFPReg1 Rd: DPFPReg0.
	self MoveRd: DPFPReg0 R: TempReg.
	self MoveR: TempReg R: ReceiverResultReg.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveFloatDivide [
	"AutoGenerated by Druid"

	| currentBlock |
	self MoveR: ReceiverResultReg R: TempReg.
	self MoveR: Arg0Reg R: ClassReg.
	self ConvertR: ClassReg Rd: DPFPReg0.
	self ConvertR: TempReg Rd: DPFPReg1.
	self DivRd: DPFPReg1 Rd: DPFPReg0.
	self MoveRd: DPFPReg0 R: TempReg.
	self MoveR: TempReg R: ReceiverResultReg.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveFloatMultiply [
	"AutoGenerated by Druid"

	| currentBlock |
	self MoveR: ReceiverResultReg R: TempReg.
	self MoveR: Arg0Reg R: ClassReg.
	self ConvertR: ClassReg Rd: DPFPReg0.
	self ConvertR: TempReg Rd: DPFPReg1.
	self MulRd: DPFPReg0 Rd: DPFPReg1.
	self MoveRd: DPFPReg1 R: TempReg.
	self MoveR: TempReg R: ReceiverResultReg.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveFloatSubtract [
	"AutoGenerated by Druid"

	| currentBlock |
	self MoveR: ReceiverResultReg R: TempReg.
	self MoveR: Arg0Reg R: ClassReg.
	self ConvertR: ClassReg Rd: DPFPReg0.
	self ConvertR: TempReg Rd: DPFPReg1.
	self SubRd: DPFPReg1 Rd: DPFPReg0.
	self MoveRd: DPFPReg0 R: TempReg.
	self MoveR: TempReg R: ReceiverResultReg.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveFullClosureValue [
	"AutoGenerated by Druid"

	| jump3 jump1 currentBlock jump4 jump2 |
	self MoveR: ReceiverResultReg R: TempReg.
	self MoveM64: 24 r: TempReg R: ClassReg.
	self ArithmeticShiftRightCq: 3 R: ClassReg.
	self CmpCq: 0 R: ClassReg.
	jump1 := self JumpNonZero: 0.
	self MoveM64: 16 r: TempReg R: ClassReg.
	self MoveR: ClassReg R: TempReg.
	self AndCq: 7 R: TempReg.
	self CmpCq: 0 R: TempReg.
	jump2 := self JumpNonZero: 0.
	self MoveM64: 0 r: ClassReg R: TempReg.
	self ArithmeticShiftRightCq: 24 R: TempReg.
	self AndCq: 31 R: TempReg.
	self CmpCq: 24 R: TempReg.
	jump3 := self JumpBelow: 0.
	self MoveM64: 8 r: ClassReg R: TempReg.
	self AndCq: 1 R: TempReg.
	self CmpCq: 0 R: TempReg.
	jump4 := self JumpNonZero: 0.
	self MoveM64: 8 r: ClassReg R: TempReg.
	self AddCq: self fullBlockEntryOffset R: TempReg.
	self JumpR: TempReg.
	self genPrimReturn.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	jump2 jmpTarget: currentBlock.
	jump3 jmpTarget: currentBlock.
	jump4 jmpTarget: currentBlock.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveGreaterOrEqualThanArgument [
	"AutoGenerated by Druid"

	| jumpNext currentBlock jumpTrue |
	self MoveR: Arg0Reg R: TempReg.
	self CmpCq: 0 R: TempReg.
	jumpTrue := self JumpGreaterOrEqual: 0.
	self MoveCq: 0 R: TempReg.
	jumpNext := self Jump: 0.
	jumpTrue jmpTarget: self Label.
	self MoveCq: 1 R: TempReg.
	jumpNext jmpTarget: self Label.
	self MoveR: TempReg R: ReceiverResultReg.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveGreaterOrEqualThanValue [
	"AutoGenerated by Druid"

	| jumpNext currentBlock jumpTrue |
	self MoveR: ReceiverResultReg R: TempReg.
	self CmpCq: 0 R: TempReg.
	jumpTrue := self JumpGreaterOrEqual: 0.
	self MoveCq: 0 R: TempReg.
	jumpNext := self Jump: 0.
	jumpTrue jmpTarget: self Label.
	self MoveCq: 1 R: TempReg.
	jumpNext jmpTarget: self Label.
	self MoveR: TempReg R: ReceiverResultReg.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveGreaterOrEqualsThan [
	"AutoGenerated by Druid"

	| jump1 jump2 currentBlock |
	self MoveR: ReceiverResultReg R: TempReg.
	self CmpCq: 10 R: TempReg.
	jump1 := self JumpLess: 0.
	self MoveCq: 5 R: ReceiverResultReg.
	jump2 := self Jump: 0.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	self MoveCq: 11 R: ReceiverResultReg.
	currentBlock := self Label.
	jump2 jmpTarget: currentBlock.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveGreaterOrEqualsThanFloats [
	"AutoGenerated by Druid"

	| jumpNext currentBlock jumpTrue |
	self MoveR: ReceiverResultReg R: TempReg.
	self MoveR: Arg0Reg R: ClassReg.
	self ConvertR: ClassReg Rd: DPFPReg0.
	self ConvertR: TempReg Rd: DPFPReg1.
	self CmpRd: DPFPReg1 Rd: DPFPReg0.
	jumpTrue := self JumpFPGreaterOrEqual: 0.
	self MoveCq: 0 R: TempReg.
	jumpNext := self Jump: 0.
	jumpTrue jmpTarget: self Label.
	self MoveCq: 1 R: TempReg.
	jumpNext jmpTarget: self Label.
	self MoveR: TempReg R: ReceiverResultReg.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveGreaterOrEqualsThanInverted [
	"AutoGenerated by Druid"

	| jump1 jump2 currentBlock |
	self MoveR: ReceiverResultReg R: TempReg.
	self MoveCq: 10 R: ClassReg.
	self CmpR: TempReg R: ClassReg.
	jump1 := self JumpLess: 0.
	self MoveCq: 5 R: ReceiverResultReg.
	jump2 := self Jump: 0.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	self MoveCq: 11 R: ReceiverResultReg.
	currentBlock := self Label.
	jump2 jmpTarget: currentBlock.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveGreaterThan [
	"AutoGenerated by Druid"

	| jump1 jump2 currentBlock |
	self MoveR: ReceiverResultReg R: TempReg.
	self CmpCq: 10 R: TempReg.
	jump1 := self JumpLessOrEqual: 0.
	self MoveCq: 5 R: ReceiverResultReg.
	jump2 := self Jump: 0.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	self MoveCq: 11 R: ReceiverResultReg.
	currentBlock := self Label.
	jump2 jmpTarget: currentBlock.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveGreaterThanArgument [
	"AutoGenerated by Druid"

	| jumpNext currentBlock jumpTrue |
	self MoveR: Arg0Reg R: TempReg.
	self CmpCq: 0 R: TempReg.
	jumpTrue := self JumpGreater: 0.
	self MoveCq: 0 R: TempReg.
	jumpNext := self Jump: 0.
	jumpTrue jmpTarget: self Label.
	self MoveCq: 1 R: TempReg.
	jumpNext jmpTarget: self Label.
	self MoveR: TempReg R: ReceiverResultReg.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveGreaterThanFloats [
	"AutoGenerated by Druid"

	| jumpNext currentBlock jumpTrue |
	self MoveR: ReceiverResultReg R: TempReg.
	self MoveR: Arg0Reg R: ClassReg.
	self ConvertR: ClassReg Rd: DPFPReg0.
	self ConvertR: TempReg Rd: DPFPReg1.
	self CmpRd: DPFPReg1 Rd: DPFPReg0.
	jumpTrue := self JumpFPGreater: 0.
	self MoveCq: 0 R: TempReg.
	jumpNext := self Jump: 0.
	jumpTrue jmpTarget: self Label.
	self MoveCq: 1 R: TempReg.
	jumpNext jmpTarget: self Label.
	self MoveR: TempReg R: ReceiverResultReg.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveGreaterThanInverted [
	"AutoGenerated by Druid"

	| jump1 jump2 currentBlock |
	self MoveR: ReceiverResultReg R: TempReg.
	self MoveCq: 10 R: ClassReg.
	self CmpR: TempReg R: ClassReg.
	jump1 := self JumpLessOrEqual: 0.
	self MoveCq: 5 R: ReceiverResultReg.
	jump2 := self Jump: 0.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	self MoveCq: 11 R: ReceiverResultReg.
	currentBlock := self Label.
	jump2 jmpTarget: currentBlock.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveGreaterThanReferenceValue [
	"AutoGenerated by Druid"

	| jumpNext currentBlock jumpTrue |
	self MoveR: ReceiverResultReg R: TempReg.
	self CmpCq: objectMemory trueObject R: TempReg.
	jumpTrue := self JumpAbove: 0.
	self MoveCq: 0 R: TempReg.
	jumpNext := self Jump: 0.
	jumpTrue jmpTarget: self Label.
	self MoveCq: 1 R: TempReg.
	jumpNext jmpTarget: self Label.
	self MoveR: TempReg R: ReceiverResultReg.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveIfFalseIfTrueReturningValue [
	"AutoGenerated by Druid"

	| jump1 jump2 currentBlock |
	self MoveR: ReceiverResultReg R: TempReg.
	self CmpCq: 0 R: TempReg.
	jump1 := self JumpNonZero: 0.
	self MoveCq: 42 R: ReceiverResultReg.
	jump2 := self Jump: 0.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	self MoveCq: 57 R: ReceiverResultReg.
	currentBlock := self Label.
	jump2 jmpTarget: currentBlock.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveIfTrueIfFalseAssigningValue [
	"AutoGenerated by Druid"

	| jump1 jump2 currentBlock |
	self MoveR: ReceiverResultReg R: TempReg.
	self CmpCq: 0 R: TempReg.
	jump1 := self JumpNonZero: 0.
	self MoveCq: 42 R: ReceiverResultReg.
	jump2 := self Jump: 0.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	self MoveCq: 57 R: ReceiverResultReg.
	currentBlock := self Label.
	jump2 jmpTarget: currentBlock.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveIfTrueIfFalseReturningValue [
	"AutoGenerated by Druid"

	| jump1 jump2 currentBlock |
	self MoveR: ReceiverResultReg R: TempReg.
	self CmpCq: 0 R: TempReg.
	jump1 := self JumpNonZero: 0.
	self MoveCq: 42 R: ReceiverResultReg.
	jump2 := self Jump: 0.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	self MoveCq: 57 R: ReceiverResultReg.
	currentBlock := self Label.
	jump2 jmpTarget: currentBlock.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveIfTrueStatement [
	"AutoGenerated by Druid"

	| jump1 jump2 currentBlock |
	self MoveR: ReceiverResultReg R: TempReg.
	self CmpCq: 0 R: TempReg.
	jump1 := self JumpNonZero: 0.
	self MoveCq: 42 R: ReceiverResultReg.
	jump2 := self Jump: 0.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	self MoveCq: 10 R: ReceiverResultReg.
	currentBlock := self Label.
	jump2 jmpTarget: currentBlock.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveImplicitArgumentBitShiftLeft [
	"AutoGenerated by Druid"

	| jump1 jump2 currentBlock |
	self MoveR: ReceiverResultReg R: TempReg.
	self CmpCq: 0 R: TempReg.
	jump1 := self JumpLessOrEqual: 0.
	self MoveCq: 1 R: ClassReg.
	self LogicalShiftLeftR: TempReg R: ClassReg.
	self MoveR: ClassReg R: ReceiverResultReg.
	jump2 := self Jump: 0.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	self MoveR: TempReg R: ClassReg.
	self NegateR: ClassReg.
	self MoveCq: 1 R: TempReg.
	self ArithmeticShiftRightR: ClassReg R: TempReg.
	self MoveR: TempReg R: ReceiverResultReg.
	currentBlock := self Label.
	jump2 jmpTarget: currentBlock.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveImplicitBitShiftLeft [
	"AutoGenerated by Druid"

	| currentBlock |
	self MoveR: ReceiverResultReg R: TempReg.
	self LogicalShiftLeftCq: 1 R: TempReg.
	self MoveR: TempReg R: ReceiverResultReg.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveImplicitBitShiftRight [
	"AutoGenerated by Druid"

	| currentBlock |
	self MoveR: ReceiverResultReg R: TempReg.
	self ArithmeticShiftRightCq: 1 R: TempReg.
	self MoveR: TempReg R: ReceiverResultReg.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveIncrement [

	| currentBlock |
	self MoveR: ReceiverResultReg R: TempReg.
	self AddCq: 1 R: TempReg.
	self MoveR: TempReg R: ReceiverResultReg.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveIncrementConstantArgument [
	"AutoGenerated by Druid"

	| currentBlock |
	self MoveR: ReceiverResultReg R: TempReg.
	self AddCq: 1 R: TempReg.
	self MoveR: TempReg R: ReceiverResultReg.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveIncrementConstantReceiver [
	"AutoGenerated by Druid"

	| currentBlock |
	self MoveR: ReceiverResultReg R: TempReg.
	self AddCq: 1 R: TempReg.
	self MoveR: TempReg R: ReceiverResultReg.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveIntegerAsFloat [
	"AutoGenerated by Druid"

	| currentBlock |
	self MoveR: ReceiverResultReg R: TempReg.
	self ConvertR: TempReg Rd: DPFPReg0.
	self MoveRd: DPFPReg0 R: TempReg.
	self MoveR: TempReg R: ReceiverResultReg.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveIntegerDivide [
	"AutoGenerated by Druid"

	| currentBlock |
	self MoveR: ReceiverResultReg R: TempReg.
	self MoveR: Arg0Reg R: ClassReg.
	self
		DivR: ClassReg
		R: TempReg
		Quo: TempReg
		Rem: ClassReg.
	self MoveR: TempReg R: ReceiverResultReg.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveIntegerDivideByConstant [
	"AutoGenerated by Druid"

	| currentBlock |
	self MoveR: ReceiverResultReg R: TempReg.
	self MoveCq: 2 R: ClassReg.
	self
		DivR: ClassReg
		R: TempReg
		Quo: ClassReg
		Rem: TempReg.
	self MoveR: ClassReg R: ReceiverResultReg.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveIntegerRawBitsAsFloat [
	"AutoGenerated by Druid"

	| currentBlock |
	self MoveR: ReceiverResultReg R: TempReg.
	self MoveR: TempReg Rd: DPFPReg0.
	self ConvertRd: DPFPReg0 R: TempReg.
	self MoveR: TempReg R: ReceiverResultReg.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveIsIntegerObject [
	"AutoGenerated by Druid"

	| jump1 jump2 currentBlock |
	self MoveR: ReceiverResultReg R: TempReg.
	self TstCq: 1 R: TempReg.
	jump1 := self JumpZero: 0.
	self MoveCq: objectMemory trueObject R: ReceiverResultReg.
	jump2 := self Jump: 0.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	self MoveCq: objectMemory falseObject R: ReceiverResultReg.
	currentBlock := self Label.
	jump2 jmpTarget: currentBlock.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveJITCompileTimeExpression [
	"AutoGenerated by Druid"

	| currentBlock |
	self MoveCq: (objectMemory trueObject + 5) R: ReceiverResultReg.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveLessOrEqualThanArgument [
	"AutoGenerated by Druid"

	| jumpNext currentBlock jumpTrue |
	self MoveR: Arg0Reg R: TempReg.
	self CmpCq: 0 R: TempReg.
	jumpTrue := self JumpLessOrEqual: 0.
	self MoveCq: 0 R: TempReg.
	jumpNext := self Jump: 0.
	jumpTrue jmpTarget: self Label.
	self MoveCq: 1 R: TempReg.
	jumpNext jmpTarget: self Label.
	self MoveR: TempReg R: ReceiverResultReg.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveLessOrEqualThanValue [
	"AutoGenerated by Druid"

	| jumpNext currentBlock jumpTrue |
	self MoveR: ReceiverResultReg R: TempReg.
	self CmpCq: 0 R: TempReg.
	jumpTrue := self JumpLessOrEqual: 0.
	self MoveCq: 0 R: TempReg.
	jumpNext := self Jump: 0.
	jumpTrue jmpTarget: self Label.
	self MoveCq: 1 R: TempReg.
	jumpNext jmpTarget: self Label.
	self MoveR: TempReg R: ReceiverResultReg.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveLessOrEqualsThan [
	"AutoGenerated by Druid"

	| jump1 jump2 currentBlock |
	self MoveR: ReceiverResultReg R: TempReg.
	self CmpCq: 10 R: TempReg.
	jump1 := self JumpGreater: 0.
	self MoveCq: 5 R: ReceiverResultReg.
	jump2 := self Jump: 0.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	self MoveCq: 11 R: ReceiverResultReg.
	currentBlock := self Label.
	jump2 jmpTarget: currentBlock.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveLessOrEqualsThanFloats [
	"AutoGenerated by Druid"

	| jumpNext currentBlock jumpTrue |
	self MoveR: ReceiverResultReg R: TempReg.
	self MoveR: Arg0Reg R: ClassReg.
	self ConvertR: ClassReg Rd: DPFPReg0.
	self ConvertR: TempReg Rd: DPFPReg1.
	self CmpRd: DPFPReg1 Rd: DPFPReg0.
	jumpTrue := self JumpFPLessOrEqual: 0.
	self MoveCq: 0 R: TempReg.
	jumpNext := self Jump: 0.
	jumpTrue jmpTarget: self Label.
	self MoveCq: 1 R: TempReg.
	jumpNext jmpTarget: self Label.
	self MoveR: TempReg R: ReceiverResultReg.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveLessOrEqualsThanInverted [
	"AutoGenerated by Druid"

	| jump1 jump2 currentBlock |
	self MoveR: ReceiverResultReg R: TempReg.
	self MoveCq: 10 R: ClassReg.
	self CmpR: TempReg R: ClassReg.
	jump1 := self JumpGreater: 0.
	self MoveCq: 5 R: ReceiverResultReg.
	jump2 := self Jump: 0.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	self MoveCq: 11 R: ReceiverResultReg.
	currentBlock := self Label.
	jump2 jmpTarget: currentBlock.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveLessThan [
	"AutoGenerated by Druid"

	| jump1 jump2 currentBlock |
	self MoveR: ReceiverResultReg R: TempReg.
	self CmpCq: 10 R: TempReg.
	jump1 := self JumpGreaterOrEqual: 0.
	self MoveCq: 5 R: ReceiverResultReg.
	jump2 := self Jump: 0.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	self MoveCq: 11 R: ReceiverResultReg.
	currentBlock := self Label.
	jump2 jmpTarget: currentBlock.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveLessThanArgument [
	"AutoGenerated by Druid"

	| jumpNext currentBlock jumpTrue |
	self MoveR: Arg0Reg R: TempReg.
	self CmpCq: 0 R: TempReg.
	jumpTrue := self JumpLess: 0.
	self MoveCq: 0 R: TempReg.
	jumpNext := self Jump: 0.
	jumpTrue jmpTarget: self Label.
	self MoveCq: 1 R: TempReg.
	jumpNext jmpTarget: self Label.
	self MoveR: TempReg R: ReceiverResultReg.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveLessThanFloats [
	"AutoGenerated by Druid"

	| jumpNext currentBlock jumpTrue |
	self MoveR: ReceiverResultReg R: TempReg.
	self MoveR: Arg0Reg R: ClassReg.
	self ConvertR: ClassReg Rd: DPFPReg0.
	self ConvertR: TempReg Rd: DPFPReg1.
	self CmpRd: DPFPReg1 Rd: DPFPReg0.
	jumpTrue := self JumpFPLess: 0.
	self MoveCq: 0 R: TempReg.
	jumpNext := self Jump: 0.
	jumpTrue jmpTarget: self Label.
	self MoveCq: 1 R: TempReg.
	jumpNext jmpTarget: self Label.
	self MoveR: TempReg R: ReceiverResultReg.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveLessThanInverted [
	"AutoGenerated by Druid"

	| jump1 jump2 currentBlock |
	self MoveR: ReceiverResultReg R: TempReg.
	self MoveCq: 10 R: ClassReg.
	self CmpR: TempReg R: ClassReg.
	jump1 := self JumpGreaterOrEqual: 0.
	self MoveCq: 5 R: ReceiverResultReg.
	jump2 := self Jump: 0.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	self MoveCq: 11 R: ReceiverResultReg.
	currentBlock := self Label.
	jump2 jmpTarget: currentBlock.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveLessThanThanInverted [

	| currentBlock jump0 jump1 |
	self MoveCq: true asBit R: TempReg.
	self MoveCq: 10 R: ClassReg.
	self CmpCq: 10 R: ReceiverResultReg.
	jump0 := self JumpLess: 0.
	self MoveCq: 5 R: Extra0Reg.
	self MoveCq: 5 R: Extra1Reg.
	self MoveR: Extra1Reg R: ClassReg.
	self MoveR: ReceiverResultReg R: SendNumArgsReg.
	jump1 := self Jump: 0.
	currentBlock := self Label.
	jump0 jmpTarget: currentBlock.
	self MoveCq: 11 R: Extra2Reg.
	self MoveCq: 11 R: TempReg.
	self MoveR: TempReg R: ClassReg.
	self MoveR: ReceiverResultReg R: SendNumArgsReg.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	self MoveCq: 1 R: Extra0Reg.
	self MoveR: ClassReg R: ReceiverResultReg.
	self RetN: 1 * objectMemory wordSize.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveLessThanValue [
	"AutoGenerated by Druid"

	| jumpNext currentBlock jumpTrue |
	self MoveR: ReceiverResultReg R: TempReg.
	self CmpCq: 0 R: TempReg.
	jumpTrue := self JumpLess: 0.
	self MoveCq: 0 R: TempReg.
	jumpNext := self Jump: 0.
	jumpTrue jmpTarget: self Label.
	self MoveCq: 1 R: TempReg.
	jumpNext jmpTarget: self Label.
	self MoveR: TempReg R: ReceiverResultReg.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveLoopIncrementing [
	"AutoGenerated by Druid"

	| jump1 jump2 b21 currentBlock |
	self MoveCq: 10 R: TempReg.
	b21 := self Label.
	self MoveR: TempReg R: ClassReg.
	self AddCq: 1 R: ClassReg.
	self CmpCq: 15 R: ClassReg.
	jump1 := self JumpGreaterOrEqual: 0.
	self MoveR: ClassReg R: TempReg.
	jump2 := self Jump: b21.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	self MoveR: ClassReg R: ReceiverResultReg.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveLoopIncrementingGlobalState [
	"AutoGenerated by Druid"

	| jump1 jump2 b21 currentBlock |
	self MoveCq: 10 R: TempReg.
	b21 := self Label.
	self MoveR: TempReg R: ClassReg.
	self AddCq: 1 R: ClassReg.
	self CmpCq: 15 R: ClassReg.
	jump1 := self JumpGreaterOrEqual: 0.
	self MoveR: ClassReg R: TempReg.
	jump2 := self Jump: b21.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	self MoveR: ClassReg R: ReceiverResultReg.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveLoopWithInvariant [

	| jump1 currentBlock b14 |
	self MoveCq: 0 R: TempReg.
	self MoveR: ReceiverResultReg R: ClassReg.
	b14 := self Label.
	self MoveCq: 1 R: SendNumArgsReg.
	self MoveR: ClassReg R: Extra0Reg.
	self MulR: SendNumArgsReg R: Extra0Reg.
	self MoveR: TempReg R: SendNumArgsReg.
	self AddR: Extra0Reg R: SendNumArgsReg.
	self CmpCq: 15 R: SendNumArgsReg.
	jump1 := self JumpLess: 0.
	self MoveR: SendNumArgsReg R: ReceiverResultReg.
	self genPrimReturn.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	self MoveR: SendNumArgsReg R: TempReg.
	jump1 := self Jump: b14.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveMod [
	"AutoGenerated by Druid"

	| currentBlock |
	self MoveR: ReceiverResultReg R: TempReg.
	self MoveR: Arg0Reg R: ClassReg.
	self
		DivR: ClassReg
		R: TempReg
		Quo: ClassReg
		Rem: TempReg.
	self MoveR: TempReg R: ReceiverResultReg.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveModByConstant [
	"AutoGenerated by Druid"

	| currentBlock |
	self MoveR: ReceiverResultReg R: TempReg.
	self MoveCq: 2 R: ClassReg.
	self
		DivR: ClassReg
		R: TempReg
		Quo: ClassReg
		Rem: TempReg.
	self MoveR: TempReg R: ReceiverResultReg.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveMultiply [

	| currentBlock |
	self MoveR: ReceiverResultReg R: TempReg.
	self MoveR: TempReg R: ReceiverResultReg.
	self MulR: ReceiverResultReg R: TempReg.
	self MoveR: TempReg R: ReceiverResultReg.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveMultiplyConstantArgument [
	"AutoGenerated by Druid"

	| currentBlock |
	self MoveR: ReceiverResultReg R: TempReg.
	self MoveCq: 2 R: ClassReg.
	self MulR: TempReg R: ClassReg.
	self MoveR: ClassReg R: ReceiverResultReg.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveMultiplyConstantReceiver [
	"AutoGenerated by Druid"

	| currentBlock |
	self MoveR: ReceiverResultReg R: TempReg.
	self MoveCq: 2 R: ClassReg.
	self MulR: ClassReg R: TempReg.
	self MoveR: TempReg R: ReceiverResultReg.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveMultiplyInverted [

	| currentBlock |
	self MoveCq: 2 R: TempReg.
	self MoveR: TempReg Cq: 2.
	self MulCq: 2 R: TempReg.
	self MoveR: TempReg R: ReceiverResultReg.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveMultiplyWithOverflow [
	"AutoGenerated by Druid"

	| jump1 jump2 currentBlock |
	self MoveR: ReceiverResultReg R: TempReg.
	self MoveR: Arg0Reg R: ClassReg.
	self ArithmeticShiftRightCq: 3 R: TempReg.
	self SubCq: 1 R: ClassReg.
	self MulR: ClassReg R: TempReg.
	jump1 := self JumpMultiplyNoOverflow: 0.
	self MoveCq: 99 R: ReceiverResultReg.
	jump2 := self Jump: 0.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	self AddCq: 1 R: TempReg.
	self MoveR: TempReg R: ReceiverResultReg.
	currentBlock := self Label.
	jump2 jmpTarget: currentBlock.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveNegated [
	"AutoGenerated by Druid"

	| currentBlock |
	self MoveR: ReceiverResultReg R: TempReg.
	self MoveR: TempReg R: TempReg.
	self NegateR: TempReg.
	self MoveR: TempReg R: ReceiverResultReg.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveNew [
	"AutoGenerated by Druid"

	| jump1 b391 jumpNext jump9 jump6 jump3 currentBlock jump8 jump5 jumpTrue jump2 jump7 jump4 |
	self MoveM64: 24 r: ReceiverResultReg R: TempReg.
	self ArithmeticShiftRightCq: 3 R: TempReg.
	self MoveR: TempReg R: ClassReg.
	self ArithmeticShiftRightCq: 16 R: ClassReg.
	self AndCq: 31 R: ClassReg.
	self MoveR: ClassReg R: SendNumArgsReg.
	self CmpCq: 1 R: SendNumArgsReg.
	jumpTrue := self JumpLessOrEqual: 0.
	self MoveCq: 0 R: SendNumArgsReg.
	jumpNext := self Jump: 0.
	jumpTrue jmpTarget: self Label.
	self MoveCq: 1 R: SendNumArgsReg.
	jumpNext jmpTarget: self Label.
	self CmpCq: 1 R: ClassReg.
	jump1 := self JumpAbove: 0.
	jump2 := self Jump: 0.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	self MoveR: ClassReg R: SendNumArgsReg.
	self CmpCq: 5 R: SendNumArgsReg.
	jumpTrue := self JumpZero: 0.
	self MoveCq: 0 R: SendNumArgsReg.
	jumpNext := self Jump: 0.
	jumpTrue jmpTarget: self Label.
	self MoveCq: 1 R: SendNumArgsReg.
	jumpNext jmpTarget: self Label.
	currentBlock := self Label.
	jump2 jmpTarget: currentBlock.
	self CmpCq: 1 R: SendNumArgsReg.
	jump2 := self JumpNonZero: 0.
	self MoveM32: 4 r: ReceiverResultReg R: SendNumArgsReg.
	self AndCq: 16rFFFFFFFF R: SendNumArgsReg.
	self AndCq: 16r3FFFFF R: SendNumArgsReg.
	self CmpCq: 0 R: SendNumArgsReg.
	jump1 := self JumpZero: 0.
	self CmpCq: 0 R: SendNumArgsReg.
	jump3 := self JumpAboveOrEqual: 0.
	jump4 := self Jump: 0.
	currentBlock := self Label.
	jump3 jmpTarget: currentBlock.
	self AndCq: 16rFFFF R: TempReg.
	self CmpCq: 255 R: TempReg.
	jump3 := self JumpLess: 0.
	self MoveR: TempReg R: Extra0Reg.
	self ArithmeticShiftRightCq: 56 R: Extra0Reg.
	self CmpCq: 0 R: Extra0Reg.
	jump5 := self JumpLessOrEqual: 0.
	self MoveCq: 0 R: Extra0Reg.
	jump6 := self Jump: 0.
	currentBlock := self Label.
	jump5 jmpTarget: currentBlock.
	self MoveCq: 8 R: Extra0Reg.
	self MulR: TempReg R: Extra0Reg.
	self AddCq: 16 R: Extra0Reg.
	self MoveAw: objectMemory freeStartAddress R: Extra1Reg.
	self AddR: Extra0Reg R: Extra1Reg.
	self CmpCq: objectMemory getScavengeThreshold R: Extra1Reg.
	jump5 := self JumpLessOrEqual: 0.
	jump7 := self Jump: 0.
	currentBlock := self Label.
	jump5 jmpTarget: currentBlock.
	jump5 := self Jump: 0.
	currentBlock := self Label.
	jump3 jmpTarget: currentBlock.
	self CmpCq: 1 R: TempReg.
	jump3 := self JumpGreaterOrEqual: 0.
	self MoveCq: 8 R: Extra1Reg.
	jump8 := self Jump: 0.
	currentBlock := self Label.
	jump3 jmpTarget: currentBlock.
	self MoveCq: 8 R: Extra1Reg.
	self MulR: TempReg R: Extra1Reg.
	currentBlock := self Label.
	jump8 jmpTarget: currentBlock.
	self AddCq: 8 R: Extra1Reg.
	self MoveAw: objectMemory freeStartAddress R: Extra2Reg.
	self AddR: Extra1Reg R: Extra2Reg.
	self CmpCq: objectMemory getScavengeThreshold R: Extra2Reg.
	jump8 := self JumpLessOrEqual: 0.
	self MoveR: Extra1Reg R: Extra0Reg.
	self MoveR: Extra2Reg R: Extra1Reg.
	currentBlock := self Label.
	jump7 jmpTarget: currentBlock.
	self CmpCq: objectMemory getScavengeThreshold R: Extra1Reg.
	jump7 := self JumpLessOrEqual: 0.
	self MoveR: Extra0Reg R: SendNumArgsReg.
	jump3 := self Jump: 0.
	currentBlock := self Label.
	jump7 jmpTarget: currentBlock.
	self MoveAw: objectMemory freeStartAddress R: Extra2Reg.
	self CmpCq: 255 R: TempReg.
	jump7 := self JumpLess: 0.
	jump9 := self Jump: 0.
	currentBlock := self Label.
	jump7 jmpTarget: currentBlock.
	jump7 := self Jump: 0.
	currentBlock := self Label.
	jump8 jmpTarget: currentBlock.
	self MoveR: Extra1Reg R: Extra0Reg.
	self MoveR: Extra2Reg R: Extra1Reg.
	currentBlock := self Label.
	jump5 jmpTarget: currentBlock.
	self MoveAw: objectMemory freeStartAddress R: Extra2Reg.
	self CmpCq: 255 R: TempReg.
	jump5 := self JumpLess: 0.
	currentBlock := self Label.
	jump9 jmpTarget: currentBlock.
	self MoveR: TempReg R: Extra1Reg.
	self AddCq: 16rFF00000000000000 R: Extra1Reg.
	self MoveR: Extra1Reg M64: 0 r: Extra2Reg.
	self LogicalShiftLeftCq: 24 R: ClassReg.
	self AddR: SendNumArgsReg R: ClassReg.
	self AddCq: 16rFF00000000000000 R: ClassReg.
	self OrCq: 0 R: ClassReg.
	self MoveR: ClassReg M64: 8 r: Extra2Reg.
	self AddCq: 8 R: Extra2Reg.
	self MoveR: Extra2Reg R: Extra1Reg.
	jump9 := self Jump: 0.
	currentBlock := self Label.
	jump5 jmpTarget: currentBlock.
	currentBlock := self Label.
	jump7 jmpTarget: currentBlock.
	self MoveR: TempReg R: Extra1Reg.
	self LogicalShiftLeftCq: 56 R: Extra1Reg.
	self LogicalShiftLeftCq: 24 R: ClassReg.
	self AddR: ClassReg R: Extra1Reg.
	self AddR: SendNumArgsReg R: Extra1Reg.
	self OrCq: 0 R: Extra1Reg.
	self MoveR: Extra1Reg M64: 0 r: Extra2Reg.
	self MoveR: Extra2Reg R: Extra1Reg.
	currentBlock := self Label.
	jump9 jmpTarget: currentBlock.
	self MoveAw: objectMemory freeStartAddress R: SendNumArgsReg.
	self AddR: Extra0Reg R: SendNumArgsReg.
	self MoveR: SendNumArgsReg Aw: objectMemory freeStartAddress.
	self MoveR: Extra1Reg R: Extra0Reg.
	currentBlock := self Label.
	jump6 jmpTarget: currentBlock.
	self CmpCq: 0 R: Extra0Reg.
	jump6 := self JumpNonZero: 0.
	self MoveR: ReceiverResultReg R: SendNumArgsReg.
	jump9 := self Jump: 0.
	currentBlock := self Label.
	jump6 jmpTarget: currentBlock.
	self MoveR: Extra0Reg R: SendNumArgsReg.
	self AddCq: 8 R: SendNumArgsReg.
	self MoveCq: 8 R: Extra1Reg.
	self MulR: TempReg R: Extra1Reg.
	self MoveR: Extra0Reg R: TempReg.
	self AddR: Extra1Reg R: TempReg.
	self AddCq: 8 R: TempReg.
	self SubCq: 1 R: TempReg.
	self MoveR: ReceiverResultReg R: Extra1Reg.
	b391 := self Label.
	self CmpR: SendNumArgsReg R: TempReg.
	jump6 := self JumpLess: 0.
	self MoveCq: objectMemory nilObject R: ClassReg.
	self MoveR: ClassReg M64: 0 r: SendNumArgsReg.
	self MoveR: SendNumArgsReg R: ClassReg.
	self AddCq: 8 R: ClassReg.
	self MoveR: ClassReg R: SendNumArgsReg.
	jump7 := self Jump: b391.
	currentBlock := self Label.
	jump6 jmpTarget: currentBlock.
	self MoveR: Extra1Reg R: SendNumArgsReg.
	currentBlock := self Label.
	jump9 jmpTarget: currentBlock.
	self MoveR: Extra0Reg R: ClassReg.
	jump9 := self Jump: 0.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	jump1 := self Jump: 0.
	currentBlock := self Label.
	jump2 jmpTarget: currentBlock.
	self MoveCq: 0 R: SendNumArgsReg.
	self MoveR: SendNumArgsReg R: ClassReg.
	self MoveR: ReceiverResultReg R: SendNumArgsReg.
	currentBlock := self Label.
	jump9 jmpTarget: currentBlock.
	self CmpCq: 0 R: ClassReg.
	jump9 := self JumpNonZero: 0.
	self MoveR: SendNumArgsReg R: ReceiverResultReg.
	jump2 := self Jump: 0.
	currentBlock := self Label.
	jump9 jmpTarget: currentBlock.
	self MoveR: ClassReg R: ReceiverResultReg.
	self genPrimReturn.
	currentBlock := self Label.
	jump4 jmpTarget: currentBlock.
	jump3 jmpTarget: currentBlock.
	jump1 jmpTarget: currentBlock.
	jump2 jmpTarget: currentBlock.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveNewWithArg [
	"AutoGenerated by Druid"

	| jump1 jump10 jumpNext jump13 jump9 jump6 jump3 jump12 currentBlock jump8 jump5 jumpTrue jump2 jump11 b986 jump7 jump4 |
	self AddCq: 24 R: SPReg.
	self TstCq: 1 R: Arg0Reg.
	jump1 := self JumpZero: 0.
	self MoveR: Arg0Reg R: TempReg.
	self ArithmeticShiftRightCq: 3 R: TempReg.
	self CmpCq: 0 R: TempReg.
	jump2 := self JumpLess: 0.
	self MoveM64: 24 r: ReceiverResultReg R: ClassReg.
	self ArithmeticShiftRightCq: 3 R: ClassReg.
	self MoveR: ClassReg R: SendNumArgsReg.
	self ArithmeticShiftRightCq: 16 R: SendNumArgsReg.
	self AndCq: 31 R: SendNumArgsReg.
	self MoveM32: 4 r: ReceiverResultReg R: Extra0Reg.
	self AndCq: 16rFFFFFFFF R: Extra0Reg.
	self AndCq: 16r3FFFFF R: Extra0Reg.
	self MoveCq: 0 R: Extra1Reg.
	self CmpCq: 2 R: SendNumArgsReg.
	jump3 := self JumpNonZero: 0.
	self MoveCq: objectMemory nilObject R: Extra1Reg.
	jump4 := self Jump: 0.
	currentBlock := self Label.
	jump3 jmpTarget: currentBlock.
	self CmpCq: 3 R: SendNumArgsReg.
	jump3 := self JumpNonZero: 0.
	self AndCq: 16rFFFF R: ClassReg.
	self AddR: TempReg R: ClassReg.
	self MoveCq: objectMemory nilObject R: Extra1Reg.
	self MoveR: ClassReg R: TempReg.
	jump5 := self Jump: 0.
	currentBlock := self Label.
	jump3 jmpTarget: currentBlock.
	self CmpCq: 4 R: SendNumArgsReg.
	jump3 := self JumpNonZero: 0.
	self AndCq: 16rFFFF R: ClassReg.
	self AddR: TempReg R: ClassReg.
	self MoveCq: objectMemory nilObject R: Extra1Reg.
	self MoveR: ClassReg R: TempReg.
	jump6 := self Jump: 0.
	currentBlock := self Label.
	jump3 jmpTarget: currentBlock.
	self CmpCq: 9 R: SendNumArgsReg.
	jump3 := self JumpNonZero: 0.
	jump7 := self Jump: 0.
	currentBlock := self Label.
	jump3 jmpTarget: currentBlock.
	self CmpCq: 10 R: SendNumArgsReg.
	jump3 := self JumpNonZero: 0.
	self CmpCq: 34 R: Extra0Reg.
	jump8 := self JumpNonZero: 0.
	self MoveR: TempReg R: Extra1Reg.
	self CmpCq: 2 R: Extra1Reg.
	jumpTrue := self JumpNonZero: 0.
	self MoveCq: 0 R: Extra1Reg.
	jumpNext := self Jump: 0.
	jumpTrue jmpTarget: self Label.
	self MoveCq: 1 R: Extra1Reg.
	jumpNext jmpTarget: self Label.
	self CmpCq: 2 R: TempReg.
	jump9 := self JumpNonZero: 0.
	self MoveR: TempReg R: Extra1Reg.
	self AddCq: 1 R: Extra1Reg.
	self MoveCq: 2 R: ClassReg.
	self
		DivR: ClassReg
		R: Extra1Reg
		Quo: Extra1Reg
		Rem: ClassReg.
	self AndCq: 1 R: TempReg.
	self AddR: TempReg R: SendNumArgsReg.
	self MoveCq: 0 R: ClassReg.
	jump10 := self Jump: 0.
	currentBlock := self Label.
	jump8 jmpTarget: currentBlock.
	self MoveR: TempReg R: ClassReg.
	self AddCq: 1 R: ClassReg.
	self MoveCq: 2 R: Extra1Reg.
	self
		DivR: Extra1Reg
		R: ClassReg
		Quo: Extra1Reg
		Rem: ClassReg.
	self AndCq: 1 R: TempReg.
	self AddR: TempReg R: SendNumArgsReg.
	self MoveCq: 0 R: ClassReg.
	self CmpCq: 0 R: Extra0Reg.
	jump8 := self JumpNonZero: 0.
	self MoveR: Extra1Reg R: Extra0Reg.
	jump11 := self Jump: 0.
	currentBlock := self Label.
	jump8 jmpTarget: currentBlock.
	currentBlock := self Label.
	jump10 jmpTarget: currentBlock.
	self MoveR: Extra1Reg R: TempReg.
	jump10 := self Jump: 0.
	currentBlock := self Label.
	jump3 jmpTarget: currentBlock.
	self CmpCq: 12 R: SendNumArgsReg.
	jump3 := self JumpNonZero: 0.
	self MoveR: TempReg R: ClassReg.
	self AddCq: 3 R: ClassReg.
	self MoveCq: 4 R: Extra2Reg.
	self
		DivR: Extra2Reg
		R: ClassReg
		Quo: Extra2Reg
		Rem: ClassReg.
	self MoveCq: 4 R: ClassReg.
	self SubR: TempReg R: ClassReg.
	self AndCq: 3 R: ClassReg.
	self AddR: ClassReg R: SendNumArgsReg.
	self MoveR: Extra2Reg R: TempReg.
	jump8 := self Jump: 0.
	currentBlock := self Label.
	jump3 jmpTarget: currentBlock.
	self CmpCq: 16 R: SendNumArgsReg.
	jump3 := self JumpNonZero: 0.
	self MoveR: TempReg R: ClassReg.
	self AddCq: 7 R: ClassReg.
	self MoveCq: 8 R: Extra2Reg.
	self
		DivR: Extra2Reg
		R: ClassReg
		Quo: ClassReg
		Rem: Extra2Reg.
	self MoveCq: 8 R: Extra2Reg.
	self SubR: TempReg R: Extra2Reg.
	self AndCq: 7 R: Extra2Reg.
	self AddR: Extra2Reg R: SendNumArgsReg.
	self MoveR: ClassReg R: TempReg.
	jump12 := self Jump: 0.
	currentBlock := self Label.
	jump3 jmpTarget: currentBlock.
	self MoveR: TempReg R: Extra2Reg.
	self CmpCq: 0 R: Extra2Reg.
	jumpTrue := self JumpNonZero: 0.
	self MoveCq: 0 R: Extra2Reg.
	jumpNext := self Jump: 0.
	jumpTrue jmpTarget: self Label.
	self MoveCq: 1 R: Extra2Reg.
	jumpNext jmpTarget: self Label.
	self CmpCq: 0 R: TempReg.
	jump3 := self JumpZero: 0.
	jump13 := self Jump: 0.
	currentBlock := self Label.
	jump3 jmpTarget: currentBlock.
	self MoveR: SendNumArgsReg R: Extra2Reg.
	self CmpCq: 5 R: Extra2Reg.
	jumpTrue := self JumpAbove: 0.
	self MoveCq: 0 R: Extra2Reg.
	jumpNext := self Jump: 0.
	jumpTrue jmpTarget: self Label.
	self MoveCq: 1 R: Extra2Reg.
	jumpNext jmpTarget: self Label.
	currentBlock := self Label.
	jump13 jmpTarget: currentBlock.
	self CmpCq: 1 R: Extra2Reg.
	jump13 := self JumpNonZero: 0.
	self MoveCq: 0 R: Extra2Reg.
	self MoveR: Arg0Reg R: ClassReg.
	self MoveR: ReceiverResultReg R: SendNumArgsReg.
	jump3 := self Jump: 0.
	currentBlock := self Label.
	jump13 jmpTarget: currentBlock.
	self AndCq: 16rFFFF R: ClassReg.
	self MoveCq: objectMemory nilObject R: Extra2Reg.
	self MoveR: ClassReg R: TempReg.
	self MoveR: Extra2Reg R: Extra1Reg.
	currentBlock := self Label.
	jump4 jmpTarget: currentBlock.
	jump5 jmpTarget: currentBlock.
	jump6 jmpTarget: currentBlock.
	jump7 jmpTarget: currentBlock.
	jump8 jmpTarget: currentBlock.
	jump12 jmpTarget: currentBlock.
	self CmpCq: 0 R: Extra0Reg.
	jump12 := self JumpNonZero: 0.
	self MoveR: TempReg R: Extra0Reg.
	self MoveR: Extra1Reg R: ClassReg.
	currentBlock := self Label.
	jump11 jmpTarget: currentBlock.
	self MoveM32: 4 r: ReceiverResultReg R: Extra2Reg.
	self AndCq: 16rFFFFFFFF R: Extra2Reg.
	self AndCq: 16r3FFFFF R: Extra2Reg.
	self CmpCq: 0 R: Extra2Reg.
	jump11 := self JumpZero: 0.
	self CmpCq: 0 R: Extra2Reg.
	jump8 := self JumpBelow: 0.
	self MoveR: Extra0Reg R: Extra3Reg.
	self MoveR: Extra3Reg Mw: 8 r: SPReg.
	self MoveR: ClassReg R: Extra3Reg.
	self MoveR: Extra3Reg Mw: 16 r: SPReg.
	jump7 := self Jump: 0.
	currentBlock := self Label.
	jump12 jmpTarget: currentBlock.
	self MoveR: Extra1Reg R: ClassReg.
	currentBlock := self Label.
	jump10 jmpTarget: currentBlock.
	self MoveR: TempReg R: Extra3Reg.
	self MoveR: Extra3Reg Mw: 8 r: SPReg.
	self MoveR: ClassReg R: Extra3Reg.
	self MoveR: Extra3Reg Mw: 16 r: SPReg.
	self MoveR: Extra0Reg R: Extra2Reg.
	currentBlock := self Label.
	jump7 jmpTarget: currentBlock.
	self MoveR: Arg0Reg R: Extra3Reg.
	self MoveR: Extra3Reg Mw: 24 r: SPReg.
	self MoveR: ReceiverResultReg R: Extra1Reg.
	self MoveMw: 8 r: SPReg R: Extra3Reg.
	self CmpCq: 255 R: Extra3Reg.
	jump7 := self JumpLess: 0.
	self MoveMw: 8 r: SPReg R: Extra3Reg.
	self MoveR: Extra3Reg R: TempReg.
	self ArithmeticShiftRightCq: 56 R: TempReg.
	self CmpCq: 0 R: TempReg.
	jump10 := self JumpLessOrEqual: 0.
	self MoveCq: 0 R: TempReg.
	jump12 := self Jump: 0.
	currentBlock := self Label.
	jump10 jmpTarget: currentBlock.
	self MoveCq: 8 R: TempReg.
	self MoveMw: 8 r: SPReg R: Extra3Reg.
	self MulR: Extra3Reg R: TempReg.
	self AddCq: 16 R: TempReg.
	jump10 := self Jump: 0.
	currentBlock := self Label.
	jump7 jmpTarget: currentBlock.
	self MoveMw: 8 r: SPReg R: Extra3Reg.
	self CmpCq: 1 R: Extra3Reg.
	jump7 := self JumpGreaterOrEqual: 0.
	self MoveCq: 8 R: TempReg.
	jump6 := self Jump: 0.
	currentBlock := self Label.
	jump7 jmpTarget: currentBlock.
	self MoveCq: 8 R: TempReg.
	self MoveMw: 8 r: SPReg R: Extra3Reg.
	self MulR: Extra3Reg R: TempReg.
	currentBlock := self Label.
	jump6 jmpTarget: currentBlock.
	self AddCq: 8 R: TempReg.
	currentBlock := self Label.
	jump10 jmpTarget: currentBlock.
	self MoveAw: objectMemory freeStartAddress R: ClassReg.
	self MoveMw: 8 r: SPReg R: Extra3Reg.
	self CmpCq: 255 R: Extra3Reg.
	jump10 := self JumpLess: 0.
	self MoveMw: 8 r: SPReg R: Extra3Reg.
	self MoveR: Extra3Reg R: Extra0Reg.
	self AddCq: 16rFF00000000000000 R: Extra0Reg.
	self MoveR: Extra0Reg M64: 0 r: ClassReg.
	self LogicalShiftLeftCq: 24 R: SendNumArgsReg.
	self AddR: Extra2Reg R: SendNumArgsReg.
	self AddCq: 16rFF00000000000000 R: SendNumArgsReg.
	self OrCq: 0 R: SendNumArgsReg.
	self MoveR: SendNumArgsReg M64: 8 r: ClassReg.
	self AddCq: 8 R: ClassReg.
	self MoveR: ClassReg R: Extra0Reg.
	jump6 := self Jump: 0.
	currentBlock := self Label.
	jump10 jmpTarget: currentBlock.
	self MoveMw: 8 r: SPReg R: Extra3Reg.
	self MoveR: Extra3Reg R: Extra0Reg.
	self LogicalShiftLeftCq: 56 R: Extra0Reg.
	self LogicalShiftLeftCq: 24 R: SendNumArgsReg.
	self AddR: SendNumArgsReg R: Extra0Reg.
	self AddR: Extra2Reg R: Extra0Reg.
	self OrCq: 0 R: Extra0Reg.
	self MoveR: Extra0Reg M64: 0 r: ClassReg.
	self MoveR: ClassReg R: Extra0Reg.
	currentBlock := self Label.
	jump6 jmpTarget: currentBlock.
	self MoveAw: objectMemory freeStartAddress R: ClassReg.
	self AddR: TempReg R: ClassReg.
	self MoveR: ClassReg Aw: objectMemory freeStartAddress.
	self MoveR: Extra0Reg R: TempReg.
	currentBlock := self Label.
	jump12 jmpTarget: currentBlock.
	self CmpCq: 0 R: TempReg.
	jump12 := self JumpNonZero: 0.
	self MoveMw: 24 r: SPReg R: Extra3Reg.
	self MoveR: Extra3Reg R: ClassReg.
	jump6 := self Jump: 0.
	currentBlock := self Label.
	jump12 jmpTarget: currentBlock.
	self MoveR: TempReg R: ClassReg.
	self AddCq: 8 R: ClassReg.
	self MoveCq: 8 R: Extra0Reg.
	self MoveMw: 8 r: SPReg R: Extra3Reg.
	self MulR: Extra3Reg R: Extra0Reg.
	self MoveR: TempReg R: Extra2Reg.
	self AddR: Extra0Reg R: Extra2Reg.
	self AddCq: 8 R: Extra2Reg.
	self SubCq: 1 R: Extra2Reg.
	self MoveMw: 24 r: SPReg R: Extra3Reg.
	self MoveR: Extra3Reg R: Extra0Reg.
	b986 := self Label.
	self CmpR: ClassReg R: Extra2Reg.
	jump12 := self JumpLess: 0.
	self MoveMw: 16 r: SPReg R: Extra3Reg.
	self MoveR: Extra3Reg M64: 0 r: ClassReg.
	self MoveR: ClassReg R: SendNumArgsReg.
	self AddCq: 8 R: SendNumArgsReg.
	self MoveR: SendNumArgsReg R: ClassReg.
	jump10 := self Jump: b986.
	currentBlock := self Label.
	jump12 jmpTarget: currentBlock.
	self MoveR: Extra0Reg R: ClassReg.
	currentBlock := self Label.
	jump6 jmpTarget: currentBlock.
	self MoveR: TempReg R: Extra2Reg.
	self MoveR: Extra1Reg R: SendNumArgsReg.
	currentBlock := self Label.
	jump3 jmpTarget: currentBlock.
	self CmpCq: 0 R: Extra2Reg.
	jump3 := self JumpNonZero: 0.
	self MoveR: ClassReg R: Arg0Reg.
	self MoveR: SendNumArgsReg R: ReceiverResultReg.
	jump6 := self Jump: 0.
	currentBlock := self Label.
	jump3 jmpTarget: currentBlock.
	self MoveR: Extra2Reg R: ReceiverResultReg.
	self SubCq: 24 R: SPReg.
	self genPrimReturn.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	jump2 jmpTarget: currentBlock.
	jump9 jmpTarget: currentBlock.
	jump11 jmpTarget: currentBlock.
	jump8 jmpTarget: currentBlock.
	jump6 jmpTarget: currentBlock.
	self SubCq: 24 R: SPReg.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveNextUint16At [
	"AutoGenerated by Druid"

	| currentBlock |
	self MoveM16: 1 r: ReceiverResultReg R: TempReg.
	self AndCq: 16rFFFF R: TempReg.
	self MoveR: TempReg R: ReceiverResultReg.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveNoopLoopWithInvariant [
	"AutoGenerated by Druid"

	| jump3 jump1 b22 currentBlock jump2 |
	self MoveR: ReceiverResultReg R: TempReg.
	self CmpCq: 10 R: TempReg.
	jump1 := self JumpGreaterOrEqual: 0.
	b22 := self Label.
	self MoveR: TempReg R: ClassReg.
	self AddCq: 1 R: ClassReg.
	self CmpCq: 10 R: ClassReg.
	jump2 := self JumpGreaterOrEqual: 0.
	self MoveR: ClassReg R: TempReg.
	jump3 := self Jump: b22.
	currentBlock := self Label.
	jump2 jmpTarget: currentBlock.
	self MoveCq: 5 R: ReceiverResultReg.
	jump2 := self Jump: 0.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	self MoveCq: 3 R: ReceiverResultReg.
	currentBlock := self Label.
	jump2 jmpTarget: currentBlock.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveNotEqualsThan [
	"AutoGenerated by Druid"

	| jump1 jump2 currentBlock |
	self MoveR: ReceiverResultReg R: TempReg.
	self CmpCq: 10 R: TempReg.
	jump1 := self JumpZero: 0.
	self MoveCq: 5 R: ReceiverResultReg.
	jump2 := self Jump: 0.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	self MoveCq: 11 R: ReceiverResultReg.
	currentBlock := self Label.
	jump2 jmpTarget: currentBlock.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveNotEqualsThanFloats [
	"AutoGenerated by Druid"

	| jumpNext currentBlock jumpTrue |
	self MoveR: ReceiverResultReg R: TempReg.
	self MoveR: Arg0Reg R: ClassReg.
	self ConvertR: ClassReg Rd: DPFPReg0.
	self ConvertR: TempReg Rd: DPFPReg1.
	self CmpRd: DPFPReg1 Rd: DPFPReg0.
	jumpTrue := self JumpFPNotEqual: 0.
	self MoveCq: 0 R: TempReg.
	jumpNext := self Jump: 0.
	jumpTrue jmpTarget: self Label.
	self MoveCq: 1 R: TempReg.
	jumpNext jmpTarget: self Label.
	self MoveR: TempReg R: ReceiverResultReg.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveNotEqualsThanInverted [
	"AutoGenerated by Druid"

	| jump1 jump2 currentBlock |
	self MoveR: ReceiverResultReg R: TempReg.
	self MoveCq: 10 R: ClassReg.
	self CmpR: TempReg R: ClassReg.
	jump1 := self JumpZero: 0.
	self MoveCq: 5 R: ReceiverResultReg.
	jump2 := self Jump: 0.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	self MoveCq: 11 R: ReceiverResultReg.
	currentBlock := self Label.
	jump2 jmpTarget: currentBlock.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveOr [
	"AutoGenerated by Druid"

	| jumpNext jumpTrue jump1 currentBlock jump2 |
	self MoveR: ReceiverResultReg R: TempReg.
	self MoveR: TempReg R: ClassReg.
	self CmpCq: 5 R: ClassReg.
	jumpTrue := self JumpLess: 0.
	self MoveCq: 0 R: ClassReg.
	jumpNext := self Jump: 0.
	jumpTrue jmpTarget: self Label.
	self MoveCq: 1 R: ClassReg.
	jumpNext jmpTarget: self Label.
	self CmpCq: 5 R: TempReg.
	jump1 := self JumpGreaterOrEqual: 0.
	jump2 := self Jump: 0.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	self CmpCq: 10 R: TempReg.
	jumpTrue := self JumpGreater: 0.
	self MoveCq: 0 R: TempReg.
	jumpNext := self Jump: 0.
	jumpTrue jmpTarget: self Label.
	self MoveCq: 1 R: TempReg.
	jumpNext jmpTarget: self Label.
	self MoveR: TempReg R: ClassReg.
	currentBlock := self Label.
	jump2 jmpTarget: currentBlock.
	self CmpCq: 1 R: ClassReg.
	jump2 := self JumpNonZero: 0.
	self MoveCq: 42 R: ReceiverResultReg.
	jump1 := self Jump: 0.
	currentBlock := self Label.
	jump2 jmpTarget: currentBlock.
	self MoveCq: 10 R: ReceiverResultReg.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitivePushFirstArgument [
	"AutoGenerated by Druid"

	| currentBlock |
	self MoveR: Arg0Reg R: TempReg.
	self MoveR: TempReg R: ReceiverResultReg.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitivePushReceiverOf0ArgSelector [
	"AutoGenerated by Druid"

	| currentBlock |
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitivePushReceiverOf1ArgSelector [
	"AutoGenerated by Druid"

	| currentBlock |
	self MoveR: Arg0Reg R: TempReg.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitivePushStackValue0 [
	"AutoGenerated by Druid"

	| currentBlock |
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitivePushStackValue0WithOneArgument [
	"AutoGenerated by Druid"

	| currentBlock |
	self MoveR: Arg0Reg R: ReceiverResultReg.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitivePushStackValue1 [
	"AutoGenerated by Druid"

	| currentBlock |
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveReturnFalse [
	"AutoGenerated by Druid"

	| currentBlock |
	self MoveCq: objectMemory falseObject R: ReceiverResultReg.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveReturnOne [
	"AutoGenerated by Druid"

	| currentBlock |
	self MoveCq: 1 R: ReceiverResultReg.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveReturnOneWithArguments [
	"AutoGenerated by Druid"

	| currentBlock |
	self MoveR: Arg1Reg R: TempReg.
	self MoveR: Arg0Reg R: TempReg.
	self MoveCq: 1 R: ReceiverResultReg.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveReturnTrue [
	"AutoGenerated by Druid"

	| currentBlock |
	self MoveCq: objectMemory trueObject R: ReceiverResultReg.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveSandclock [
	"AutoGenerated by Druid"

	| jump1 jump2 currentBlock |
	self MoveR: ReceiverResultReg R: TempReg.
	self CmpCq: 10 R: TempReg.
	jump1 := self JumpLessOrEqual: 0.
	self MoveCq: 1 R: TempReg.
	jump2 := self Jump: 0.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	self MoveCq: 99 R: ClassReg.
	self CmpCq: 0 R: TempReg.
	jump1 := self JumpLessOrEqual: 0.
	self MoveR: ClassReg R: TempReg.
	currentBlock := self Label.
	jump2 jmpTarget: currentBlock.
	self AddCq: 5 R: TempReg.
	self MoveR: TempReg R: ReceiverResultReg.
	jump2 := self Jump: 0.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	self MoveCq: 116 R: ReceiverResultReg.
	currentBlock := self Label.
	jump2 jmpTarget: currentBlock.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveSizeofusqInt [
	"AutoGenerated by Druid"

	| currentBlock |
	self MoveCq: 8 R: ReceiverResultReg.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveSmallOrEqualsThan [

	| currentBlock jump0 jump1 |
	self MoveCq: true asBit R: TempReg.
	self MoveCq: 10 R: ClassReg.
	self CmpCq: 10 R: ReceiverResultReg.
	jump0 := self JumpGreater: 0.
	self MoveCq: 5 R: Extra0Reg.
	self MoveCq: 5 R: Extra1Reg.
	self MoveR: Extra1Reg R: ClassReg.
	self MoveR: ReceiverResultReg R: SendNumArgsReg.
	jump1 := self Jump: 0.
	currentBlock := self Label.
	jump0 jmpTarget: currentBlock.
	self MoveCq: 11 R: Extra2Reg.
	self MoveCq: 11 R: TempReg.
	self MoveR: TempReg R: ClassReg.
	self MoveR: ReceiverResultReg R: SendNumArgsReg.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	self MoveCq: 1 R: Extra0Reg.
	self MoveR: ClassReg R: ReceiverResultReg.
	self RetN: 1 * objectMemory wordSize.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveSmallThan [

	| currentBlock jump0 jump1 |
	self MoveCq: true asBit R: TempReg.
	self MoveCq: 10 R: ClassReg.
	self CmpCq: 10 R: ReceiverResultReg.
	jump0 := self JumpGreaterOrEqual: 0.
	self MoveCq: 5 R: Extra0Reg.
	self MoveCq: 5 R: Extra1Reg.
	self MoveR: Extra1Reg R: ClassReg.
	self MoveR: ReceiverResultReg R: SendNumArgsReg.
	jump1 := self Jump: 0.
	currentBlock := self Label.
	jump0 jmpTarget: currentBlock.
	self MoveCq: 11 R: Extra2Reg.
	self MoveCq: 11 R: TempReg.
	self MoveR: TempReg R: ClassReg.
	self MoveR: ReceiverResultReg R: SendNumArgsReg.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	self MoveCq: 1 R: Extra0Reg.
	self MoveR: ClassReg R: ReceiverResultReg.
	self RetN: 1 * objectMemory wordSize.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveSubWithOverflow [
	"AutoGenerated by Druid"

	| jump1 jump2 currentBlock |
	self MoveR: ReceiverResultReg R: TempReg.
	self MoveR: Arg0Reg R: ClassReg.
	self AddCq:  -1 R: ClassReg.
	self SubR: ClassReg R: TempReg.
	jump1 := self JumpNoOverflow: 0.
	self MoveCq: 99 R: ReceiverResultReg.
	jump2 := self Jump: 0.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	self MoveR: TempReg R: ReceiverResultReg.
	currentBlock := self Label.
	jump2 jmpTarget: currentBlock.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveSumWithOverflow [
	"AutoGenerated by Druid"

	| jump1 jump2 currentBlock |
	self MoveR: ReceiverResultReg R: TempReg.
	self MoveR: Arg0Reg R: ClassReg.
	self AddCq:  -1 R: TempReg.
	self AddR: ClassReg R: TempReg.
	jump1 := self JumpNoOverflow: 0.
	self MoveCq: 99 R: ReceiverResultReg.
	jump2 := self Jump: 0.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	self MoveR: TempReg R: ReceiverResultReg.
	currentBlock := self Label.
	jump2 jmpTarget: currentBlock.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveTrueAssignmentAsInteger [
	"AutoGenerated by Druid"

	| currentBlock |
	self MoveCq: 1 R: ReceiverResultReg.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveTrueAssignmentAsIntegerShifted [
	"AutoGenerated by Druid"

	| currentBlock |
	self MoveCq: 2 R: ReceiverResultReg.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveTrueNot [
	"AutoGenerated by Druid"

	| currentBlock |
	self MoveCq: 0 R: ReceiverResultReg.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveUint16At [
	"AutoGenerated by Druid"

	| currentBlock |
	self MoveR: ReceiverResultReg R: TempReg.
	self MoveM16: 0 r: TempReg R: TempReg.
	self AndCq: 16rFFFF R: TempReg.
	self MoveR: TempReg R: ReceiverResultReg.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveUint16AtPut [
	"AutoGenerated by Druid"

	| currentBlock |
	self MoveR: ReceiverResultReg R: TempReg.
	self MoveR: Arg0Reg R: ClassReg.
	self MoveR: ClassReg M16: 0 r: TempReg.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveUint32At [
	"AutoGenerated by Druid"

	| currentBlock |
	self MoveR: ReceiverResultReg R: TempReg.
	self MoveM32: 0 r: TempReg R: TempReg.
	self AndCq: 16rFFFFFFFF R: TempReg.
	self MoveR: TempReg R: ReceiverResultReg.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveUint32AtPut [
	"AutoGenerated by Druid"

	| currentBlock |
	self MoveR: ReceiverResultReg R: TempReg.
	self MoveR: Arg0Reg R: ClassReg.
	self MoveR: ClassReg M32: 0 r: TempReg.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveUint64At [
	"AutoGenerated by Druid"

	| currentBlock |
	self MoveR: ReceiverResultReg R: TempReg.
	self MoveM64: 0 r: TempReg R: TempReg.
	self MoveR: TempReg R: ReceiverResultReg.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveUint64AtPut [
	"AutoGenerated by Druid"

	| currentBlock |
	self MoveR: ReceiverResultReg R: TempReg.
	self MoveR: Arg0Reg R: ClassReg.
	self MoveR: ClassReg M64: 0 r: TempReg.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveUint8At [
	"AutoGenerated by Druid"

	| currentBlock |
	self MoveR: ReceiverResultReg R: TempReg.
	self MoveMb: 0 r: TempReg R: TempReg.
	self AndCq: 255 R: TempReg.
	self MoveR: TempReg R: ReceiverResultReg.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveUint8AtPut [
	"AutoGenerated by Druid"

	| currentBlock |
	self MoveR: ReceiverResultReg R: TempReg.
	self MoveR: Arg0Reg R: ClassReg.
	self MoveR: ClassReg Mb: 0 r: TempReg.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveWithDeadCode [
	"AutoGenerated by Druid"

	| jump1 jump2 currentBlock |
	self MoveR: ReceiverResultReg R: TempReg.
	self CmpCq: 0 R: TempReg.
	jump1 := self JumpNonZero: 0.
	self MoveCq: 42 R: ReceiverResultReg.
	jump2 := self Jump: 0.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	self MoveCq: 55 R: ReceiverResultReg.
	currentBlock := self Label.
	jump2 jmpTarget: currentBlock.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveWithIfAssigningValue [

	| currentBlock jump0 jump1 |
	self CmpCq: 0 R: ReceiverResultReg.
	jump0 := self JumpZero: 0.
	self MoveCq: 57 R: ReceiverResultReg.
	jump1 := self Jump: 0.
	
	currentBlock := self Label.
	jump0 jmpTarget: currentBlock.
	self MoveCq: 42 R: ReceiverResultReg.
	
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	self RetN: 1 * objectMemory wordSize.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveWithIfNilIfNotNilStatement [
	"AutoGenerated by Druid"

	| jump1 jump2 currentBlock |
	self MoveR: ReceiverResultReg R: TempReg.
	self CmpCq: 0 R: TempReg.
	jump1 := self JumpLessOrEqual: 0.
	self MoveCq: 17 R: ReceiverResultReg.
	jump2 := self Jump: 0.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	self MoveCq: 42 R: ReceiverResultReg.
	currentBlock := self Label.
	jump2 jmpTarget: currentBlock.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveWithIfNotNilIfNilStatement [
	"AutoGenerated by Druid"

	| jump1 jump2 currentBlock |
	self MoveR: ReceiverResultReg R: TempReg.
	self CmpCq: 0 R: TempReg.
	jump1 := self JumpLessOrEqual: 0.
	self MoveCq: 17 R: ReceiverResultReg.
	jump2 := self Jump: 0.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	self MoveCq: 42 R: ReceiverResultReg.
	currentBlock := self Label.
	jump2 jmpTarget: currentBlock.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveWithIfNotNilIfNilStatementWithArgument [
	"AutoGenerated by Druid"

	| jump1 jump2 currentBlock |
	self MoveR: ReceiverResultReg R: TempReg.
	self CmpCq: 0 R: TempReg.
	jump1 := self JumpLessOrEqual: 0.
	self MoveCq: 17 R: ReceiverResultReg.
	jump2 := self Jump: 0.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	self MoveCq: 42 R: ReceiverResultReg.
	currentBlock := self Label.
	jump2 jmpTarget: currentBlock.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveWithIfNotNilStatement [
	"AutoGenerated by Druid"

	| jump1 jump2 currentBlock |
	self MoveR: ReceiverResultReg R: TempReg.
	self CmpCq: 0 R: TempReg.
	jump1 := self JumpLessOrEqual: 0.
	self MoveCq: 17 R: ReceiverResultReg.
	jump2 := self Jump: 0.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	self MoveCq: 42 R: ReceiverResultReg.
	currentBlock := self Label.
	jump2 jmpTarget: currentBlock.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveWithIfReturningValue [

	| currentBlock jump0 jump1 |
	self CmpCq: 0 R: ReceiverResultReg.
	jump0 := self JumpZero: 0.
	self MoveCq: 57 R: ReceiverResultReg.
	jump1 := self Jump: 0.
	
	currentBlock := self Label.
	jump0 jmpTarget: currentBlock.
	self MoveCq: 42 R: ReceiverResultReg.
	
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveWithNonCompilableBranch [
	"AutoGenerated by Druid"

	| jump1 currentBlock |
	self MoveR: ReceiverResultReg R: TempReg.
	self CmpCq: 0 R: TempReg.
	jump1 := self JumpLessOrEqual: 0.
	self MoveCq: 11 R: ReceiverResultReg.
	self genPrimReturn.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveWithSequentialExitPoint [
	"AutoGenerated by Druid"

	| currentBlock |
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_pushConstantOneBytecode [
	"AutoGenerated by Druid"

	| live currentBlock |
	live := 0.
	self ssPushConstant: ConstOne.
	^ 0
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_pushConstantTrueBytecode [
	"AutoGenerated by Druid"

	| live currentBlock |
	live := 0.
	self ssPushConstant: objectMemory trueObject.
	^ 0
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_pushConstantZeroBytecode [
	"AutoGenerated by Druid"

	| live currentBlock |
	live := 0.
	self ssPushConstant: ConstZero.
	^ 0
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_pushLiteralConstantBytecode [
	"AutoGenerated by Druid"

	| live currentBlock t0 |
	live := 0.
	t0 := self allocateRegNotConflictingWith: live ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t0).
	self genMoveConstant: methodObj R: t0.
	self ssPushConstant:
		(coInterpreter int64AtPointer:  ((methodObj + 8) + ((1 + LiteralStart) << 3))).
	^ 0
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_pushLiteralVariable16CasesBytecode [
	"AutoGenerated by Druid"

	| t0 t1 currentBlock live t2 |
	live := 0.
	t0 := self allocateRegNotConflictingWith: live ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t0).
	self genMoveConstant: methodObj R: t0.
	t1 := self allocateRegNotConflictingWith: live ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t1).
	t2 := self allocateRegNotConflictingWith: live ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t2).
	0=((coInterpreter int64AtPointer:  (coInterpreter int64AtPointer:  ((methodObj + 8) + ((0 + LiteralStart) << 3)))) bitAnd: 4194295)
		ifTrue: [
			| jumpNext jumpTrue jump1 jump3 jump2 b227 |
			self
				MoveCq:
				(coInterpreter int64AtPointer:  (((coInterpreter int64AtPointer:  ((methodObj + 8) + ((0 + LiteralStart) << 3))) + 8) + 0))
				R: t0.
			b227 := self Label.
			self MoveR: t0 R: t1.
			self AndCq: 7 R: t1.
			self CmpCq: 0 R: t1.
			jump1 := self JumpNonZero: 0.
			self MoveM64: 0 r: t0 R: t1.
			self AndCq: 16r3FFFF7 R: t1.
			self MoveR: t1 R: t2.
			self CmpCq: 0 R: t2.
			jumpTrue := self JumpZero: 0.
			self MoveCq: 0 R: t2.
			jumpNext := self Jump: 0.
			jumpTrue jmpTarget: self Label.
			self MoveCq: 1 R: t2.
			jumpNext jmpTarget: self Label.
			self CmpCq: 0 R: t1.
			jump2 := self JumpNonZero: 0.
			self MoveM64: 8 r: t0 R: t2.
			self MoveR: t2 R: t0.
			jump3 := self Jump: b227.
			currentBlock := self Label.
			jump1 jmpTarget: currentBlock.
			jump2 jmpTarget: currentBlock.
			self ssPushConstant:
				(coInterpreter int64AtPointer:  (((coInterpreter int64AtPointer:  ((methodObj + 8) + ((0 + LiteralStart) << 3))) + 8) + (ValueIndex << 3))).
			^ 0 ].
	self ssPushConstant:
		(coInterpreter int64AtPointer:  (((coInterpreter int64AtPointer:  ((methodObj + 8) + ((0 + LiteralStart) << 3))) + 8) + (ValueIndex << 3))).
	^ 0
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_pushReceiverBytecode [
	"AutoGenerated by Druid"

	| live currentBlock t0 |
	live := 0.
	self ensureReceiverResultRegContainsSelf.
	t0 := self allocateRegNotConflictingWith: live ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t0).
	self MoveR: ReceiverResultReg R: t0.
	self ssPushRegister: t0.
	^ 0
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_pushReceiverVariableBytecode [
	"AutoGenerated by Druid"

	| live currentBlock t0 |
	live := 0.
	self ensureReceiverResultRegContainsSelf.
	t0 := self allocateRegNotConflictingWith: live ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t0).
	self MoveR: ReceiverResultReg R: t0.
	self ssPushBase: t0 offset: 16.
	^ 0
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_pushTemporaryVariableBytecode [
	"AutoGenerated by Druid"

	| live currentBlock t0 |
	live := 0.
	t0 := self allocateRegNotConflictingWith: live ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t0).
	(self simStackTempAt: 2) copyToReg: t0.
	self ssPushRegister: t0.
	^ 0
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_returnFalse [
	"AutoGenerated by Druid"

	| live currentBlock t0 |
	live := 0.
	t0 := self allocateRegNotConflictingWith: live ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t0).
	self genMoveConstant: objectMemory falseObject R: t0.
	self MoveR: t0 R: ReceiverResultReg.
	self genUpArrowReturn.
	^ 0
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_returnNil [
	"AutoGenerated by Druid"

	| live currentBlock t0 |
	live := 0.
	t0 := self allocateRegNotConflictingWith: live ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t0).
	self genMoveConstant: objectMemory nilObject R: t0.
	self MoveR: t0 R: ReceiverResultReg.
	self genUpArrowReturn.
	^ 0
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_returnReceiver [
	"AutoGenerated by Druid"

	| live currentBlock t0 |
	live := 0.
	self ensureReceiverResultRegContainsSelf.
	t0 := self allocateRegNotConflictingWith: live ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t0).
	self MoveR: ReceiverResultReg R: t0.
	self MoveR: t0 R: ReceiverResultReg.
	self genUpArrowReturn.
	^ 0
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_returnTopFromMethod [
	"AutoGenerated by Druid"

	| live currentBlock t0 |
	live := 0.
	t0 := self allocateRegNotConflictingWith: live ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t0).
	(self ssValue: 0) copyToReg: t0.
	self ssPop: 1.
	self MoveR: t0 R: ReceiverResultReg.
	self genUpArrowReturn.
	^ 0
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_returnTrue [
	"AutoGenerated by Druid"

	| live currentBlock t0 |
	live := 0.
	t0 := self allocateRegNotConflictingWith: live ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t0).
	self genMoveConstant: objectMemory trueObject R: t0.
	self MoveR: t0 R: ReceiverResultReg.
	self genUpArrowReturn.
	^ 0
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_sendLiteralSelector0ArgsBytecode [
	"AutoGenerated by Druid"

	| live currentBlock |
	live := 0.
	self marshallSendArguments: 0.
	self genMarshalledSend: 1 numArgs: 0 sendTable: ordinarySendTrampolines.
	^ 0
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_shortConditionalJumpFalse [
	"AutoGenerated by Druid"

	| t0 jump1 currentBlock jump2 live |
	live := 0.
	self annotateBytecode: self Label.
	t0 := self allocateRegNotConflictingWith: live ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t0).
	(self ssValue: 0) copyToReg: t0.
	self ssPop: 1.
	self ssFlushStack.
	self CmpCq: objectMemory falseObject R: t0.
	jump1 := self JumpNonZero: 0.
	self Jump: (self ensureFixupAt: bytecodePC + 0 + 1 + 1).
	deadCode := true.
	jump2 := self Jump: 0.
	deadCode := false.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	self CmpCq: objectMemory trueObject R: t0.
	jump1 := self JumpZero: 0.
	self MoveR: t0 R: TempReg.
	self CallRT: ceSendMustBeBooleanTrampoline.
	currentBlock := self Label.
	jump2 jmpTarget: currentBlock.
	jump1 jmpTarget: currentBlock.
	^ 0
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_shortConditionalJumpTrue [
	"AutoGenerated by Druid"

	| t0 jump1 currentBlock jump2 live |
	live := 0.
	self annotateBytecode: self Label.
	t0 := self allocateRegNotConflictingWith: live ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t0).
	(self ssValue: 0) copyToReg: t0.
	self ssPop: 1.
	self ssFlushStack.
	self CmpCq: objectMemory trueObject R: t0.
	jump1 := self JumpNonZero: 0.
	self Jump: (self ensureFixupAt: bytecodePC + 0 + 1 + 1).
	deadCode := true.
	jump2 := self Jump: 0.
	deadCode := false.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	self CmpCq: objectMemory falseObject R: t0.
	jump1 := self JumpZero: 0.
	self MoveR: t0 R: TempReg.
	self CallRT: ceSendMustBeBooleanTrampoline.
	currentBlock := self Label.
	jump2 jmpTarget: currentBlock.
	jump1 jmpTarget: currentBlock.
	^ 0
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_shortUnconditionalJump [
	"AutoGenerated by Druid"

	| live currentBlock |
	live := 0.
	self ssFlushStack.
	self Jump: (self ensureFixupAt: bytecodePC + 0 + 1 + 1).
	deadCode := true.
	^ 0
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_storeAndPopReceiverVariableBytecode [
	"AutoGenerated by Druid"

	| jump1 jump7 jumpNext t1 jump6 jump3 jump9 currentBlock t0 jump5 jump2 jumpTrue jump8 live t2 jump4 |
	live := 0.
	self annotateBytecode: self Label.
	self ensureReceiverResultRegContainsSelf.
	t0 := self allocateRegNotConflictingWith: live ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t0).
	self MoveR: ReceiverResultReg R: t0.
	t1 := self allocateRegNotConflictingWith: live ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t1).
	(self ssValue: 0) copyToReg: t1.
	t2 := self allocateRegNotConflictingWith: live ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t2).
	self MoveM64: 0 r: t0 R: t2.
	self ArithmeticShiftRightCq: 23 R: t2.
	self AndCq: 1 R: t2.
	self ssFlushStack.
	self CmpCq: 0 R: t2.
	jump1 := self JumpZero: 0.
	self deoptimize.
	jump2 := self Jump: 0.
	deadCode := false.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	self ssPop: 1.
	self MoveR: t0 R: t2.
	self AndCq: 7 R: t2.
	self CmpCq: 0 R: t2.
	jump1 := self JumpNonZero: 0.
	self MoveR: t0 R: t2.
	self AndCq: objectMemory getMemoryMap getSpaceMaskToUse R: t2.
	self CmpCq: objectMemory getMemoryMap getOldSpaceMask R: t2.
	jump3 := self JumpNonZero: 0.
	self MoveR: t1 R: t2.
	self AndCq: 7 R: t2.
	self CmpCq: 0 R: t2.
	jump4 := self JumpNonZero: 0.
	self MoveR: t1 R: t2.
	self AndCq: objectMemory getMemoryMap getSpaceMaskToUse R: t2.
	self CmpCq: objectMemory getMemoryMap getNewSpaceMask R: t2.
	jump5 := self JumpNonZero: 0.
	self MoveR: t1 R: t2.
	self CmpCq: objectMemory getMemoryMap getNewSpaceStart R: t2.
	jumpTrue := self JumpGreaterOrEqual: 0.
	self MoveCq: 0 R: t2.
	jumpNext := self Jump: 0.
	jumpTrue jmpTarget: self Label.
	self MoveCq: 1 R: t2.
	jumpNext jmpTarget: self Label.
	self CmpCq: 1 R: t2.
	jump6 := self JumpNonZero: 0.
	self MoveM64: 0 r: t0 R: t2.
	self ArithmeticShiftRightCq: 29 R: t2.
	self AndCq: 1 R: t2.
	self CmpCq: 0 R: t2.
	jump7 := self JumpNonZero: 0.
	self MoveR: t0 R: TempReg.
	backEnd saveAndRestoreLinkRegAround: [ self CallRT: ceStoreCheckTrampoline ].
	self TstCq: 7 R: t1.
	jump8 := self JumpNonZero: 0.
	jump9 := self JumpZero: 0.
	currentBlock := self Label.
	jump5 jmpTarget: currentBlock.
	self MoveCq: 0 R: t2.
	currentBlock := self Label.
	jump6 jmpTarget: currentBlock.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	jump3 jmpTarget: currentBlock.
	jump4 jmpTarget: currentBlock.
	jump7 jmpTarget: currentBlock.
	self TstCq: 7 R: t1.
	jump7 := self JumpNonZero: 0.
	currentBlock := self Label.
	jump9 jmpTarget: currentBlock.
	self CmpCq: objectMemory nilObject R: t1.
	jump9 := self JumpBelow: 0.
	self MoveR: t1 R: t2.
	self CmpCq: objectMemory trueObject R: t2.
	jumpTrue := self JumpLessOrEqual: 0.
	self MoveCq: 0 R: t2.
	jumpNext := self Jump: 0.
	jumpTrue jmpTarget: self Label.
	self MoveCq: 1 R: t2.
	jumpNext jmpTarget: self Label.
	jump4 := self Jump: 0.
	currentBlock := self Label.
	jump9 jmpTarget: currentBlock.
	self MoveCq: 0 R: t2.
	currentBlock := self Label.
	jump4 jmpTarget: currentBlock.
	self CmpCq: 1 R: t2.
	jump4 := self JumpZero: 0.
	self CmpCq: objectMemory getMemoryMap getNewSpaceStart R: t1.
	jump9 := self JumpLess: 0.
	self MoveM64: 0 r: t0 R: t2.
	self ArithmeticShiftRightCq: 29 R: t2.
	self AndCq: 1 R: t2.
	self CmpCq: 0 R: t2.
	jump3 := self JumpNonZero: 0.
	self MoveR: t0 R: t2.
	self AndCq: 7 R: t2.
	self CmpCq: 0 R: t2.
	jump1 := self JumpNonZero: 0.
	self MoveR: t0 R: t2.
	self AndCq: objectMemory getMemoryMap getSpaceMaskToUse R: t2.
	self CmpCq: objectMemory getMemoryMap getPermSpaceMask R: t2.
	jumpTrue := self JumpZero: 0.
	self MoveCq: 0 R: t2.
	jumpNext := self Jump: 0.
	jumpTrue jmpTarget: self Label.
	self MoveCq: 1 R: t2.
	jumpNext jmpTarget: self Label.
	jump6 := self Jump: 0.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	self MoveCq: 0 R: t2.
	currentBlock := self Label.
	jump6 jmpTarget: currentBlock.
	self CmpCq: 1 R: t2.
	jump6 := self JumpNonZero: 0.
	self MoveR: t1 R: t2.
	self AndCq: objectMemory getMemoryMap getSpaceMaskToUse R: t2.
	self CmpCq: objectMemory getMemoryMap getPermSpaceMask R: t2.
	jump1 := self JumpZero: 0.
	self MoveR: t0 R: TempReg.
	backEnd saveAndRestoreLinkRegAround: [ self CallRT: ceStoreCheckTrampoline ].
	currentBlock := self Label.
	jump8 jmpTarget: currentBlock.
	jump7 jmpTarget: currentBlock.
	jump4 jmpTarget: currentBlock.
	jump9 jmpTarget: currentBlock.
	jump3 jmpTarget: currentBlock.
	jump6 jmpTarget: currentBlock.
	jump1 jmpTarget: currentBlock.
	self MoveR: t1 M64: 8 r: t0.
	currentBlock := self Label.
	jump2 jmpTarget: currentBlock.
	^ 0
]

{ #category : #query }
DruidTestRTLCompiler >> hasAnnotatedAbstractInstructions: annotation [

	0 to: opcodeIndex - 1 do: [ :i |
		| instruction |
		instruction := self abstractInstructionAt: i.
		instruction annotation = annotation ifTrue: [ ^ true ] ].
	^ false
]

{ #category : #'trait candidates' }
DruidTestRTLCompiler >> initialize [

	super initialize.
	deadCode := false
]

{ #category : #generated }
DruidTestRTLCompiler >> numRegArgs [

	^ 2 "Hardcoded?"
]

{ #category : #compatibility }
DruidTestRTLCompiler >> shouldAnnotateObjectReference: anOop [
	"Objects in newSpace or oldSpace except nil, true, false & classTableRootObj need to be annotated."
	^(objectMemory isNonImmediate: anOop)
	  and: [(self oop: anOop isGreaterThan: objectMemory classTableRootObj)
		or: [self oop: anOop isLessThan: objectMemory nilObject]]
]

{ #category : #generated }
DruidTestRTLCompiler >> smallIntegerSpecialisedPreamble [ 

	self mclassIsSmallInteger ifFalse:
		[^UnimplementedPrimitive].
]
