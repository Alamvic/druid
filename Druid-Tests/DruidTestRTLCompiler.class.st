Class {
	#name : #DruidTestRTLCompiler,
	#superclass : #DruidJIT,
	#category : #'Druid-Tests'
}

{ #category : #'class initialization' }
DruidTestRTLCompiler class >> bytecodeTable [

	<generated>
	^ {
		  { 1. 0. 0. #gen_BytecodeWithNoFrameInstVarRefAnnotation.
		  #isInstVarRef. #needsFrameNever:. 1 }.
		  { 1. 77. 77. #gen_BytecodeWithNoFrameInstVarRefAnnotation }.
		  { 1. 90. 90. #gen_BytecodeWithNoFrameInstVarRefAnnotation }.
		  { 1. 91. 91. #gen_BytecodeWithNoFrameInstVarRefAnnotation }.
		  { 1. 176. 176. #gen_BytecodeWithNoFrameInstVarRefAnnotation }.
		  { 1. 184. 184. #gen_BytecodeWithNoFrameInstVarRefAnnotation }.
		  { 1. 192. 192. #gen_BytecodeWithNoFrameInstVarRefAnnotation } }
]

{ #category : #'class initialization' }
DruidTestRTLCompiler class >> initializeBytecodeTableForSistaV1 [

	<generated>
	numPushNilsFunction := #sistaV1:Num:Push:Nils:.
	pushNilSizeFunction := #sistaV1PushNilSize:numInitialNils:.
	BytecodeSetHasDirectedSuperSend := true.
	BytecodeSetHasExtensions := true.
	FirstSpecialSelector := 96.
	NumSpecialSelectors := 32.
	self generatorTableFrom: self bytecodeTable
]

{ #category : #'class initialization' }
DruidTestRTLCompiler class >> initializePrimitiveTable [

	<generated>
	MaxCompiledPrimitiveIndex := 0.
	primitiveTable := CArrayAccessor on:
		                  (Array new: MaxCompiledPrimitiveIndex + 1).
	self table: primitiveTable from: self primitiveTableArray.
	^ primitiveTable
]

{ #category : #'class initialization' }
DruidTestRTLCompiler class >> primitiveTableArray [

	<generated>
	^ {  }
]

{ #category : #deployment }
DruidTestRTLCompiler class >> replaceMethodOnJIT: selector [

| druidMethod cogMethod |
druidMethod := DruidTestRTLCompiler lookupSelector: (#gen_, selector).
cogMethod := druidMethod ast copy.

"Change selector"
cogMethod selector: (#gen, selector capitalized).

"Replace self by cogit variable"
cogMethod nodesDo: [ :n | n isSelfVariable ifTrue: [ n replaceWith: (RBVariableNode named: 'cogit') ] ].

"Add type anotations"
cogMethod pragmas: { }.
cogMethod temporaries do: [ :temp | |args|	
	args := {temp name. #'AbstractInstruction *'} collect: [ :arg | RBLiteralNode value: arg ].
	cogMethod addPragma: (RBPragmaNode selector: #var:type: arguments: args).	
].


CogObjectRepresentation compile: cogMethod formattedCode classified: 'primitive generators'
]

{ #category : #compiling }
DruidTestRTLCompiler >> compileAbort [
	"Fake method"

	stackOverflowCall := self Nop
]

{ #category : #compiling }
DruidTestRTLCompiler >> compileEntry [
	"Fake method"

	
]

{ #category : #accessing }
DruidTestRTLCompiler >> deadCode [

	^ deadCode
]

{ #category : #accessing }
DruidTestRTLCompiler >> extA [

	<doNotGenerate>
	^ extA
]

{ #category : #accessing }
DruidTestRTLCompiler >> extA: anObject [

	<doNotGenerate>
	^ extA := anObject
]

{ #category : #accessing }
DruidTestRTLCompiler >> extB [

	<doNotGenerate>
	^ extB
]

{ #category : #accessing }
DruidTestRTLCompiler >> extB: anObject [

	<doNotGenerate>
	^ extB := anObject
]

{ #category : #'primitive generators' }
DruidTestRTLCompiler >> genPrimReturn [

	self RetN: 0
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_BytecodeWithNoFrameInstVarRefAnnotation [
	"AutoGenerated by Druid"

	| live currentBlock |
	live := 0.
	^ 0
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_BytecodeWithNoFrameInstVarRefAnnotation0 [
	"AutoGenerated by Druid"

	| live currentBlock |
	live := 0.
	^ 0
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_BytecodeWithNoFrameInstVarRefAnnotation1 [
	"AutoGenerated by Druid"

	| live currentBlock |
	live := 0.
	^ 0
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_BytecodeWithNoFrameInstVarRefAnnotation2 [
	"AutoGenerated by Druid"

	| live currentBlock |
	live := 0.
	^ 0
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_BytecodeWithNoFrameInstVarRefAnnotation3 [
	"AutoGenerated by Druid"

	| live currentBlock |
	live := 0.
	^ 0
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_PrimitiveAdd [
	"AutoGenerated by Druid"

	| jump1 jump2 currentBlock |
	self mclassIsSmallInteger ifFalse: [ ^ UnimplementedPrimitive ].
	self MoveR: ReceiverResultReg R: TempReg.
	self MoveR: Arg0Reg R: ClassReg.
	self TstCq: 1 R: ClassReg.
	jump1 := self JumpZero: 0.
	self AddCq:  -1 R: ClassReg.
	self AddR: TempReg R: ClassReg.
	jump2 := self JumpOverflow: 0.
	self MoveR: ClassReg R: ReceiverResultReg.
	self genPrimReturn.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	jump2 jmpTarget: currentBlock.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_PushReceiverVariableBytecode [
	"AutoGenerated by Druid"

	| live currentBlock t0 |
	live := 0.
	self ensureReceiverResultRegContainsSelf.
	t0 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t0).
	self MoveR: ReceiverResultReg R: t0.
	self ssPushBase: t0 offset: 8.
	^ 0
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_ReturnTopFromMethod [
	"AutoGenerated by Druid"

	| live currentBlock t0 |
	live := 0.
	t0 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t0).
	(self ssValue: 0) copyToReg: t0.
	self ssPop: 1.
	self MoveR: t0 R: ReceiverResultReg.
	self genUpArrowReturn.
	^ 0
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_StoreAndPopReceiverVariableBytecode0 [
	"AutoGenerated by Druid"

	| jump1 jump7 jumpNext t1 jump6 jump3 jump9 currentBlock t0 jump5 jump2 jumpTrue jump8 live t2 jump4 |
	live := 0.
	self annotateBytecode: self Label.
	self ensureReceiverResultRegContainsSelf.
	t0 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t0).
	self MoveR: ReceiverResultReg R: t0.
	t1 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t1).
	(self ssValue: 0) copyToReg: t1.
	t2 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t2).
	self MoveM64: 0 r: t0 R: t2.
	self ArithmeticShiftRightCq: 23 R: t2.
	self AndCq: 1 R: t2.
	self ssFlushStack.
	self CmpCq: 0 R: t2.
	jump1 := self JumpZero: 0.
	self deoptimize.
	jump2 := self Jump: 0.
	deadCode := false.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	self ssPop: 1.
	self MoveR: t0 R: t2.
	self AndCq: 7 R: t2.
	self CmpCq: 0 R: t2.
	jump1 := self JumpNonZero: 0.
	self MoveR: t0 R: t2.
	self AndCq: objectMemory getMemoryMap getSpaceMaskToUse R: t2.
	self CmpCq: objectMemory getMemoryMap getOldSpaceMask R: t2.
	jump3 := self JumpNonZero: 0.
	self MoveR: t1 R: t2.
	self AndCq: 7 R: t2.
	self CmpCq: 0 R: t2.
	jump4 := self JumpNonZero: 0.
	self MoveR: t1 R: t2.
	self AndCq: objectMemory getMemoryMap getSpaceMaskToUse R: t2.
	self CmpCq: objectMemory getMemoryMap getNewSpaceMask R: t2.
	jump5 := self JumpNonZero: 0.
	self MoveR: t1 R: t2.
	self CmpCq: objectMemory getMemoryMap getNewSpaceStart R: t2.
	jumpTrue := self JumpAboveOrEqual: 0.
	self MoveCq: 0 R: t2.
	jumpNext := self Jump: 0.
	jumpTrue jmpTarget: self Label.
	self MoveCq: 1 R: t2.
	jumpNext jmpTarget: self Label.
	self CmpCq: 1 R: t2.
	jump6 := self JumpNonZero: 0.
	self MoveM64: 0 r: t0 R: t2.
	self ArithmeticShiftRightCq: 29 R: t2.
	self AndCq: 1 R: t2.
	self CmpCq: 0 R: t2.
	jump7 := self JumpNonZero: 0.
	self MoveR: t0 R: TempReg.
	backEnd saveAndRestoreLinkRegAround: [
		self CallRT: ceStoreCheckTrampoline ].
	self TstCq: 7 R: t1.
	jump8 := self JumpNonZero: 0.
	jump9 := self JumpZero: 0.
	currentBlock := self Label.
	jump5 jmpTarget: currentBlock.
	self MoveCq: 0 R: t2.
	currentBlock := self Label.
	jump6 jmpTarget: currentBlock.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	jump3 jmpTarget: currentBlock.
	jump4 jmpTarget: currentBlock.
	jump7 jmpTarget: currentBlock.
	self TstCq: 7 R: t1.
	jump7 := self JumpNonZero: 0.
	currentBlock := self Label.
	jump9 jmpTarget: currentBlock.
	self CmpCq: objectMemory nilObject R: t1.
	jump9 := self JumpBelow: 0.
	self MoveR: t1 R: t2.
	self CmpCq: objectMemory trueObject R: t2.
	jumpTrue := self JumpBelowOrEqual: 0.
	self MoveCq: 0 R: t2.
	jumpNext := self Jump: 0.
	jumpTrue jmpTarget: self Label.
	self MoveCq: 1 R: t2.
	jumpNext jmpTarget: self Label.
	jump4 := self Jump: 0.
	currentBlock := self Label.
	jump9 jmpTarget: currentBlock.
	self MoveCq: 0 R: t2.
	currentBlock := self Label.
	jump4 jmpTarget: currentBlock.
	self CmpCq: 1 R: t2.
	jump4 := self JumpZero: 0.
	self CmpCq: objectMemory getMemoryMap getNewSpaceStart R: t1.
	jump9 := self JumpBelow: 0.
	self MoveM64: 0 r: t0 R: t2.
	self ArithmeticShiftRightCq: 29 R: t2.
	self AndCq: 1 R: t2.
	self CmpCq: 0 R: t2.
	jump3 := self JumpNonZero: 0.
	self MoveR: t0 R: t2.
	self AndCq: 7 R: t2.
	self CmpCq: 0 R: t2.
	jump1 := self JumpNonZero: 0.
	self MoveR: t0 R: t2.
	self AndCq: objectMemory getMemoryMap getSpaceMaskToUse R: t2.
	self CmpCq: objectMemory getMemoryMap getPermSpaceMask R: t2.
	jumpTrue := self JumpZero: 0.
	self MoveCq: 0 R: t2.
	jumpNext := self Jump: 0.
	jumpTrue jmpTarget: self Label.
	self MoveCq: 1 R: t2.
	jumpNext jmpTarget: self Label.
	jump6 := self Jump: 0.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	self MoveCq: 0 R: t2.
	currentBlock := self Label.
	jump6 jmpTarget: currentBlock.
	self CmpCq: 1 R: t2.
	jump6 := self JumpNonZero: 0.
	self MoveR: t1 R: t2.
	self AndCq: objectMemory getMemoryMap getSpaceMaskToUse R: t2.
	self CmpCq: objectMemory getMemoryMap getPermSpaceMask R: t2.
	jump1 := self JumpZero: 0.
	self MoveR: t0 R: TempReg.
	backEnd saveAndRestoreLinkRegAround: [
		self CallRT: ceStoreCheckTrampoline ].
	currentBlock := self Label.
	jump8 jmpTarget: currentBlock.
	jump7 jmpTarget: currentBlock.
	jump4 jmpTarget: currentBlock.
	jump9 jmpTarget: currentBlock.
	jump3 jmpTarget: currentBlock.
	jump6 jmpTarget: currentBlock.
	jump1 jmpTarget: currentBlock.
	self MoveR: t1 M64: 8 r: t0.
	currentBlock := self Label.
	jump2 jmpTarget: currentBlock.
	^ 0
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_StoreAndPopReceiverVariableBytecode1 [
	"AutoGenerated by Druid"

	| jump1 jump7 jumpNext t1 jump6 jump3 jump9 currentBlock t0 jump5 jump2 jumpTrue jump8 live t2 jump4 |
	live := 0.
	self annotateBytecode: self Label.
	self ensureReceiverResultRegContainsSelf.
	t0 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t0).
	self MoveR: ReceiverResultReg R: t0.
	t1 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t1).
	(self ssValue: 0) copyToReg: t1.
	t2 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t2).
	self MoveM64: 0 r: t0 R: t2.
	self ArithmeticShiftRightCq: 23 R: t2.
	self AndCq: 1 R: t2.
	self ssFlushStack.
	self CmpCq: 0 R: t2.
	jump1 := self JumpZero: 0.
	self deoptimize.
	jump2 := self Jump: 0.
	deadCode := false.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	self ssPop: 1.
	self MoveR: t0 R: t2.
	self AndCq: 7 R: t2.
	self CmpCq: 0 R: t2.
	jump1 := self JumpNonZero: 0.
	self MoveR: t0 R: t2.
	self AndCq: objectMemory getMemoryMap getSpaceMaskToUse R: t2.
	self CmpCq: objectMemory getMemoryMap getOldSpaceMask R: t2.
	jump3 := self JumpNonZero: 0.
	self MoveR: t1 R: t2.
	self AndCq: 7 R: t2.
	self CmpCq: 0 R: t2.
	jump4 := self JumpNonZero: 0.
	self MoveR: t1 R: t2.
	self AndCq: objectMemory getMemoryMap getSpaceMaskToUse R: t2.
	self CmpCq: objectMemory getMemoryMap getNewSpaceMask R: t2.
	jump5 := self JumpNonZero: 0.
	self MoveR: t1 R: t2.
	self CmpCq: objectMemory getMemoryMap getNewSpaceStart R: t2.
	jumpTrue := self JumpAboveOrEqual: 0.
	self MoveCq: 0 R: t2.
	jumpNext := self Jump: 0.
	jumpTrue jmpTarget: self Label.
	self MoveCq: 1 R: t2.
	jumpNext jmpTarget: self Label.
	self CmpCq: 1 R: t2.
	jump6 := self JumpNonZero: 0.
	self MoveM64: 0 r: t0 R: t2.
	self ArithmeticShiftRightCq: 29 R: t2.
	self AndCq: 1 R: t2.
	self CmpCq: 0 R: t2.
	jump7 := self JumpNonZero: 0.
	self MoveR: t0 R: TempReg.
	backEnd saveAndRestoreLinkRegAround: [
		self CallRT: ceStoreCheckTrampoline ].
	self TstCq: 7 R: t1.
	jump8 := self JumpNonZero: 0.
	jump9 := self JumpZero: 0.
	currentBlock := self Label.
	jump5 jmpTarget: currentBlock.
	self MoveCq: 0 R: t2.
	currentBlock := self Label.
	jump6 jmpTarget: currentBlock.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	jump3 jmpTarget: currentBlock.
	jump4 jmpTarget: currentBlock.
	jump7 jmpTarget: currentBlock.
	self TstCq: 7 R: t1.
	jump7 := self JumpNonZero: 0.
	currentBlock := self Label.
	jump9 jmpTarget: currentBlock.
	self CmpCq: objectMemory nilObject R: t1.
	jump9 := self JumpBelow: 0.
	self MoveR: t1 R: t2.
	self CmpCq: objectMemory trueObject R: t2.
	jumpTrue := self JumpBelowOrEqual: 0.
	self MoveCq: 0 R: t2.
	jumpNext := self Jump: 0.
	jumpTrue jmpTarget: self Label.
	self MoveCq: 1 R: t2.
	jumpNext jmpTarget: self Label.
	jump4 := self Jump: 0.
	currentBlock := self Label.
	jump9 jmpTarget: currentBlock.
	self MoveCq: 0 R: t2.
	currentBlock := self Label.
	jump4 jmpTarget: currentBlock.
	self CmpCq: 1 R: t2.
	jump4 := self JumpZero: 0.
	self CmpCq: objectMemory getMemoryMap getNewSpaceStart R: t1.
	jump9 := self JumpBelow: 0.
	self MoveM64: 0 r: t0 R: t2.
	self ArithmeticShiftRightCq: 29 R: t2.
	self AndCq: 1 R: t2.
	self CmpCq: 0 R: t2.
	jump3 := self JumpNonZero: 0.
	self MoveR: t0 R: t2.
	self AndCq: 7 R: t2.
	self CmpCq: 0 R: t2.
	jump1 := self JumpNonZero: 0.
	self MoveR: t0 R: t2.
	self AndCq: objectMemory getMemoryMap getSpaceMaskToUse R: t2.
	self CmpCq: objectMemory getMemoryMap getPermSpaceMask R: t2.
	jumpTrue := self JumpZero: 0.
	self MoveCq: 0 R: t2.
	jumpNext := self Jump: 0.
	jumpTrue jmpTarget: self Label.
	self MoveCq: 1 R: t2.
	jumpNext jmpTarget: self Label.
	jump6 := self Jump: 0.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	self MoveCq: 0 R: t2.
	currentBlock := self Label.
	jump6 jmpTarget: currentBlock.
	self CmpCq: 1 R: t2.
	jump6 := self JumpNonZero: 0.
	self MoveR: t1 R: t2.
	self AndCq: objectMemory getMemoryMap getSpaceMaskToUse R: t2.
	self CmpCq: objectMemory getMemoryMap getPermSpaceMask R: t2.
	jump1 := self JumpZero: 0.
	self MoveR: t0 R: TempReg.
	backEnd saveAndRestoreLinkRegAround: [
		self CallRT: ceStoreCheckTrampoline ].
	currentBlock := self Label.
	jump8 jmpTarget: currentBlock.
	jump7 jmpTarget: currentBlock.
	jump4 jmpTarget: currentBlock.
	jump9 jmpTarget: currentBlock.
	jump3 jmpTarget: currentBlock.
	jump6 jmpTarget: currentBlock.
	jump1 jmpTarget: currentBlock.
	self MoveR: t1 M64: 16 r: t0.
	currentBlock := self Label.
	jump2 jmpTarget: currentBlock.
	^ 0
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_StoreAndPopReceiverVariableBytecode2 [
	"AutoGenerated by Druid"

	| jump1 jump7 jumpNext t1 jump6 jump3 jump9 currentBlock t0 jump5 jump2 jumpTrue jump8 live t2 jump4 |
	live := 0.
	self annotateBytecode: self Label.
	self ensureReceiverResultRegContainsSelf.
	t0 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t0).
	self MoveR: ReceiverResultReg R: t0.
	t1 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t1).
	(self ssValue: 0) copyToReg: t1.
	t2 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t2).
	self MoveM64: 0 r: t0 R: t2.
	self ArithmeticShiftRightCq: 23 R: t2.
	self AndCq: 1 R: t2.
	self ssFlushStack.
	self CmpCq: 0 R: t2.
	jump1 := self JumpZero: 0.
	self deoptimize.
	jump2 := self Jump: 0.
	deadCode := false.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	self ssPop: 1.
	self MoveR: t0 R: t2.
	self AndCq: 7 R: t2.
	self CmpCq: 0 R: t2.
	jump1 := self JumpNonZero: 0.
	self MoveR: t0 R: t2.
	self AndCq: objectMemory getMemoryMap getSpaceMaskToUse R: t2.
	self CmpCq: objectMemory getMemoryMap getOldSpaceMask R: t2.
	jump3 := self JumpNonZero: 0.
	self MoveR: t1 R: t2.
	self AndCq: 7 R: t2.
	self CmpCq: 0 R: t2.
	jump4 := self JumpNonZero: 0.
	self MoveR: t1 R: t2.
	self AndCq: objectMemory getMemoryMap getSpaceMaskToUse R: t2.
	self CmpCq: objectMemory getMemoryMap getNewSpaceMask R: t2.
	jump5 := self JumpNonZero: 0.
	self MoveR: t1 R: t2.
	self CmpCq: objectMemory getMemoryMap getNewSpaceStart R: t2.
	jumpTrue := self JumpAboveOrEqual: 0.
	self MoveCq: 0 R: t2.
	jumpNext := self Jump: 0.
	jumpTrue jmpTarget: self Label.
	self MoveCq: 1 R: t2.
	jumpNext jmpTarget: self Label.
	self CmpCq: 1 R: t2.
	jump6 := self JumpNonZero: 0.
	self MoveM64: 0 r: t0 R: t2.
	self ArithmeticShiftRightCq: 29 R: t2.
	self AndCq: 1 R: t2.
	self CmpCq: 0 R: t2.
	jump7 := self JumpNonZero: 0.
	self MoveR: t0 R: TempReg.
	backEnd saveAndRestoreLinkRegAround: [
		self CallRT: ceStoreCheckTrampoline ].
	self TstCq: 7 R: t1.
	jump8 := self JumpNonZero: 0.
	jump9 := self JumpZero: 0.
	currentBlock := self Label.
	jump5 jmpTarget: currentBlock.
	self MoveCq: 0 R: t2.
	currentBlock := self Label.
	jump6 jmpTarget: currentBlock.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	jump3 jmpTarget: currentBlock.
	jump4 jmpTarget: currentBlock.
	jump7 jmpTarget: currentBlock.
	self TstCq: 7 R: t1.
	jump7 := self JumpNonZero: 0.
	currentBlock := self Label.
	jump9 jmpTarget: currentBlock.
	self CmpCq: objectMemory nilObject R: t1.
	jump9 := self JumpBelow: 0.
	self MoveR: t1 R: t2.
	self CmpCq: objectMemory trueObject R: t2.
	jumpTrue := self JumpBelowOrEqual: 0.
	self MoveCq: 0 R: t2.
	jumpNext := self Jump: 0.
	jumpTrue jmpTarget: self Label.
	self MoveCq: 1 R: t2.
	jumpNext jmpTarget: self Label.
	jump4 := self Jump: 0.
	currentBlock := self Label.
	jump9 jmpTarget: currentBlock.
	self MoveCq: 0 R: t2.
	currentBlock := self Label.
	jump4 jmpTarget: currentBlock.
	self CmpCq: 1 R: t2.
	jump4 := self JumpZero: 0.
	self CmpCq: objectMemory getMemoryMap getNewSpaceStart R: t1.
	jump9 := self JumpBelow: 0.
	self MoveM64: 0 r: t0 R: t2.
	self ArithmeticShiftRightCq: 29 R: t2.
	self AndCq: 1 R: t2.
	self CmpCq: 0 R: t2.
	jump3 := self JumpNonZero: 0.
	self MoveR: t0 R: t2.
	self AndCq: 7 R: t2.
	self CmpCq: 0 R: t2.
	jump1 := self JumpNonZero: 0.
	self MoveR: t0 R: t2.
	self AndCq: objectMemory getMemoryMap getSpaceMaskToUse R: t2.
	self CmpCq: objectMemory getMemoryMap getPermSpaceMask R: t2.
	jumpTrue := self JumpZero: 0.
	self MoveCq: 0 R: t2.
	jumpNext := self Jump: 0.
	jumpTrue jmpTarget: self Label.
	self MoveCq: 1 R: t2.
	jumpNext jmpTarget: self Label.
	jump6 := self Jump: 0.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	self MoveCq: 0 R: t2.
	currentBlock := self Label.
	jump6 jmpTarget: currentBlock.
	self CmpCq: 1 R: t2.
	jump6 := self JumpNonZero: 0.
	self MoveR: t1 R: t2.
	self AndCq: objectMemory getMemoryMap getSpaceMaskToUse R: t2.
	self CmpCq: objectMemory getMemoryMap getPermSpaceMask R: t2.
	jump1 := self JumpZero: 0.
	self MoveR: t0 R: TempReg.
	backEnd saveAndRestoreLinkRegAround: [
		self CallRT: ceStoreCheckTrampoline ].
	currentBlock := self Label.
	jump8 jmpTarget: currentBlock.
	jump7 jmpTarget: currentBlock.
	jump4 jmpTarget: currentBlock.
	jump9 jmpTarget: currentBlock.
	jump3 jmpTarget: currentBlock.
	jump6 jmpTarget: currentBlock.
	jump1 jmpTarget: currentBlock.
	self MoveR: t1 M64: 24 r: t0.
	currentBlock := self Label.
	jump2 jmpTarget: currentBlock.
	^ 0
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_StoreAndPopReceiverVariableBytecode3 [
	"AutoGenerated by Druid"

	| jump1 jump7 jumpNext t1 jump6 jump3 jump9 currentBlock t0 jump5 jump2 jumpTrue jump8 live t2 jump4 |
	live := 0.
	self annotateBytecode: self Label.
	self ensureReceiverResultRegContainsSelf.
	t0 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t0).
	self MoveR: ReceiverResultReg R: t0.
	t1 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t1).
	(self ssValue: 0) copyToReg: t1.
	t2 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t2).
	self MoveM64: 0 r: t0 R: t2.
	self ArithmeticShiftRightCq: 23 R: t2.
	self AndCq: 1 R: t2.
	self ssFlushStack.
	self CmpCq: 0 R: t2.
	jump1 := self JumpZero: 0.
	self deoptimize.
	jump2 := self Jump: 0.
	deadCode := false.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	self ssPop: 1.
	self MoveR: t0 R: t2.
	self AndCq: 7 R: t2.
	self CmpCq: 0 R: t2.
	jump1 := self JumpNonZero: 0.
	self MoveR: t0 R: t2.
	self AndCq: objectMemory getMemoryMap getSpaceMaskToUse R: t2.
	self CmpCq: objectMemory getMemoryMap getOldSpaceMask R: t2.
	jump3 := self JumpNonZero: 0.
	self MoveR: t1 R: t2.
	self AndCq: 7 R: t2.
	self CmpCq: 0 R: t2.
	jump4 := self JumpNonZero: 0.
	self MoveR: t1 R: t2.
	self AndCq: objectMemory getMemoryMap getSpaceMaskToUse R: t2.
	self CmpCq: objectMemory getMemoryMap getNewSpaceMask R: t2.
	jump5 := self JumpNonZero: 0.
	self MoveR: t1 R: t2.
	self CmpCq: objectMemory getMemoryMap getNewSpaceStart R: t2.
	jumpTrue := self JumpAboveOrEqual: 0.
	self MoveCq: 0 R: t2.
	jumpNext := self Jump: 0.
	jumpTrue jmpTarget: self Label.
	self MoveCq: 1 R: t2.
	jumpNext jmpTarget: self Label.
	self CmpCq: 1 R: t2.
	jump6 := self JumpNonZero: 0.
	self MoveM64: 0 r: t0 R: t2.
	self ArithmeticShiftRightCq: 29 R: t2.
	self AndCq: 1 R: t2.
	self CmpCq: 0 R: t2.
	jump7 := self JumpNonZero: 0.
	self MoveR: t0 R: TempReg.
	backEnd saveAndRestoreLinkRegAround: [
		self CallRT: ceStoreCheckTrampoline ].
	self TstCq: 7 R: t1.
	jump8 := self JumpNonZero: 0.
	jump9 := self JumpZero: 0.
	currentBlock := self Label.
	jump5 jmpTarget: currentBlock.
	self MoveCq: 0 R: t2.
	currentBlock := self Label.
	jump6 jmpTarget: currentBlock.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	jump3 jmpTarget: currentBlock.
	jump4 jmpTarget: currentBlock.
	jump7 jmpTarget: currentBlock.
	self TstCq: 7 R: t1.
	jump7 := self JumpNonZero: 0.
	currentBlock := self Label.
	jump9 jmpTarget: currentBlock.
	self CmpCq: objectMemory nilObject R: t1.
	jump9 := self JumpBelow: 0.
	self MoveR: t1 R: t2.
	self CmpCq: objectMemory trueObject R: t2.
	jumpTrue := self JumpBelowOrEqual: 0.
	self MoveCq: 0 R: t2.
	jumpNext := self Jump: 0.
	jumpTrue jmpTarget: self Label.
	self MoveCq: 1 R: t2.
	jumpNext jmpTarget: self Label.
	jump4 := self Jump: 0.
	currentBlock := self Label.
	jump9 jmpTarget: currentBlock.
	self MoveCq: 0 R: t2.
	currentBlock := self Label.
	jump4 jmpTarget: currentBlock.
	self CmpCq: 1 R: t2.
	jump4 := self JumpZero: 0.
	self CmpCq: objectMemory getMemoryMap getNewSpaceStart R: t1.
	jump9 := self JumpBelow: 0.
	self MoveM64: 0 r: t0 R: t2.
	self ArithmeticShiftRightCq: 29 R: t2.
	self AndCq: 1 R: t2.
	self CmpCq: 0 R: t2.
	jump3 := self JumpNonZero: 0.
	self MoveR: t0 R: t2.
	self AndCq: 7 R: t2.
	self CmpCq: 0 R: t2.
	jump1 := self JumpNonZero: 0.
	self MoveR: t0 R: t2.
	self AndCq: objectMemory getMemoryMap getSpaceMaskToUse R: t2.
	self CmpCq: objectMemory getMemoryMap getPermSpaceMask R: t2.
	jumpTrue := self JumpZero: 0.
	self MoveCq: 0 R: t2.
	jumpNext := self Jump: 0.
	jumpTrue jmpTarget: self Label.
	self MoveCq: 1 R: t2.
	jumpNext jmpTarget: self Label.
	jump6 := self Jump: 0.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	self MoveCq: 0 R: t2.
	currentBlock := self Label.
	jump6 jmpTarget: currentBlock.
	self CmpCq: 1 R: t2.
	jump6 := self JumpNonZero: 0.
	self MoveR: t1 R: t2.
	self AndCq: objectMemory getMemoryMap getSpaceMaskToUse R: t2.
	self CmpCq: objectMemory getMemoryMap getPermSpaceMask R: t2.
	jump1 := self JumpZero: 0.
	self MoveR: t0 R: TempReg.
	backEnd saveAndRestoreLinkRegAround: [
		self CallRT: ceStoreCheckTrampoline ].
	currentBlock := self Label.
	jump8 jmpTarget: currentBlock.
	jump7 jmpTarget: currentBlock.
	jump4 jmpTarget: currentBlock.
	jump9 jmpTarget: currentBlock.
	jump3 jmpTarget: currentBlock.
	jump6 jmpTarget: currentBlock.
	jump1 jmpTarget: currentBlock.
	self MoveR: t1 M64: 32 r: t0.
	currentBlock := self Label.
	jump2 jmpTarget: currentBlock.
	^ 0
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_assertIsIgnored [

	| currentBlock |
	self MoveCq: 17 R: ReceiverResultReg.
	self RetN: 1 * objectMemory wordSize.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_branchingWithAssigments [

	| currentBlock jump0 jump1 |
	self CmpCq: 0 R: ReceiverResultReg.
	jump0 := self JumpLessOrEqual: 0.
	self MoveCq: 17 R: ReceiverResultReg.
	jump1 := self Jump: 0.
	currentBlock := self Label.
	jump0 jmpTarget: currentBlock.
	self MoveCq: 42 R: ReceiverResultReg.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	self RetN: 1 * objectMemory wordSize.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_bytecodePopOnTwoBranches [
	"AutoGenerated by Druid"

	| t0 jump1 t1 currentBlock jump2 live t2 |
	live := 0.
	t0 := self allocateRegNotConflictingWith: live ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t0).
	t1 := self allocateRegNotConflictingWith: live ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t1).
	t2 := self allocateRegNotConflictingWith: live ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t2).
	(self ssValue: 0) copyToReg: t0.
	self CmpCq: 0 R: t0.
	jump1 := self JumpLessOrEqual: 0.
	(self ssValue: 0) copyToReg: t1.
	self MoveR: t1 R: t0.
	jump2 := self Jump: 0.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	(self ssValue: 0) copyToReg: t2.
	self MoveR: t2 R: t0.
	currentBlock := self Label.
	jump2 jmpTarget: currentBlock.
	self ssPop: 1 popSpilled: true.
	self ssPushRegister: t0.
	^ 0
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_bytecodePrimAdd [
	"AutoGenerated by Druid"

	| live currentBlock |
	live := 0.
	self ssFlushStackExceptTop: 2.
	self marshallSendArgumentsNoPush: 1.
	self genMarshalledSendNoPush: -1 numArgs: 1 sendTable: ordinarySendTrampolines.
	self ssPop: 2 popSpilled: false.
	self ssPushRegister: ReceiverResultReg.
	^ 0
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_bytecodePrimIdenticalSistaV1 [
	"AutoGenerated by Druid"

	| jump1 b507 s57 s54 t1 jump6 jump3 b503 currentBlock t3 t0 jump5 jump2 live t2 jump4 |
	live := 0.
	t0 := self allocateRegNotConflictingWith: live ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t0).
	t1 := self allocateRegNotConflictingWith: live ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t1).
	t2 := self allocateRegNotConflictingWith: live ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t2).
	t3 := self allocateRegNotConflictingWith: live ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t3).
	(self ssValue: 1) copyToReg: t0.
	(self ssValue: 0) copyToReg: t1.
	self MoveR: t0 R: t2.
	self AndCq: 7 R: t2.
	self CmpCq: 0 R: t2.
	jump1 := self JumpNonZero: 0.
	self MoveM64: 0 r: t0 R: t2.
	self AndCq: 16r3FFFF7 R: t2.
	self CmpCq: 0 R: t2.
	jump2 := self JumpNonZero: 0.
	self MoveM64: 8 r: t0 R: t2.
	b507 := self Label.
	self MoveR: t2 R: t0.
	self AndCq: 7 R: t0.
	self CmpCq: 0 R: t0.
	jump3 := self JumpNonZero: 0.
	self MoveM64: 0 r: t2 R: t0.
	self AndCq: 16r3FFFF7 R: t0.
	self CmpCq: 0 R: t0.
	jump4 := self JumpNonZero: 0.
	self MoveM64: 8 r: t2 R: t0.
	self MoveR: t0 R: t2.
	jump5 := self Jump: b507.
	currentBlock := self Label.
	jump3 jmpTarget: currentBlock.
	jump4 jmpTarget: currentBlock.
	self MoveR: t2 R: t0.
	jump4 := self Jump: 0.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	jump2 jmpTarget: currentBlock.
	currentBlock := self Label.
	jump4 jmpTarget: currentBlock.
	self MoveR: t1 R: t2.
	self AndCq: 7 R: t2.
	self CmpCq: 0 R: t2.
	jump4 := self JumpNonZero: 0.
	self MoveM64: 0 r: t1 R: t2.
	self AndCq: 16r3FFFF7 R: t2.
	self CmpCq: 0 R: t2.
	jump2 := self JumpNonZero: 0.
	self MoveM64: 8 r: t1 R: t2.
	b503 := self Label.
	self MoveR: t2 R: t3.
	self AndCq: 7 R: t3.
	self CmpCq: 0 R: t3.
	jump1 := self JumpNonZero: 0.
	self MoveM64: 0 r: t2 R: t3.
	self AndCq: 16r3FFFF7 R: t3.
	self CmpCq: 0 R: t3.
	jump3 := self JumpNonZero: 0.
	self MoveM64: 8 r: t2 R: t3.
	self MoveR: t3 R: t2.
	jump6 := self Jump: b503.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	jump3 jmpTarget: currentBlock.
	self MoveR: t2 R: t3.
	jump3 := self Jump: 0.
	currentBlock := self Label.
	jump4 jmpTarget: currentBlock.
	jump2 jmpTarget: currentBlock.
	self MoveR: t1 R: t3.
	currentBlock := self Label.
	jump3 jmpTarget: currentBlock.
	self ssPop: 2 popSpilled: true.
	self CmpR: t3 R: t0.
	jump3 := self JumpNonZero: 0.
	s54 := objectMemory trueObject.
	self MoveCq: s54 R: t3.
	jump2 := self Jump: 0.
	currentBlock := self Label.
	jump3 jmpTarget: currentBlock.
	s57 := objectMemory falseObject.
	self MoveCq: s57 R: t3.
	currentBlock := self Label.
	jump2 jmpTarget: currentBlock.
	self ssPushRegister: t3.
	^ 0
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_bytecodePrimIdenticalSistaV1_shortConditionalJumpFalse [
	"AutoGenerated by Druid"

	| jump1 b560 s57 t1 jump6 jump3 b556 s56 t3 t0 currentBlock jump2 jump5 s58 live t2 jump4 |
	live := 0.
	t0 := self allocateRegNotConflictingWith: live ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t0).
	t1 := self allocateRegNotConflictingWith: live ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t1).
	t2 := self allocateRegNotConflictingWith: live ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t2).
	t3 := self allocateRegNotConflictingWith: live ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t3).
	(self ssValue: 1) copyToReg: t0.
	(self ssValue: 0) copyToReg: t1.
	self MoveR: t0 R: t2.
	self AndCq: 7 R: t2.
	self CmpCq: 0 R: t2.
	jump1 := self JumpNonZero: 0.
	self MoveM64: 0 r: t0 R: t2.
	self AndCq: 16r3FFFF7 R: t2.
	self CmpCq: 0 R: t2.
	jump2 := self JumpNonZero: 0.
	self MoveM64: 8 r: t0 R: t2.
	b560 := self Label.
	self MoveR: t2 R: t0.
	self AndCq: 7 R: t0.
	self CmpCq: 0 R: t0.
	jump3 := self JumpNonZero: 0.
	self MoveM64: 0 r: t2 R: t0.
	self AndCq: 16r3FFFF7 R: t0.
	self CmpCq: 0 R: t0.
	jump4 := self JumpNonZero: 0.
	self MoveM64: 8 r: t2 R: t0.
	self MoveR: t0 R: t2.
	jump5 := self Jump: b560.
	currentBlock := self Label.
	jump3 jmpTarget: currentBlock.
	jump4 jmpTarget: currentBlock.
	self MoveR: t2 R: t0.
	jump4 := self Jump: 0.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	jump2 jmpTarget: currentBlock.
	currentBlock := self Label.
	jump4 jmpTarget: currentBlock.
	self MoveR: t1 R: t2.
	self AndCq: 7 R: t2.
	self CmpCq: 0 R: t2.
	jump4 := self JumpNonZero: 0.
	self MoveM64: 0 r: t1 R: t2.
	self AndCq: 16r3FFFF7 R: t2.
	self CmpCq: 0 R: t2.
	jump2 := self JumpNonZero: 0.
	self MoveM64: 8 r: t1 R: t2.
	b556 := self Label.
	self MoveR: t2 R: t3.
	self AndCq: 7 R: t3.
	self CmpCq: 0 R: t3.
	jump1 := self JumpNonZero: 0.
	self MoveM64: 0 r: t2 R: t3.
	self AndCq: 16r3FFFF7 R: t3.
	self CmpCq: 0 R: t3.
	jump3 := self JumpNonZero: 0.
	self MoveM64: 8 r: t2 R: t3.
	self MoveR: t3 R: t2.
	jump6 := self Jump: b556.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	jump3 jmpTarget: currentBlock.
	self MoveR: t2 R: t3.
	jump3 := self Jump: 0.
	currentBlock := self Label.
	jump4 jmpTarget: currentBlock.
	jump2 jmpTarget: currentBlock.
	self MoveR: t1 R: t3.
	currentBlock := self Label.
	jump3 jmpTarget: currentBlock.
	self ssPop: 2 popSpilled: true.
	self ssFlushStackExceptTop: 0.
	self CmpR: t3 R: t0.
	jump3 := self JumpNonZero: 0.
	jump2 := self Jump: 0.
	currentBlock := self Label.
	jump3 jmpTarget: currentBlock.
	s56 := bytecodePC.
	s57 := s56 + 2.
	self Jump: (self ensureFixupAt: s57).
	deadCode := true.
	deadCode := false.
	currentBlock := self Label.
	jump2 jmpTarget: currentBlock.
	^ 0
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_bytecodePrimIdenticalSistaV1_shortConditionalJumpFalse_10 [
	"AutoGenerated by Druid"

	| b556 jump5 jump3 jump1 t1 s2 currentBlock s49 jump6 live jump4 s45 jump2 t2 s52 b560 t0 s48 s50 |
	live := 0.
	t0 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t0).
	t1 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t1).
	t2 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t2).
	self annotateBytecode: self Label.
	(self ssValue: 1) copyToReg: t0.
	(self ssValue: 0) copyToReg: t1.
	self MoveR: t0 R: t2.
	self AndCq: 7 R: t2.
	self CmpCq: 0 R: t2.
	jump1 := self JumpNonZero: 0.
	self MoveM64: 0 r: t0 R: t2.
	self AndCq: 16r3FFFF7 R: t2.
	self CmpCq: 0 R: t2.
	jump2 := self JumpNonZero: 0.
	self MoveM64: 8 r: t0 R: t2.
	b560 := self Label.
	self MoveR: t2 R: t0.
	self AndCq: 7 R: t0.
	self CmpCq: 0 R: t0.
	jump3 := self JumpNonZero: 0.
	self MoveM64: 0 r: t2 R: t0.
	self AndCq: 16r3FFFF7 R: t0.
	self CmpCq: 0 R: t0.
	jump4 := self JumpNonZero: 0.
	self MoveM64: 8 r: t2 R: t0.
	self MoveR: t0 R: t2.
	jump5 := self Jump: b560.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	jump2 jmpTarget: currentBlock.
	jump3 jmpTarget: currentBlock.
	jump4 jmpTarget: currentBlock.
	self MoveR: t1 R: t0.
	self AndCq: 7 R: t0.
	self CmpCq: 0 R: t0.
	jump4 := self JumpNonZero: 0.
	self MoveM64: 0 r: t1 R: t0.
	self AndCq: 16r3FFFF7 R: t0.
	self CmpCq: 0 R: t0.
	jump3 := self JumpNonZero: 0.
	self MoveM64: 8 r: t1 R: t0.
	b556 := self Label.
	self MoveR: t0 R: t2.
	self AndCq: 7 R: t2.
	self CmpCq: 0 R: t2.
	jump2 := self JumpNonZero: 0.
	self MoveM64: 0 r: t0 R: t2.
	self AndCq: 16r3FFFF7 R: t2.
	self CmpCq: 0 R: t2.
	jump1 := self JumpNonZero: 0.
	self MoveM64: 8 r: t0 R: t2.
	self MoveR: t2 R: t0.
	jump6 := self Jump: b556.
	currentBlock := self Label.
	jump4 jmpTarget: currentBlock.
	jump3 jmpTarget: currentBlock.
	jump2 jmpTarget: currentBlock.
	jump1 jmpTarget: currentBlock.
	self ssPop: 2 popSpilled: true.
	(self ssValue: 1) copyToReg: t2.
	s45 := objectMemory falseObject.
	self ssFlushStackExceptTop: 0.
	self CmpCq: s45 R: t2.
	jump1 := self JumpNonZero: 0.
	s48 := bytecodePC.
	s49 := s48 + 3.
	self Jump: (self ensureFixupAt: s49).
	deadCode := true.
	jump2 := self Jump: 0.
	deadCode := false.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	s52 := objectMemory trueObject.
	self CmpCq: s52 R: t2.
	jump1 := self JumpZero: 0.
	self MoveR: t2 R: TempReg.
	self CallRT: ceSendMustBeBooleanTrampoline.
	currentBlock := self Label.
	jump2 jmpTarget: currentBlock.
	jump1 jmpTarget: currentBlock.
	^ 0
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_bytecodePrimIdenticalSistaV1_shortConditionalJumpFalse_11 [
	"AutoGenerated by Druid"

	| b556 jump5 jump3 jump1 t1 s2 currentBlock s49 jump6 live jump4 s45 jump2 t2 s52 b560 t0 s48 s50 |
	live := 0.
	t0 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t0).
	t1 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t1).
	t2 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t2).
	self annotateBytecode: self Label.
	(self ssValue: 1) copyToReg: t0.
	(self ssValue: 0) copyToReg: t1.
	self MoveR: t0 R: t2.
	self AndCq: 7 R: t2.
	self CmpCq: 0 R: t2.
	jump1 := self JumpNonZero: 0.
	self MoveM64: 0 r: t0 R: t2.
	self AndCq: 16r3FFFF7 R: t2.
	self CmpCq: 0 R: t2.
	jump2 := self JumpNonZero: 0.
	self MoveM64: 8 r: t0 R: t2.
	b560 := self Label.
	self MoveR: t2 R: t0.
	self AndCq: 7 R: t0.
	self CmpCq: 0 R: t0.
	jump3 := self JumpNonZero: 0.
	self MoveM64: 0 r: t2 R: t0.
	self AndCq: 16r3FFFF7 R: t0.
	self CmpCq: 0 R: t0.
	jump4 := self JumpNonZero: 0.
	self MoveM64: 8 r: t2 R: t0.
	self MoveR: t0 R: t2.
	jump5 := self Jump: b560.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	jump2 jmpTarget: currentBlock.
	jump3 jmpTarget: currentBlock.
	jump4 jmpTarget: currentBlock.
	self MoveR: t1 R: t0.
	self AndCq: 7 R: t0.
	self CmpCq: 0 R: t0.
	jump4 := self JumpNonZero: 0.
	self MoveM64: 0 r: t1 R: t0.
	self AndCq: 16r3FFFF7 R: t0.
	self CmpCq: 0 R: t0.
	jump3 := self JumpNonZero: 0.
	self MoveM64: 8 r: t1 R: t0.
	b556 := self Label.
	self MoveR: t0 R: t2.
	self AndCq: 7 R: t2.
	self CmpCq: 0 R: t2.
	jump2 := self JumpNonZero: 0.
	self MoveM64: 0 r: t0 R: t2.
	self AndCq: 16r3FFFF7 R: t2.
	self CmpCq: 0 R: t2.
	jump1 := self JumpNonZero: 0.
	self MoveM64: 8 r: t0 R: t2.
	self MoveR: t2 R: t0.
	jump6 := self Jump: b556.
	currentBlock := self Label.
	jump4 jmpTarget: currentBlock.
	jump3 jmpTarget: currentBlock.
	jump2 jmpTarget: currentBlock.
	jump1 jmpTarget: currentBlock.
	self ssPop: 2 popSpilled: true.
	(self ssValue: 1) copyToReg: t2.
	s45 := objectMemory falseObject.
	self ssFlushStackExceptTop: 0.
	self CmpCq: s45 R: t2.
	jump1 := self JumpNonZero: 0.
	s48 := bytecodePC.
	s49 := s48 + 4.
	self Jump: (self ensureFixupAt: s49).
	deadCode := true.
	jump2 := self Jump: 0.
	deadCode := false.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	s52 := objectMemory trueObject.
	self CmpCq: s52 R: t2.
	jump1 := self JumpZero: 0.
	self MoveR: t2 R: TempReg.
	self CallRT: ceSendMustBeBooleanTrampoline.
	currentBlock := self Label.
	jump2 jmpTarget: currentBlock.
	jump1 jmpTarget: currentBlock.
	^ 0
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_bytecodePrimIdenticalSistaV1_shortConditionalJumpFalse_12 [
	"AutoGenerated by Druid"

	| b556 jump5 jump3 jump1 t1 s2 currentBlock s49 jump6 live jump4 s45 jump2 t2 s52 b560 t0 s48 s50 |
	live := 0.
	t0 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t0).
	t1 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t1).
	t2 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t2).
	self annotateBytecode: self Label.
	(self ssValue: 1) copyToReg: t0.
	(self ssValue: 0) copyToReg: t1.
	self MoveR: t0 R: t2.
	self AndCq: 7 R: t2.
	self CmpCq: 0 R: t2.
	jump1 := self JumpNonZero: 0.
	self MoveM64: 0 r: t0 R: t2.
	self AndCq: 16r3FFFF7 R: t2.
	self CmpCq: 0 R: t2.
	jump2 := self JumpNonZero: 0.
	self MoveM64: 8 r: t0 R: t2.
	b560 := self Label.
	self MoveR: t2 R: t0.
	self AndCq: 7 R: t0.
	self CmpCq: 0 R: t0.
	jump3 := self JumpNonZero: 0.
	self MoveM64: 0 r: t2 R: t0.
	self AndCq: 16r3FFFF7 R: t0.
	self CmpCq: 0 R: t0.
	jump4 := self JumpNonZero: 0.
	self MoveM64: 8 r: t2 R: t0.
	self MoveR: t0 R: t2.
	jump5 := self Jump: b560.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	jump2 jmpTarget: currentBlock.
	jump3 jmpTarget: currentBlock.
	jump4 jmpTarget: currentBlock.
	self MoveR: t1 R: t0.
	self AndCq: 7 R: t0.
	self CmpCq: 0 R: t0.
	jump4 := self JumpNonZero: 0.
	self MoveM64: 0 r: t1 R: t0.
	self AndCq: 16r3FFFF7 R: t0.
	self CmpCq: 0 R: t0.
	jump3 := self JumpNonZero: 0.
	self MoveM64: 8 r: t1 R: t0.
	b556 := self Label.
	self MoveR: t0 R: t2.
	self AndCq: 7 R: t2.
	self CmpCq: 0 R: t2.
	jump2 := self JumpNonZero: 0.
	self MoveM64: 0 r: t0 R: t2.
	self AndCq: 16r3FFFF7 R: t2.
	self CmpCq: 0 R: t2.
	jump1 := self JumpNonZero: 0.
	self MoveM64: 8 r: t0 R: t2.
	self MoveR: t2 R: t0.
	jump6 := self Jump: b556.
	currentBlock := self Label.
	jump4 jmpTarget: currentBlock.
	jump3 jmpTarget: currentBlock.
	jump2 jmpTarget: currentBlock.
	jump1 jmpTarget: currentBlock.
	self ssPop: 2 popSpilled: true.
	(self ssValue: 1) copyToReg: t2.
	s45 := objectMemory falseObject.
	self ssFlushStackExceptTop: 0.
	self CmpCq: s45 R: t2.
	jump1 := self JumpNonZero: 0.
	s48 := bytecodePC.
	s49 := s48 + 5.
	self Jump: (self ensureFixupAt: s49).
	deadCode := true.
	jump2 := self Jump: 0.
	deadCode := false.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	s52 := objectMemory trueObject.
	self CmpCq: s52 R: t2.
	jump1 := self JumpZero: 0.
	self MoveR: t2 R: TempReg.
	self CallRT: ceSendMustBeBooleanTrampoline.
	currentBlock := self Label.
	jump2 jmpTarget: currentBlock.
	jump1 jmpTarget: currentBlock.
	^ 0
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_bytecodePrimIdenticalSistaV1_shortConditionalJumpFalse_13 [
	"AutoGenerated by Druid"

	| b556 jump5 jump3 jump1 t1 s2 currentBlock s49 jump6 live jump4 s45 jump2 t2 s52 b560 t0 s48 s50 |
	live := 0.
	t0 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t0).
	t1 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t1).
	t2 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t2).
	self annotateBytecode: self Label.
	(self ssValue: 1) copyToReg: t0.
	(self ssValue: 0) copyToReg: t1.
	self MoveR: t0 R: t2.
	self AndCq: 7 R: t2.
	self CmpCq: 0 R: t2.
	jump1 := self JumpNonZero: 0.
	self MoveM64: 0 r: t0 R: t2.
	self AndCq: 16r3FFFF7 R: t2.
	self CmpCq: 0 R: t2.
	jump2 := self JumpNonZero: 0.
	self MoveM64: 8 r: t0 R: t2.
	b560 := self Label.
	self MoveR: t2 R: t0.
	self AndCq: 7 R: t0.
	self CmpCq: 0 R: t0.
	jump3 := self JumpNonZero: 0.
	self MoveM64: 0 r: t2 R: t0.
	self AndCq: 16r3FFFF7 R: t0.
	self CmpCq: 0 R: t0.
	jump4 := self JumpNonZero: 0.
	self MoveM64: 8 r: t2 R: t0.
	self MoveR: t0 R: t2.
	jump5 := self Jump: b560.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	jump2 jmpTarget: currentBlock.
	jump3 jmpTarget: currentBlock.
	jump4 jmpTarget: currentBlock.
	self MoveR: t1 R: t0.
	self AndCq: 7 R: t0.
	self CmpCq: 0 R: t0.
	jump4 := self JumpNonZero: 0.
	self MoveM64: 0 r: t1 R: t0.
	self AndCq: 16r3FFFF7 R: t0.
	self CmpCq: 0 R: t0.
	jump3 := self JumpNonZero: 0.
	self MoveM64: 8 r: t1 R: t0.
	b556 := self Label.
	self MoveR: t0 R: t2.
	self AndCq: 7 R: t2.
	self CmpCq: 0 R: t2.
	jump2 := self JumpNonZero: 0.
	self MoveM64: 0 r: t0 R: t2.
	self AndCq: 16r3FFFF7 R: t2.
	self CmpCq: 0 R: t2.
	jump1 := self JumpNonZero: 0.
	self MoveM64: 8 r: t0 R: t2.
	self MoveR: t2 R: t0.
	jump6 := self Jump: b556.
	currentBlock := self Label.
	jump4 jmpTarget: currentBlock.
	jump3 jmpTarget: currentBlock.
	jump2 jmpTarget: currentBlock.
	jump1 jmpTarget: currentBlock.
	self ssPop: 2 popSpilled: true.
	(self ssValue: 1) copyToReg: t2.
	s45 := objectMemory falseObject.
	self ssFlushStackExceptTop: 0.
	self CmpCq: s45 R: t2.
	jump1 := self JumpNonZero: 0.
	s48 := bytecodePC.
	s49 := s48 + 6.
	self Jump: (self ensureFixupAt: s49).
	deadCode := true.
	jump2 := self Jump: 0.
	deadCode := false.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	s52 := objectMemory trueObject.
	self CmpCq: s52 R: t2.
	jump1 := self JumpZero: 0.
	self MoveR: t2 R: TempReg.
	self CallRT: ceSendMustBeBooleanTrampoline.
	currentBlock := self Label.
	jump2 jmpTarget: currentBlock.
	jump1 jmpTarget: currentBlock.
	^ 0
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_bytecodePrimIdenticalSistaV1_shortConditionalJumpFalse_14 [
	"AutoGenerated by Druid"

	| b556 jump5 jump3 jump1 t1 s2 currentBlock s49 jump6 live jump4 s45 jump2 t2 s52 b560 t0 s48 s50 |
	live := 0.
	t0 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t0).
	t1 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t1).
	t2 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t2).
	self annotateBytecode: self Label.
	(self ssValue: 1) copyToReg: t0.
	(self ssValue: 0) copyToReg: t1.
	self MoveR: t0 R: t2.
	self AndCq: 7 R: t2.
	self CmpCq: 0 R: t2.
	jump1 := self JumpNonZero: 0.
	self MoveM64: 0 r: t0 R: t2.
	self AndCq: 16r3FFFF7 R: t2.
	self CmpCq: 0 R: t2.
	jump2 := self JumpNonZero: 0.
	self MoveM64: 8 r: t0 R: t2.
	b560 := self Label.
	self MoveR: t2 R: t0.
	self AndCq: 7 R: t0.
	self CmpCq: 0 R: t0.
	jump3 := self JumpNonZero: 0.
	self MoveM64: 0 r: t2 R: t0.
	self AndCq: 16r3FFFF7 R: t0.
	self CmpCq: 0 R: t0.
	jump4 := self JumpNonZero: 0.
	self MoveM64: 8 r: t2 R: t0.
	self MoveR: t0 R: t2.
	jump5 := self Jump: b560.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	jump2 jmpTarget: currentBlock.
	jump3 jmpTarget: currentBlock.
	jump4 jmpTarget: currentBlock.
	self MoveR: t1 R: t0.
	self AndCq: 7 R: t0.
	self CmpCq: 0 R: t0.
	jump4 := self JumpNonZero: 0.
	self MoveM64: 0 r: t1 R: t0.
	self AndCq: 16r3FFFF7 R: t0.
	self CmpCq: 0 R: t0.
	jump3 := self JumpNonZero: 0.
	self MoveM64: 8 r: t1 R: t0.
	b556 := self Label.
	self MoveR: t0 R: t2.
	self AndCq: 7 R: t2.
	self CmpCq: 0 R: t2.
	jump2 := self JumpNonZero: 0.
	self MoveM64: 0 r: t0 R: t2.
	self AndCq: 16r3FFFF7 R: t2.
	self CmpCq: 0 R: t2.
	jump1 := self JumpNonZero: 0.
	self MoveM64: 8 r: t0 R: t2.
	self MoveR: t2 R: t0.
	jump6 := self Jump: b556.
	currentBlock := self Label.
	jump4 jmpTarget: currentBlock.
	jump3 jmpTarget: currentBlock.
	jump2 jmpTarget: currentBlock.
	jump1 jmpTarget: currentBlock.
	self ssPop: 2 popSpilled: true.
	(self ssValue: 1) copyToReg: t2.
	s45 := objectMemory falseObject.
	self ssFlushStackExceptTop: 0.
	self CmpCq: s45 R: t2.
	jump1 := self JumpNonZero: 0.
	s48 := bytecodePC.
	s49 := s48 + 7.
	self Jump: (self ensureFixupAt: s49).
	deadCode := true.
	jump2 := self Jump: 0.
	deadCode := false.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	s52 := objectMemory trueObject.
	self CmpCq: s52 R: t2.
	jump1 := self JumpZero: 0.
	self MoveR: t2 R: TempReg.
	self CallRT: ceSendMustBeBooleanTrampoline.
	currentBlock := self Label.
	jump2 jmpTarget: currentBlock.
	jump1 jmpTarget: currentBlock.
	^ 0
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_bytecodePrimIdenticalSistaV1_shortConditionalJumpFalse_15 [
	"AutoGenerated by Druid"

	| b556 jump5 jump3 jump1 t1 s2 currentBlock s49 jump6 live jump4 s45 jump2 t2 s52 b560 t0 s48 s50 |
	live := 0.
	t0 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t0).
	t1 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t1).
	t2 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t2).
	self annotateBytecode: self Label.
	(self ssValue: 1) copyToReg: t0.
	(self ssValue: 0) copyToReg: t1.
	self MoveR: t0 R: t2.
	self AndCq: 7 R: t2.
	self CmpCq: 0 R: t2.
	jump1 := self JumpNonZero: 0.
	self MoveM64: 0 r: t0 R: t2.
	self AndCq: 16r3FFFF7 R: t2.
	self CmpCq: 0 R: t2.
	jump2 := self JumpNonZero: 0.
	self MoveM64: 8 r: t0 R: t2.
	b560 := self Label.
	self MoveR: t2 R: t0.
	self AndCq: 7 R: t0.
	self CmpCq: 0 R: t0.
	jump3 := self JumpNonZero: 0.
	self MoveM64: 0 r: t2 R: t0.
	self AndCq: 16r3FFFF7 R: t0.
	self CmpCq: 0 R: t0.
	jump4 := self JumpNonZero: 0.
	self MoveM64: 8 r: t2 R: t0.
	self MoveR: t0 R: t2.
	jump5 := self Jump: b560.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	jump2 jmpTarget: currentBlock.
	jump3 jmpTarget: currentBlock.
	jump4 jmpTarget: currentBlock.
	self MoveR: t1 R: t0.
	self AndCq: 7 R: t0.
	self CmpCq: 0 R: t0.
	jump4 := self JumpNonZero: 0.
	self MoveM64: 0 r: t1 R: t0.
	self AndCq: 16r3FFFF7 R: t0.
	self CmpCq: 0 R: t0.
	jump3 := self JumpNonZero: 0.
	self MoveM64: 8 r: t1 R: t0.
	b556 := self Label.
	self MoveR: t0 R: t2.
	self AndCq: 7 R: t2.
	self CmpCq: 0 R: t2.
	jump2 := self JumpNonZero: 0.
	self MoveM64: 0 r: t0 R: t2.
	self AndCq: 16r3FFFF7 R: t2.
	self CmpCq: 0 R: t2.
	jump1 := self JumpNonZero: 0.
	self MoveM64: 8 r: t0 R: t2.
	self MoveR: t2 R: t0.
	jump6 := self Jump: b556.
	currentBlock := self Label.
	jump4 jmpTarget: currentBlock.
	jump3 jmpTarget: currentBlock.
	jump2 jmpTarget: currentBlock.
	jump1 jmpTarget: currentBlock.
	self ssPop: 2 popSpilled: true.
	(self ssValue: 1) copyToReg: t2.
	s45 := objectMemory falseObject.
	self ssFlushStackExceptTop: 0.
	self CmpCq: s45 R: t2.
	jump1 := self JumpNonZero: 0.
	s48 := bytecodePC.
	s49 := s48 + 8.
	self Jump: (self ensureFixupAt: s49).
	deadCode := true.
	jump2 := self Jump: 0.
	deadCode := false.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	s52 := objectMemory trueObject.
	self CmpCq: s52 R: t2.
	jump1 := self JumpZero: 0.
	self MoveR: t2 R: TempReg.
	self CallRT: ceSendMustBeBooleanTrampoline.
	currentBlock := self Label.
	jump2 jmpTarget: currentBlock.
	jump1 jmpTarget: currentBlock.
	^ 0
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_bytecodePrimIdenticalSistaV1_shortConditionalJumpFalse_16 [
	"AutoGenerated by Druid"

	| b556 jump5 jump3 jump1 t1 s2 currentBlock s49 jump6 live jump4 s45 jump2 t2 s52 b560 t0 s48 s50 |
	live := 0.
	t0 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t0).
	t1 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t1).
	t2 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t2).
	self annotateBytecode: self Label.
	(self ssValue: 1) copyToReg: t0.
	(self ssValue: 0) copyToReg: t1.
	self MoveR: t0 R: t2.
	self AndCq: 7 R: t2.
	self CmpCq: 0 R: t2.
	jump1 := self JumpNonZero: 0.
	self MoveM64: 0 r: t0 R: t2.
	self AndCq: 16r3FFFF7 R: t2.
	self CmpCq: 0 R: t2.
	jump2 := self JumpNonZero: 0.
	self MoveM64: 8 r: t0 R: t2.
	b560 := self Label.
	self MoveR: t2 R: t0.
	self AndCq: 7 R: t0.
	self CmpCq: 0 R: t0.
	jump3 := self JumpNonZero: 0.
	self MoveM64: 0 r: t2 R: t0.
	self AndCq: 16r3FFFF7 R: t0.
	self CmpCq: 0 R: t0.
	jump4 := self JumpNonZero: 0.
	self MoveM64: 8 r: t2 R: t0.
	self MoveR: t0 R: t2.
	jump5 := self Jump: b560.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	jump2 jmpTarget: currentBlock.
	jump3 jmpTarget: currentBlock.
	jump4 jmpTarget: currentBlock.
	self MoveR: t1 R: t0.
	self AndCq: 7 R: t0.
	self CmpCq: 0 R: t0.
	jump4 := self JumpNonZero: 0.
	self MoveM64: 0 r: t1 R: t0.
	self AndCq: 16r3FFFF7 R: t0.
	self CmpCq: 0 R: t0.
	jump3 := self JumpNonZero: 0.
	self MoveM64: 8 r: t1 R: t0.
	b556 := self Label.
	self MoveR: t0 R: t2.
	self AndCq: 7 R: t2.
	self CmpCq: 0 R: t2.
	jump2 := self JumpNonZero: 0.
	self MoveM64: 0 r: t0 R: t2.
	self AndCq: 16r3FFFF7 R: t2.
	self CmpCq: 0 R: t2.
	jump1 := self JumpNonZero: 0.
	self MoveM64: 8 r: t0 R: t2.
	self MoveR: t2 R: t0.
	jump6 := self Jump: b556.
	currentBlock := self Label.
	jump4 jmpTarget: currentBlock.
	jump3 jmpTarget: currentBlock.
	jump2 jmpTarget: currentBlock.
	jump1 jmpTarget: currentBlock.
	self ssPop: 2 popSpilled: true.
	(self ssValue: 1) copyToReg: t2.
	s45 := objectMemory falseObject.
	self ssFlushStackExceptTop: 0.
	self CmpCq: s45 R: t2.
	jump1 := self JumpNonZero: 0.
	s48 := bytecodePC.
	s49 := s48 + 9.
	self Jump: (self ensureFixupAt: s49).
	deadCode := true.
	jump2 := self Jump: 0.
	deadCode := false.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	s52 := objectMemory trueObject.
	self CmpCq: s52 R: t2.
	jump1 := self JumpZero: 0.
	self MoveR: t2 R: TempReg.
	self CallRT: ceSendMustBeBooleanTrampoline.
	currentBlock := self Label.
	jump2 jmpTarget: currentBlock.
	jump1 jmpTarget: currentBlock.
	^ 0
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_bytecodePrimIdenticalSistaV1_shortConditionalJumpFalse_9 [
	"AutoGenerated by Druid"

	| b556 jump5 jump3 jump1 t1 s2 currentBlock s49 jump6 live jump4 s45 jump2 t2 s52 b560 t0 s48 s50 |
	live := 0.
	t0 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t0).
	t1 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t1).
	t2 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t2).
	self annotateBytecode: self Label.
	(self ssValue: 1) copyToReg: t0.
	(self ssValue: 0) copyToReg: t1.
	self MoveR: t0 R: t2.
	self AndCq: 7 R: t2.
	self CmpCq: 0 R: t2.
	jump1 := self JumpNonZero: 0.
	self MoveM64: 0 r: t0 R: t2.
	self AndCq: 16r3FFFF7 R: t2.
	self CmpCq: 0 R: t2.
	jump2 := self JumpNonZero: 0.
	self MoveM64: 8 r: t0 R: t2.
	b560 := self Label.
	self MoveR: t2 R: t0.
	self AndCq: 7 R: t0.
	self CmpCq: 0 R: t0.
	jump3 := self JumpNonZero: 0.
	self MoveM64: 0 r: t2 R: t0.
	self AndCq: 16r3FFFF7 R: t0.
	self CmpCq: 0 R: t0.
	jump4 := self JumpNonZero: 0.
	self MoveM64: 8 r: t2 R: t0.
	self MoveR: t0 R: t2.
	jump5 := self Jump: b560.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	jump2 jmpTarget: currentBlock.
	jump3 jmpTarget: currentBlock.
	jump4 jmpTarget: currentBlock.
	self MoveR: t1 R: t0.
	self AndCq: 7 R: t0.
	self CmpCq: 0 R: t0.
	jump4 := self JumpNonZero: 0.
	self MoveM64: 0 r: t1 R: t0.
	self AndCq: 16r3FFFF7 R: t0.
	self CmpCq: 0 R: t0.
	jump3 := self JumpNonZero: 0.
	self MoveM64: 8 r: t1 R: t0.
	b556 := self Label.
	self MoveR: t0 R: t2.
	self AndCq: 7 R: t2.
	self CmpCq: 0 R: t2.
	jump2 := self JumpNonZero: 0.
	self MoveM64: 0 r: t0 R: t2.
	self AndCq: 16r3FFFF7 R: t2.
	self CmpCq: 0 R: t2.
	jump1 := self JumpNonZero: 0.
	self MoveM64: 8 r: t0 R: t2.
	self MoveR: t2 R: t0.
	jump6 := self Jump: b556.
	currentBlock := self Label.
	jump4 jmpTarget: currentBlock.
	jump3 jmpTarget: currentBlock.
	jump2 jmpTarget: currentBlock.
	jump1 jmpTarget: currentBlock.
	self ssPop: 2 popSpilled: true.
	(self ssValue: 1) copyToReg: t2.
	s45 := objectMemory falseObject.
	self ssFlushStackExceptTop: 0.
	self CmpCq: s45 R: t2.
	jump1 := self JumpNonZero: 0.
	s48 := bytecodePC.
	s49 := s48 + 2.
	self Jump: (self ensureFixupAt: s49).
	deadCode := true.
	jump2 := self Jump: 0.
	deadCode := false.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	s52 := objectMemory trueObject.
	self CmpCq: s52 R: t2.
	jump1 := self JumpZero: 0.
	self MoveR: t2 R: TempReg.
	self CallRT: ceSendMustBeBooleanTrampoline.
	currentBlock := self Label.
	jump2 jmpTarget: currentBlock.
	jump1 jmpTarget: currentBlock.
	^ 0
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_bytecodePrimIdenticalSistaV1_shortConditionalJumpTrue [
	"AutoGenerated by Druid"

	| jump1 b560 s54 t1 jump6 jump3 currentBlock s56 t0 b564 jump2 jump5 s55 live t2 jump4 |
	live := 0.
	t0 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t0).
	(self ssValue: 1) copyToReg: t0.
	t1 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t1).
	(self ssValue: 0) copyToReg: t1.
	t2 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t2).
	self MoveR: t0 R: t2.
	self AndCq: 7 R: t2.
	self CmpCq: 0 R: t2.
	jump1 := self JumpNonZero: 0.
	self MoveM64: 0 r: t0 R: t2.
	self AndCq: 16r3FFFF7 R: t2.
	self CmpCq: 0 R: t2.
	jump2 := self JumpNonZero: 0.
	self MoveM64: 8 r: t0 R: t2.
	b564 := self Label.
	self MoveR: t2 R: t0.
	self AndCq: 7 R: t0.
	self CmpCq: 0 R: t0.
	jump3 := self JumpNonZero: 0.
	self MoveM64: 0 r: t2 R: t0.
	self AndCq: 16r3FFFF7 R: t0.
	self CmpCq: 0 R: t0.
	jump4 := self JumpNonZero: 0.
	self MoveM64: 8 r: t2 R: t0.
	self MoveR: t0 R: t2.
	jump5 := self Jump: b564.
	currentBlock := self Label.
	jump3 jmpTarget: currentBlock.
	jump4 jmpTarget: currentBlock.
	self MoveR: t2 R: t0.
	jump4 := self Jump: 0.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	jump2 jmpTarget: currentBlock.
	currentBlock := self Label.
	jump4 jmpTarget: currentBlock.
	self MoveR: t1 R: t2.
	self AndCq: 7 R: t2.
	self CmpCq: 0 R: t2.
	jump4 := self JumpNonZero: 0.
	self MoveM64: 0 r: t1 R: t2.
	self AndCq: 16r3FFFF7 R: t2.
	self CmpCq: 0 R: t2.
	jump2 := self JumpNonZero: 0.
	self MoveM64: 8 r: t1 R: t2.
	b560 := self Label.
	self MoveR: t2 R: t1.
	self AndCq: 7 R: t1.
	self CmpCq: 0 R: t1.
	jump1 := self JumpNonZero: 0.
	self MoveM64: 0 r: t2 R: t1.
	self AndCq: 16r3FFFF7 R: t1.
	self CmpCq: 0 R: t1.
	jump3 := self JumpNonZero: 0.
	self MoveM64: 8 r: t2 R: t1.
	self MoveR: t1 R: t2.
	jump6 := self Jump: b560.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	jump3 jmpTarget: currentBlock.
	self MoveR: t2 R: t1.
	jump3 := self Jump: 0.
	currentBlock := self Label.
	jump4 jmpTarget: currentBlock.
	jump2 jmpTarget: currentBlock.
	currentBlock := self Label.
	jump3 jmpTarget: currentBlock.
	self ssPop: 2.
	self CmpR: t1 R: t0.
	jump3 := self JumpNonZero: 0.
	self annotateBytecode: self Label.
	s55 := bytecodePC.
	s56 := s55 + 3.
	self ssFlushStack.
	self Jump: (self ensureFixupAt: s56).
	deadCode := true.
	jump2 := self Jump: 0.
	deadCode := false.
	currentBlock := self Label.
	jump3 jmpTarget: currentBlock.
	self annotateBytecode: self Label.
	currentBlock := self Label.
	jump2 jmpTarget: currentBlock.
	^ 0
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_bytecodePrimIdenticalSistaV1_shortConditionalJumpTrue_1 [
	"AutoGenerated by Druid"

	| b556 jump5 jump3 jump1 t1 s2 currentBlock s49 jump6 live jump4 s45 jump2 t2 s52 b560 t0 s48 s50 |
	live := 0.
	t0 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t0).
	t1 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t1).
	t2 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t2).
	self annotateBytecode: self Label.
	(self ssValue: 1) copyToReg: t0.
	(self ssValue: 0) copyToReg: t1.
	self MoveR: t0 R: t2.
	self AndCq: 7 R: t2.
	self CmpCq: 0 R: t2.
	jump1 := self JumpNonZero: 0.
	self MoveM64: 0 r: t0 R: t2.
	self AndCq: 16r3FFFF7 R: t2.
	self CmpCq: 0 R: t2.
	jump2 := self JumpNonZero: 0.
	self MoveM64: 8 r: t0 R: t2.
	b560 := self Label.
	self MoveR: t2 R: t0.
	self AndCq: 7 R: t0.
	self CmpCq: 0 R: t0.
	jump3 := self JumpNonZero: 0.
	self MoveM64: 0 r: t2 R: t0.
	self AndCq: 16r3FFFF7 R: t0.
	self CmpCq: 0 R: t0.
	jump4 := self JumpNonZero: 0.
	self MoveM64: 8 r: t2 R: t0.
	self MoveR: t0 R: t2.
	jump5 := self Jump: b560.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	jump2 jmpTarget: currentBlock.
	jump3 jmpTarget: currentBlock.
	jump4 jmpTarget: currentBlock.
	self MoveR: t1 R: t0.
	self AndCq: 7 R: t0.
	self CmpCq: 0 R: t0.
	jump4 := self JumpNonZero: 0.
	self MoveM64: 0 r: t1 R: t0.
	self AndCq: 16r3FFFF7 R: t0.
	self CmpCq: 0 R: t0.
	jump3 := self JumpNonZero: 0.
	self MoveM64: 8 r: t1 R: t0.
	b556 := self Label.
	self MoveR: t0 R: t2.
	self AndCq: 7 R: t2.
	self CmpCq: 0 R: t2.
	jump2 := self JumpNonZero: 0.
	self MoveM64: 0 r: t0 R: t2.
	self AndCq: 16r3FFFF7 R: t2.
	self CmpCq: 0 R: t2.
	jump1 := self JumpNonZero: 0.
	self MoveM64: 8 r: t0 R: t2.
	self MoveR: t2 R: t0.
	jump6 := self Jump: b556.
	currentBlock := self Label.
	jump4 jmpTarget: currentBlock.
	jump3 jmpTarget: currentBlock.
	jump2 jmpTarget: currentBlock.
	jump1 jmpTarget: currentBlock.
	self ssPop: 2 popSpilled: true.
	(self ssValue: 1) copyToReg: t2.
	s45 := objectMemory trueObject.
	self ssFlushStackExceptTop: 0.
	self CmpCq: s45 R: t2.
	jump1 := self JumpNonZero: 0.
	s48 := bytecodePC.
	s49 := s48 + 2.
	self Jump: (self ensureFixupAt: s49).
	deadCode := true.
	jump2 := self Jump: 0.
	deadCode := false.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	s52 := objectMemory falseObject.
	self CmpCq: s52 R: t2.
	jump1 := self JumpZero: 0.
	self MoveR: t2 R: TempReg.
	self CallRT: ceSendMustBeBooleanTrampoline.
	currentBlock := self Label.
	jump2 jmpTarget: currentBlock.
	jump1 jmpTarget: currentBlock.
	^ 0
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_bytecodePrimIdenticalSistaV1_shortConditionalJumpTrue_2 [
	"AutoGenerated by Druid"

	| b556 jump5 jump3 jump1 t1 s2 currentBlock s49 jump6 live jump4 s45 jump2 t2 s52 b560 t0 s48 s50 |
	live := 0.
	t0 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t0).
	t1 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t1).
	t2 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t2).
	self annotateBytecode: self Label.
	(self ssValue: 1) copyToReg: t0.
	(self ssValue: 0) copyToReg: t1.
	self MoveR: t0 R: t2.
	self AndCq: 7 R: t2.
	self CmpCq: 0 R: t2.
	jump1 := self JumpNonZero: 0.
	self MoveM64: 0 r: t0 R: t2.
	self AndCq: 16r3FFFF7 R: t2.
	self CmpCq: 0 R: t2.
	jump2 := self JumpNonZero: 0.
	self MoveM64: 8 r: t0 R: t2.
	b560 := self Label.
	self MoveR: t2 R: t0.
	self AndCq: 7 R: t0.
	self CmpCq: 0 R: t0.
	jump3 := self JumpNonZero: 0.
	self MoveM64: 0 r: t2 R: t0.
	self AndCq: 16r3FFFF7 R: t0.
	self CmpCq: 0 R: t0.
	jump4 := self JumpNonZero: 0.
	self MoveM64: 8 r: t2 R: t0.
	self MoveR: t0 R: t2.
	jump5 := self Jump: b560.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	jump2 jmpTarget: currentBlock.
	jump3 jmpTarget: currentBlock.
	jump4 jmpTarget: currentBlock.
	self MoveR: t1 R: t0.
	self AndCq: 7 R: t0.
	self CmpCq: 0 R: t0.
	jump4 := self JumpNonZero: 0.
	self MoveM64: 0 r: t1 R: t0.
	self AndCq: 16r3FFFF7 R: t0.
	self CmpCq: 0 R: t0.
	jump3 := self JumpNonZero: 0.
	self MoveM64: 8 r: t1 R: t0.
	b556 := self Label.
	self MoveR: t0 R: t2.
	self AndCq: 7 R: t2.
	self CmpCq: 0 R: t2.
	jump2 := self JumpNonZero: 0.
	self MoveM64: 0 r: t0 R: t2.
	self AndCq: 16r3FFFF7 R: t2.
	self CmpCq: 0 R: t2.
	jump1 := self JumpNonZero: 0.
	self MoveM64: 8 r: t0 R: t2.
	self MoveR: t2 R: t0.
	jump6 := self Jump: b556.
	currentBlock := self Label.
	jump4 jmpTarget: currentBlock.
	jump3 jmpTarget: currentBlock.
	jump2 jmpTarget: currentBlock.
	jump1 jmpTarget: currentBlock.
	self ssPop: 2 popSpilled: true.
	(self ssValue: 1) copyToReg: t2.
	s45 := objectMemory trueObject.
	self ssFlushStackExceptTop: 0.
	self CmpCq: s45 R: t2.
	jump1 := self JumpNonZero: 0.
	s48 := bytecodePC.
	s49 := s48 + 3.
	self Jump: (self ensureFixupAt: s49).
	deadCode := true.
	jump2 := self Jump: 0.
	deadCode := false.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	s52 := objectMemory falseObject.
	self CmpCq: s52 R: t2.
	jump1 := self JumpZero: 0.
	self MoveR: t2 R: TempReg.
	self CallRT: ceSendMustBeBooleanTrampoline.
	currentBlock := self Label.
	jump2 jmpTarget: currentBlock.
	jump1 jmpTarget: currentBlock.
	^ 0
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_bytecodePrimIdenticalSistaV1_shortConditionalJumpTrue_3 [
	"AutoGenerated by Druid"

	| b556 jump5 jump3 jump1 t1 s2 currentBlock s49 jump6 live jump4 s45 jump2 t2 s52 b560 t0 s48 s50 |
	live := 0.
	t0 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t0).
	t1 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t1).
	t2 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t2).
	self annotateBytecode: self Label.
	(self ssValue: 1) copyToReg: t0.
	(self ssValue: 0) copyToReg: t1.
	self MoveR: t0 R: t2.
	self AndCq: 7 R: t2.
	self CmpCq: 0 R: t2.
	jump1 := self JumpNonZero: 0.
	self MoveM64: 0 r: t0 R: t2.
	self AndCq: 16r3FFFF7 R: t2.
	self CmpCq: 0 R: t2.
	jump2 := self JumpNonZero: 0.
	self MoveM64: 8 r: t0 R: t2.
	b560 := self Label.
	self MoveR: t2 R: t0.
	self AndCq: 7 R: t0.
	self CmpCq: 0 R: t0.
	jump3 := self JumpNonZero: 0.
	self MoveM64: 0 r: t2 R: t0.
	self AndCq: 16r3FFFF7 R: t0.
	self CmpCq: 0 R: t0.
	jump4 := self JumpNonZero: 0.
	self MoveM64: 8 r: t2 R: t0.
	self MoveR: t0 R: t2.
	jump5 := self Jump: b560.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	jump2 jmpTarget: currentBlock.
	jump3 jmpTarget: currentBlock.
	jump4 jmpTarget: currentBlock.
	self MoveR: t1 R: t0.
	self AndCq: 7 R: t0.
	self CmpCq: 0 R: t0.
	jump4 := self JumpNonZero: 0.
	self MoveM64: 0 r: t1 R: t0.
	self AndCq: 16r3FFFF7 R: t0.
	self CmpCq: 0 R: t0.
	jump3 := self JumpNonZero: 0.
	self MoveM64: 8 r: t1 R: t0.
	b556 := self Label.
	self MoveR: t0 R: t2.
	self AndCq: 7 R: t2.
	self CmpCq: 0 R: t2.
	jump2 := self JumpNonZero: 0.
	self MoveM64: 0 r: t0 R: t2.
	self AndCq: 16r3FFFF7 R: t2.
	self CmpCq: 0 R: t2.
	jump1 := self JumpNonZero: 0.
	self MoveM64: 8 r: t0 R: t2.
	self MoveR: t2 R: t0.
	jump6 := self Jump: b556.
	currentBlock := self Label.
	jump4 jmpTarget: currentBlock.
	jump3 jmpTarget: currentBlock.
	jump2 jmpTarget: currentBlock.
	jump1 jmpTarget: currentBlock.
	self ssPop: 2 popSpilled: true.
	(self ssValue: 1) copyToReg: t2.
	s45 := objectMemory trueObject.
	self ssFlushStackExceptTop: 0.
	self CmpCq: s45 R: t2.
	jump1 := self JumpNonZero: 0.
	s48 := bytecodePC.
	s49 := s48 + 4.
	self Jump: (self ensureFixupAt: s49).
	deadCode := true.
	jump2 := self Jump: 0.
	deadCode := false.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	s52 := objectMemory falseObject.
	self CmpCq: s52 R: t2.
	jump1 := self JumpZero: 0.
	self MoveR: t2 R: TempReg.
	self CallRT: ceSendMustBeBooleanTrampoline.
	currentBlock := self Label.
	jump2 jmpTarget: currentBlock.
	jump1 jmpTarget: currentBlock.
	^ 0
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_bytecodePrimIdenticalSistaV1_shortConditionalJumpTrue_4 [
	"AutoGenerated by Druid"

	| b556 jump5 jump3 jump1 t1 s2 currentBlock s49 jump6 live jump4 s45 jump2 t2 s52 b560 t0 s48 s50 |
	live := 0.
	t0 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t0).
	t1 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t1).
	t2 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t2).
	self annotateBytecode: self Label.
	(self ssValue: 1) copyToReg: t0.
	(self ssValue: 0) copyToReg: t1.
	self MoveR: t0 R: t2.
	self AndCq: 7 R: t2.
	self CmpCq: 0 R: t2.
	jump1 := self JumpNonZero: 0.
	self MoveM64: 0 r: t0 R: t2.
	self AndCq: 16r3FFFF7 R: t2.
	self CmpCq: 0 R: t2.
	jump2 := self JumpNonZero: 0.
	self MoveM64: 8 r: t0 R: t2.
	b560 := self Label.
	self MoveR: t2 R: t0.
	self AndCq: 7 R: t0.
	self CmpCq: 0 R: t0.
	jump3 := self JumpNonZero: 0.
	self MoveM64: 0 r: t2 R: t0.
	self AndCq: 16r3FFFF7 R: t0.
	self CmpCq: 0 R: t0.
	jump4 := self JumpNonZero: 0.
	self MoveM64: 8 r: t2 R: t0.
	self MoveR: t0 R: t2.
	jump5 := self Jump: b560.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	jump2 jmpTarget: currentBlock.
	jump3 jmpTarget: currentBlock.
	jump4 jmpTarget: currentBlock.
	self MoveR: t1 R: t0.
	self AndCq: 7 R: t0.
	self CmpCq: 0 R: t0.
	jump4 := self JumpNonZero: 0.
	self MoveM64: 0 r: t1 R: t0.
	self AndCq: 16r3FFFF7 R: t0.
	self CmpCq: 0 R: t0.
	jump3 := self JumpNonZero: 0.
	self MoveM64: 8 r: t1 R: t0.
	b556 := self Label.
	self MoveR: t0 R: t2.
	self AndCq: 7 R: t2.
	self CmpCq: 0 R: t2.
	jump2 := self JumpNonZero: 0.
	self MoveM64: 0 r: t0 R: t2.
	self AndCq: 16r3FFFF7 R: t2.
	self CmpCq: 0 R: t2.
	jump1 := self JumpNonZero: 0.
	self MoveM64: 8 r: t0 R: t2.
	self MoveR: t2 R: t0.
	jump6 := self Jump: b556.
	currentBlock := self Label.
	jump4 jmpTarget: currentBlock.
	jump3 jmpTarget: currentBlock.
	jump2 jmpTarget: currentBlock.
	jump1 jmpTarget: currentBlock.
	self ssPop: 2 popSpilled: true.
	(self ssValue: 1) copyToReg: t2.
	s45 := objectMemory trueObject.
	self ssFlushStackExceptTop: 0.
	self CmpCq: s45 R: t2.
	jump1 := self JumpNonZero: 0.
	s48 := bytecodePC.
	s49 := s48 + 5.
	self Jump: (self ensureFixupAt: s49).
	deadCode := true.
	jump2 := self Jump: 0.
	deadCode := false.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	s52 := objectMemory falseObject.
	self CmpCq: s52 R: t2.
	jump1 := self JumpZero: 0.
	self MoveR: t2 R: TempReg.
	self CallRT: ceSendMustBeBooleanTrampoline.
	currentBlock := self Label.
	jump2 jmpTarget: currentBlock.
	jump1 jmpTarget: currentBlock.
	^ 0
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_bytecodePrimIdenticalSistaV1_shortConditionalJumpTrue_5 [
	"AutoGenerated by Druid"

	| b556 jump5 jump3 jump1 t1 s2 currentBlock s49 jump6 live jump4 s45 jump2 t2 s52 b560 t0 s48 s50 |
	live := 0.
	t0 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t0).
	t1 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t1).
	t2 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t2).
	self annotateBytecode: self Label.
	(self ssValue: 1) copyToReg: t0.
	(self ssValue: 0) copyToReg: t1.
	self MoveR: t0 R: t2.
	self AndCq: 7 R: t2.
	self CmpCq: 0 R: t2.
	jump1 := self JumpNonZero: 0.
	self MoveM64: 0 r: t0 R: t2.
	self AndCq: 16r3FFFF7 R: t2.
	self CmpCq: 0 R: t2.
	jump2 := self JumpNonZero: 0.
	self MoveM64: 8 r: t0 R: t2.
	b560 := self Label.
	self MoveR: t2 R: t0.
	self AndCq: 7 R: t0.
	self CmpCq: 0 R: t0.
	jump3 := self JumpNonZero: 0.
	self MoveM64: 0 r: t2 R: t0.
	self AndCq: 16r3FFFF7 R: t0.
	self CmpCq: 0 R: t0.
	jump4 := self JumpNonZero: 0.
	self MoveM64: 8 r: t2 R: t0.
	self MoveR: t0 R: t2.
	jump5 := self Jump: b560.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	jump2 jmpTarget: currentBlock.
	jump3 jmpTarget: currentBlock.
	jump4 jmpTarget: currentBlock.
	self MoveR: t1 R: t0.
	self AndCq: 7 R: t0.
	self CmpCq: 0 R: t0.
	jump4 := self JumpNonZero: 0.
	self MoveM64: 0 r: t1 R: t0.
	self AndCq: 16r3FFFF7 R: t0.
	self CmpCq: 0 R: t0.
	jump3 := self JumpNonZero: 0.
	self MoveM64: 8 r: t1 R: t0.
	b556 := self Label.
	self MoveR: t0 R: t2.
	self AndCq: 7 R: t2.
	self CmpCq: 0 R: t2.
	jump2 := self JumpNonZero: 0.
	self MoveM64: 0 r: t0 R: t2.
	self AndCq: 16r3FFFF7 R: t2.
	self CmpCq: 0 R: t2.
	jump1 := self JumpNonZero: 0.
	self MoveM64: 8 r: t0 R: t2.
	self MoveR: t2 R: t0.
	jump6 := self Jump: b556.
	currentBlock := self Label.
	jump4 jmpTarget: currentBlock.
	jump3 jmpTarget: currentBlock.
	jump2 jmpTarget: currentBlock.
	jump1 jmpTarget: currentBlock.
	self ssPop: 2 popSpilled: true.
	(self ssValue: 1) copyToReg: t2.
	s45 := objectMemory trueObject.
	self ssFlushStackExceptTop: 0.
	self CmpCq: s45 R: t2.
	jump1 := self JumpNonZero: 0.
	s48 := bytecodePC.
	s49 := s48 + 6.
	self Jump: (self ensureFixupAt: s49).
	deadCode := true.
	jump2 := self Jump: 0.
	deadCode := false.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	s52 := objectMemory falseObject.
	self CmpCq: s52 R: t2.
	jump1 := self JumpZero: 0.
	self MoveR: t2 R: TempReg.
	self CallRT: ceSendMustBeBooleanTrampoline.
	currentBlock := self Label.
	jump2 jmpTarget: currentBlock.
	jump1 jmpTarget: currentBlock.
	^ 0
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_bytecodePrimIdenticalSistaV1_shortConditionalJumpTrue_6 [
	"AutoGenerated by Druid"

	| b556 jump5 jump3 jump1 t1 s2 currentBlock s49 jump6 live jump4 s45 jump2 t2 s52 b560 t0 s48 s50 |
	live := 0.
	t0 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t0).
	t1 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t1).
	t2 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t2).
	self annotateBytecode: self Label.
	(self ssValue: 1) copyToReg: t0.
	(self ssValue: 0) copyToReg: t1.
	self MoveR: t0 R: t2.
	self AndCq: 7 R: t2.
	self CmpCq: 0 R: t2.
	jump1 := self JumpNonZero: 0.
	self MoveM64: 0 r: t0 R: t2.
	self AndCq: 16r3FFFF7 R: t2.
	self CmpCq: 0 R: t2.
	jump2 := self JumpNonZero: 0.
	self MoveM64: 8 r: t0 R: t2.
	b560 := self Label.
	self MoveR: t2 R: t0.
	self AndCq: 7 R: t0.
	self CmpCq: 0 R: t0.
	jump3 := self JumpNonZero: 0.
	self MoveM64: 0 r: t2 R: t0.
	self AndCq: 16r3FFFF7 R: t0.
	self CmpCq: 0 R: t0.
	jump4 := self JumpNonZero: 0.
	self MoveM64: 8 r: t2 R: t0.
	self MoveR: t0 R: t2.
	jump5 := self Jump: b560.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	jump2 jmpTarget: currentBlock.
	jump3 jmpTarget: currentBlock.
	jump4 jmpTarget: currentBlock.
	self MoveR: t1 R: t0.
	self AndCq: 7 R: t0.
	self CmpCq: 0 R: t0.
	jump4 := self JumpNonZero: 0.
	self MoveM64: 0 r: t1 R: t0.
	self AndCq: 16r3FFFF7 R: t0.
	self CmpCq: 0 R: t0.
	jump3 := self JumpNonZero: 0.
	self MoveM64: 8 r: t1 R: t0.
	b556 := self Label.
	self MoveR: t0 R: t2.
	self AndCq: 7 R: t2.
	self CmpCq: 0 R: t2.
	jump2 := self JumpNonZero: 0.
	self MoveM64: 0 r: t0 R: t2.
	self AndCq: 16r3FFFF7 R: t2.
	self CmpCq: 0 R: t2.
	jump1 := self JumpNonZero: 0.
	self MoveM64: 8 r: t0 R: t2.
	self MoveR: t2 R: t0.
	jump6 := self Jump: b556.
	currentBlock := self Label.
	jump4 jmpTarget: currentBlock.
	jump3 jmpTarget: currentBlock.
	jump2 jmpTarget: currentBlock.
	jump1 jmpTarget: currentBlock.
	self ssPop: 2 popSpilled: true.
	(self ssValue: 1) copyToReg: t2.
	s45 := objectMemory trueObject.
	self ssFlushStackExceptTop: 0.
	self CmpCq: s45 R: t2.
	jump1 := self JumpNonZero: 0.
	s48 := bytecodePC.
	s49 := s48 + 7.
	self Jump: (self ensureFixupAt: s49).
	deadCode := true.
	jump2 := self Jump: 0.
	deadCode := false.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	s52 := objectMemory falseObject.
	self CmpCq: s52 R: t2.
	jump1 := self JumpZero: 0.
	self MoveR: t2 R: TempReg.
	self CallRT: ceSendMustBeBooleanTrampoline.
	currentBlock := self Label.
	jump2 jmpTarget: currentBlock.
	jump1 jmpTarget: currentBlock.
	^ 0
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_bytecodePrimIdenticalSistaV1_shortConditionalJumpTrue_7 [
	"AutoGenerated by Druid"

	| b556 jump5 jump3 jump1 t1 s2 currentBlock s49 jump6 live jump4 s45 jump2 t2 s52 b560 t0 s48 s50 |
	live := 0.
	t0 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t0).
	t1 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t1).
	t2 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t2).
	self annotateBytecode: self Label.
	(self ssValue: 1) copyToReg: t0.
	(self ssValue: 0) copyToReg: t1.
	self MoveR: t0 R: t2.
	self AndCq: 7 R: t2.
	self CmpCq: 0 R: t2.
	jump1 := self JumpNonZero: 0.
	self MoveM64: 0 r: t0 R: t2.
	self AndCq: 16r3FFFF7 R: t2.
	self CmpCq: 0 R: t2.
	jump2 := self JumpNonZero: 0.
	self MoveM64: 8 r: t0 R: t2.
	b560 := self Label.
	self MoveR: t2 R: t0.
	self AndCq: 7 R: t0.
	self CmpCq: 0 R: t0.
	jump3 := self JumpNonZero: 0.
	self MoveM64: 0 r: t2 R: t0.
	self AndCq: 16r3FFFF7 R: t0.
	self CmpCq: 0 R: t0.
	jump4 := self JumpNonZero: 0.
	self MoveM64: 8 r: t2 R: t0.
	self MoveR: t0 R: t2.
	jump5 := self Jump: b560.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	jump2 jmpTarget: currentBlock.
	jump3 jmpTarget: currentBlock.
	jump4 jmpTarget: currentBlock.
	self MoveR: t1 R: t0.
	self AndCq: 7 R: t0.
	self CmpCq: 0 R: t0.
	jump4 := self JumpNonZero: 0.
	self MoveM64: 0 r: t1 R: t0.
	self AndCq: 16r3FFFF7 R: t0.
	self CmpCq: 0 R: t0.
	jump3 := self JumpNonZero: 0.
	self MoveM64: 8 r: t1 R: t0.
	b556 := self Label.
	self MoveR: t0 R: t2.
	self AndCq: 7 R: t2.
	self CmpCq: 0 R: t2.
	jump2 := self JumpNonZero: 0.
	self MoveM64: 0 r: t0 R: t2.
	self AndCq: 16r3FFFF7 R: t2.
	self CmpCq: 0 R: t2.
	jump1 := self JumpNonZero: 0.
	self MoveM64: 8 r: t0 R: t2.
	self MoveR: t2 R: t0.
	jump6 := self Jump: b556.
	currentBlock := self Label.
	jump4 jmpTarget: currentBlock.
	jump3 jmpTarget: currentBlock.
	jump2 jmpTarget: currentBlock.
	jump1 jmpTarget: currentBlock.
	self ssPop: 2 popSpilled: true.
	(self ssValue: 1) copyToReg: t2.
	s45 := objectMemory trueObject.
	self ssFlushStackExceptTop: 0.
	self CmpCq: s45 R: t2.
	jump1 := self JumpNonZero: 0.
	s48 := bytecodePC.
	s49 := s48 + 8.
	self Jump: (self ensureFixupAt: s49).
	deadCode := true.
	jump2 := self Jump: 0.
	deadCode := false.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	s52 := objectMemory falseObject.
	self CmpCq: s52 R: t2.
	jump1 := self JumpZero: 0.
	self MoveR: t2 R: TempReg.
	self CallRT: ceSendMustBeBooleanTrampoline.
	currentBlock := self Label.
	jump2 jmpTarget: currentBlock.
	jump1 jmpTarget: currentBlock.
	^ 0
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_bytecodePrimIdenticalSistaV1_shortConditionalJumpTrue_8 [
	"AutoGenerated by Druid"

	| b556 jump5 jump3 jump1 t1 s2 currentBlock s49 jump6 live jump4 s45 jump2 t2 s52 b560 t0 s48 s50 |
	live := 0.
	t0 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t0).
	t1 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t1).
	t2 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t2).
	self annotateBytecode: self Label.
	(self ssValue: 1) copyToReg: t0.
	(self ssValue: 0) copyToReg: t1.
	self MoveR: t0 R: t2.
	self AndCq: 7 R: t2.
	self CmpCq: 0 R: t2.
	jump1 := self JumpNonZero: 0.
	self MoveM64: 0 r: t0 R: t2.
	self AndCq: 16r3FFFF7 R: t2.
	self CmpCq: 0 R: t2.
	jump2 := self JumpNonZero: 0.
	self MoveM64: 8 r: t0 R: t2.
	b560 := self Label.
	self MoveR: t2 R: t0.
	self AndCq: 7 R: t0.
	self CmpCq: 0 R: t0.
	jump3 := self JumpNonZero: 0.
	self MoveM64: 0 r: t2 R: t0.
	self AndCq: 16r3FFFF7 R: t0.
	self CmpCq: 0 R: t0.
	jump4 := self JumpNonZero: 0.
	self MoveM64: 8 r: t2 R: t0.
	self MoveR: t0 R: t2.
	jump5 := self Jump: b560.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	jump2 jmpTarget: currentBlock.
	jump3 jmpTarget: currentBlock.
	jump4 jmpTarget: currentBlock.
	self MoveR: t1 R: t0.
	self AndCq: 7 R: t0.
	self CmpCq: 0 R: t0.
	jump4 := self JumpNonZero: 0.
	self MoveM64: 0 r: t1 R: t0.
	self AndCq: 16r3FFFF7 R: t0.
	self CmpCq: 0 R: t0.
	jump3 := self JumpNonZero: 0.
	self MoveM64: 8 r: t1 R: t0.
	b556 := self Label.
	self MoveR: t0 R: t2.
	self AndCq: 7 R: t2.
	self CmpCq: 0 R: t2.
	jump2 := self JumpNonZero: 0.
	self MoveM64: 0 r: t0 R: t2.
	self AndCq: 16r3FFFF7 R: t2.
	self CmpCq: 0 R: t2.
	jump1 := self JumpNonZero: 0.
	self MoveM64: 8 r: t0 R: t2.
	self MoveR: t2 R: t0.
	jump6 := self Jump: b556.
	currentBlock := self Label.
	jump4 jmpTarget: currentBlock.
	jump3 jmpTarget: currentBlock.
	jump2 jmpTarget: currentBlock.
	jump1 jmpTarget: currentBlock.
	self ssPop: 2 popSpilled: true.
	(self ssValue: 1) copyToReg: t2.
	s45 := objectMemory trueObject.
	self ssFlushStackExceptTop: 0.
	self CmpCq: s45 R: t2.
	jump1 := self JumpNonZero: 0.
	s48 := bytecodePC.
	s49 := s48 + 9.
	self Jump: (self ensureFixupAt: s49).
	deadCode := true.
	jump2 := self Jump: 0.
	deadCode := false.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	s52 := objectMemory falseObject.
	self CmpCq: s52 R: t2.
	jump1 := self JumpZero: 0.
	self MoveR: t2 R: TempReg.
	self CallRT: ceSendMustBeBooleanTrampoline.
	currentBlock := self Label.
	jump2 jmpTarget: currentBlock.
	jump1 jmpTarget: currentBlock.
	^ 0
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_bytecodePrimNotIdenticalSistaV1 [
	"AutoGenerated by Druid"

	| jump1 b507 s57 s54 t1 jump6 jump3 b503 currentBlock t3 t0 jump5 jump2 live t2 jump4 |
	live := 0.
	t0 := self allocateRegNotConflictingWith: live ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t0).
	t1 := self allocateRegNotConflictingWith: live ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t1).
	t2 := self allocateRegNotConflictingWith: live ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t2).
	t3 := self allocateRegNotConflictingWith: live ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t3).
	(self ssValue: 1) copyToReg: t0.
	(self ssValue: 0) copyToReg: t1.
	self MoveR: t0 R: t2.
	self AndCq: 7 R: t2.
	self CmpCq: 0 R: t2.
	jump1 := self JumpNonZero: 0.
	self MoveM64: 0 r: t0 R: t2.
	self AndCq: 16r3FFFF7 R: t2.
	self CmpCq: 0 R: t2.
	jump2 := self JumpNonZero: 0.
	self MoveM64: 8 r: t0 R: t2.
	b507 := self Label.
	self MoveR: t2 R: t0.
	self AndCq: 7 R: t0.
	self CmpCq: 0 R: t0.
	jump3 := self JumpNonZero: 0.
	self MoveM64: 0 r: t2 R: t0.
	self AndCq: 16r3FFFF7 R: t0.
	self CmpCq: 0 R: t0.
	jump4 := self JumpNonZero: 0.
	self MoveM64: 8 r: t2 R: t0.
	self MoveR: t0 R: t2.
	jump5 := self Jump: b507.
	currentBlock := self Label.
	jump3 jmpTarget: currentBlock.
	jump4 jmpTarget: currentBlock.
	self MoveR: t2 R: t0.
	jump4 := self Jump: 0.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	jump2 jmpTarget: currentBlock.
	currentBlock := self Label.
	jump4 jmpTarget: currentBlock.
	self MoveR: t1 R: t2.
	self AndCq: 7 R: t2.
	self CmpCq: 0 R: t2.
	jump4 := self JumpNonZero: 0.
	self MoveM64: 0 r: t1 R: t2.
	self AndCq: 16r3FFFF7 R: t2.
	self CmpCq: 0 R: t2.
	jump2 := self JumpNonZero: 0.
	self MoveM64: 8 r: t1 R: t2.
	b503 := self Label.
	self MoveR: t2 R: t3.
	self AndCq: 7 R: t3.
	self CmpCq: 0 R: t3.
	jump1 := self JumpNonZero: 0.
	self MoveM64: 0 r: t2 R: t3.
	self AndCq: 16r3FFFF7 R: t3.
	self CmpCq: 0 R: t3.
	jump3 := self JumpNonZero: 0.
	self MoveM64: 8 r: t2 R: t3.
	self MoveR: t3 R: t2.
	jump6 := self Jump: b503.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	jump3 jmpTarget: currentBlock.
	self MoveR: t2 R: t3.
	jump3 := self Jump: 0.
	currentBlock := self Label.
	jump4 jmpTarget: currentBlock.
	jump2 jmpTarget: currentBlock.
	self MoveR: t1 R: t3.
	currentBlock := self Label.
	jump3 jmpTarget: currentBlock.
	self ssPop: 2 popSpilled: true.
	self CmpR: t3 R: t0.
	jump3 := self JumpZero: 0.
	s54 := objectMemory trueObject.
	self MoveCq: s54 R: t3.
	jump2 := self Jump: 0.
	currentBlock := self Label.
	jump3 jmpTarget: currentBlock.
	s57 := objectMemory falseObject.
	self MoveCq: s57 R: t3.
	currentBlock := self Label.
	jump2 jmpTarget: currentBlock.
	self ssPushRegister: t3.
	^ 0
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_bytecodePrimNotIdenticalSistaV1_shortConditionalJumpFalse_10 [
	"AutoGenerated by Druid"

	| b556 jump5 jump3 jump1 t1 s2 currentBlock s49 jump6 live jump4 s45 jump2 t2 s52 b560 t0 s48 s50 |
	live := 0.
	t0 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t0).
	t1 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t1).
	t2 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t2).
	self annotateBytecode: self Label.
	(self ssValue: 1) copyToReg: t0.
	(self ssValue: 0) copyToReg: t1.
	self MoveR: t0 R: t2.
	self AndCq: 7 R: t2.
	self CmpCq: 0 R: t2.
	jump1 := self JumpNonZero: 0.
	self MoveM64: 0 r: t0 R: t2.
	self AndCq: 16r3FFFF7 R: t2.
	self CmpCq: 0 R: t2.
	jump2 := self JumpNonZero: 0.
	self MoveM64: 8 r: t0 R: t2.
	b560 := self Label.
	self MoveR: t2 R: t0.
	self AndCq: 7 R: t0.
	self CmpCq: 0 R: t0.
	jump3 := self JumpNonZero: 0.
	self MoveM64: 0 r: t2 R: t0.
	self AndCq: 16r3FFFF7 R: t0.
	self CmpCq: 0 R: t0.
	jump4 := self JumpNonZero: 0.
	self MoveM64: 8 r: t2 R: t0.
	self MoveR: t0 R: t2.
	jump5 := self Jump: b560.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	jump2 jmpTarget: currentBlock.
	jump3 jmpTarget: currentBlock.
	jump4 jmpTarget: currentBlock.
	self MoveR: t1 R: t0.
	self AndCq: 7 R: t0.
	self CmpCq: 0 R: t0.
	jump4 := self JumpNonZero: 0.
	self MoveM64: 0 r: t1 R: t0.
	self AndCq: 16r3FFFF7 R: t0.
	self CmpCq: 0 R: t0.
	jump3 := self JumpNonZero: 0.
	self MoveM64: 8 r: t1 R: t0.
	b556 := self Label.
	self MoveR: t0 R: t2.
	self AndCq: 7 R: t2.
	self CmpCq: 0 R: t2.
	jump2 := self JumpNonZero: 0.
	self MoveM64: 0 r: t0 R: t2.
	self AndCq: 16r3FFFF7 R: t2.
	self CmpCq: 0 R: t2.
	jump1 := self JumpNonZero: 0.
	self MoveM64: 8 r: t0 R: t2.
	self MoveR: t2 R: t0.
	jump6 := self Jump: b556.
	currentBlock := self Label.
	jump4 jmpTarget: currentBlock.
	jump3 jmpTarget: currentBlock.
	jump2 jmpTarget: currentBlock.
	jump1 jmpTarget: currentBlock.
	self ssPop: 2 popSpilled: true.
	(self ssValue: 1) copyToReg: t2.
	s45 := objectMemory falseObject.
	self ssFlushStackExceptTop: 0.
	self CmpCq: s45 R: t2.
	jump1 := self JumpNonZero: 0.
	s48 := bytecodePC.
	s49 := s48 + 3.
	self Jump: (self ensureFixupAt: s49).
	deadCode := true.
	jump2 := self Jump: 0.
	deadCode := false.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	s52 := objectMemory trueObject.
	self CmpCq: s52 R: t2.
	jump1 := self JumpZero: 0.
	self MoveR: t2 R: TempReg.
	self CallRT: ceSendMustBeBooleanTrampoline.
	currentBlock := self Label.
	jump2 jmpTarget: currentBlock.
	jump1 jmpTarget: currentBlock.
	^ 0
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_bytecodePrimNotIdenticalSistaV1_shortConditionalJumpFalse_11 [
	"AutoGenerated by Druid"

	| b556 jump5 jump3 jump1 t1 s2 currentBlock s49 jump6 live jump4 s45 jump2 t2 s52 b560 t0 s48 s50 |
	live := 0.
	t0 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t0).
	t1 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t1).
	t2 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t2).
	self annotateBytecode: self Label.
	(self ssValue: 1) copyToReg: t0.
	(self ssValue: 0) copyToReg: t1.
	self MoveR: t0 R: t2.
	self AndCq: 7 R: t2.
	self CmpCq: 0 R: t2.
	jump1 := self JumpNonZero: 0.
	self MoveM64: 0 r: t0 R: t2.
	self AndCq: 16r3FFFF7 R: t2.
	self CmpCq: 0 R: t2.
	jump2 := self JumpNonZero: 0.
	self MoveM64: 8 r: t0 R: t2.
	b560 := self Label.
	self MoveR: t2 R: t0.
	self AndCq: 7 R: t0.
	self CmpCq: 0 R: t0.
	jump3 := self JumpNonZero: 0.
	self MoveM64: 0 r: t2 R: t0.
	self AndCq: 16r3FFFF7 R: t0.
	self CmpCq: 0 R: t0.
	jump4 := self JumpNonZero: 0.
	self MoveM64: 8 r: t2 R: t0.
	self MoveR: t0 R: t2.
	jump5 := self Jump: b560.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	jump2 jmpTarget: currentBlock.
	jump3 jmpTarget: currentBlock.
	jump4 jmpTarget: currentBlock.
	self MoveR: t1 R: t0.
	self AndCq: 7 R: t0.
	self CmpCq: 0 R: t0.
	jump4 := self JumpNonZero: 0.
	self MoveM64: 0 r: t1 R: t0.
	self AndCq: 16r3FFFF7 R: t0.
	self CmpCq: 0 R: t0.
	jump3 := self JumpNonZero: 0.
	self MoveM64: 8 r: t1 R: t0.
	b556 := self Label.
	self MoveR: t0 R: t2.
	self AndCq: 7 R: t2.
	self CmpCq: 0 R: t2.
	jump2 := self JumpNonZero: 0.
	self MoveM64: 0 r: t0 R: t2.
	self AndCq: 16r3FFFF7 R: t2.
	self CmpCq: 0 R: t2.
	jump1 := self JumpNonZero: 0.
	self MoveM64: 8 r: t0 R: t2.
	self MoveR: t2 R: t0.
	jump6 := self Jump: b556.
	currentBlock := self Label.
	jump4 jmpTarget: currentBlock.
	jump3 jmpTarget: currentBlock.
	jump2 jmpTarget: currentBlock.
	jump1 jmpTarget: currentBlock.
	self ssPop: 2 popSpilled: true.
	(self ssValue: 1) copyToReg: t2.
	s45 := objectMemory falseObject.
	self ssFlushStackExceptTop: 0.
	self CmpCq: s45 R: t2.
	jump1 := self JumpNonZero: 0.
	s48 := bytecodePC.
	s49 := s48 + 4.
	self Jump: (self ensureFixupAt: s49).
	deadCode := true.
	jump2 := self Jump: 0.
	deadCode := false.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	s52 := objectMemory trueObject.
	self CmpCq: s52 R: t2.
	jump1 := self JumpZero: 0.
	self MoveR: t2 R: TempReg.
	self CallRT: ceSendMustBeBooleanTrampoline.
	currentBlock := self Label.
	jump2 jmpTarget: currentBlock.
	jump1 jmpTarget: currentBlock.
	^ 0
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_bytecodePrimNotIdenticalSistaV1_shortConditionalJumpFalse_12 [
	"AutoGenerated by Druid"

	| b556 jump5 jump3 jump1 t1 s2 currentBlock s49 jump6 live jump4 s45 jump2 t2 s52 b560 t0 s48 s50 |
	live := 0.
	t0 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t0).
	t1 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t1).
	t2 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t2).
	self annotateBytecode: self Label.
	(self ssValue: 1) copyToReg: t0.
	(self ssValue: 0) copyToReg: t1.
	self MoveR: t0 R: t2.
	self AndCq: 7 R: t2.
	self CmpCq: 0 R: t2.
	jump1 := self JumpNonZero: 0.
	self MoveM64: 0 r: t0 R: t2.
	self AndCq: 16r3FFFF7 R: t2.
	self CmpCq: 0 R: t2.
	jump2 := self JumpNonZero: 0.
	self MoveM64: 8 r: t0 R: t2.
	b560 := self Label.
	self MoveR: t2 R: t0.
	self AndCq: 7 R: t0.
	self CmpCq: 0 R: t0.
	jump3 := self JumpNonZero: 0.
	self MoveM64: 0 r: t2 R: t0.
	self AndCq: 16r3FFFF7 R: t0.
	self CmpCq: 0 R: t0.
	jump4 := self JumpNonZero: 0.
	self MoveM64: 8 r: t2 R: t0.
	self MoveR: t0 R: t2.
	jump5 := self Jump: b560.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	jump2 jmpTarget: currentBlock.
	jump3 jmpTarget: currentBlock.
	jump4 jmpTarget: currentBlock.
	self MoveR: t1 R: t0.
	self AndCq: 7 R: t0.
	self CmpCq: 0 R: t0.
	jump4 := self JumpNonZero: 0.
	self MoveM64: 0 r: t1 R: t0.
	self AndCq: 16r3FFFF7 R: t0.
	self CmpCq: 0 R: t0.
	jump3 := self JumpNonZero: 0.
	self MoveM64: 8 r: t1 R: t0.
	b556 := self Label.
	self MoveR: t0 R: t2.
	self AndCq: 7 R: t2.
	self CmpCq: 0 R: t2.
	jump2 := self JumpNonZero: 0.
	self MoveM64: 0 r: t0 R: t2.
	self AndCq: 16r3FFFF7 R: t2.
	self CmpCq: 0 R: t2.
	jump1 := self JumpNonZero: 0.
	self MoveM64: 8 r: t0 R: t2.
	self MoveR: t2 R: t0.
	jump6 := self Jump: b556.
	currentBlock := self Label.
	jump4 jmpTarget: currentBlock.
	jump3 jmpTarget: currentBlock.
	jump2 jmpTarget: currentBlock.
	jump1 jmpTarget: currentBlock.
	self ssPop: 2 popSpilled: true.
	(self ssValue: 1) copyToReg: t2.
	s45 := objectMemory falseObject.
	self ssFlushStackExceptTop: 0.
	self CmpCq: s45 R: t2.
	jump1 := self JumpNonZero: 0.
	s48 := bytecodePC.
	s49 := s48 + 5.
	self Jump: (self ensureFixupAt: s49).
	deadCode := true.
	jump2 := self Jump: 0.
	deadCode := false.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	s52 := objectMemory trueObject.
	self CmpCq: s52 R: t2.
	jump1 := self JumpZero: 0.
	self MoveR: t2 R: TempReg.
	self CallRT: ceSendMustBeBooleanTrampoline.
	currentBlock := self Label.
	jump2 jmpTarget: currentBlock.
	jump1 jmpTarget: currentBlock.
	^ 0
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_bytecodePrimNotIdenticalSistaV1_shortConditionalJumpFalse_13 [
	"AutoGenerated by Druid"

	| b556 jump5 jump3 jump1 t1 s2 currentBlock s49 jump6 live jump4 s45 jump2 t2 s52 b560 t0 s48 s50 |
	live := 0.
	t0 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t0).
	t1 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t1).
	t2 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t2).
	self annotateBytecode: self Label.
	(self ssValue: 1) copyToReg: t0.
	(self ssValue: 0) copyToReg: t1.
	self MoveR: t0 R: t2.
	self AndCq: 7 R: t2.
	self CmpCq: 0 R: t2.
	jump1 := self JumpNonZero: 0.
	self MoveM64: 0 r: t0 R: t2.
	self AndCq: 16r3FFFF7 R: t2.
	self CmpCq: 0 R: t2.
	jump2 := self JumpNonZero: 0.
	self MoveM64: 8 r: t0 R: t2.
	b560 := self Label.
	self MoveR: t2 R: t0.
	self AndCq: 7 R: t0.
	self CmpCq: 0 R: t0.
	jump3 := self JumpNonZero: 0.
	self MoveM64: 0 r: t2 R: t0.
	self AndCq: 16r3FFFF7 R: t0.
	self CmpCq: 0 R: t0.
	jump4 := self JumpNonZero: 0.
	self MoveM64: 8 r: t2 R: t0.
	self MoveR: t0 R: t2.
	jump5 := self Jump: b560.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	jump2 jmpTarget: currentBlock.
	jump3 jmpTarget: currentBlock.
	jump4 jmpTarget: currentBlock.
	self MoveR: t1 R: t0.
	self AndCq: 7 R: t0.
	self CmpCq: 0 R: t0.
	jump4 := self JumpNonZero: 0.
	self MoveM64: 0 r: t1 R: t0.
	self AndCq: 16r3FFFF7 R: t0.
	self CmpCq: 0 R: t0.
	jump3 := self JumpNonZero: 0.
	self MoveM64: 8 r: t1 R: t0.
	b556 := self Label.
	self MoveR: t0 R: t2.
	self AndCq: 7 R: t2.
	self CmpCq: 0 R: t2.
	jump2 := self JumpNonZero: 0.
	self MoveM64: 0 r: t0 R: t2.
	self AndCq: 16r3FFFF7 R: t2.
	self CmpCq: 0 R: t2.
	jump1 := self JumpNonZero: 0.
	self MoveM64: 8 r: t0 R: t2.
	self MoveR: t2 R: t0.
	jump6 := self Jump: b556.
	currentBlock := self Label.
	jump4 jmpTarget: currentBlock.
	jump3 jmpTarget: currentBlock.
	jump2 jmpTarget: currentBlock.
	jump1 jmpTarget: currentBlock.
	self ssPop: 2 popSpilled: true.
	(self ssValue: 1) copyToReg: t2.
	s45 := objectMemory falseObject.
	self ssFlushStackExceptTop: 0.
	self CmpCq: s45 R: t2.
	jump1 := self JumpNonZero: 0.
	s48 := bytecodePC.
	s49 := s48 + 6.
	self Jump: (self ensureFixupAt: s49).
	deadCode := true.
	jump2 := self Jump: 0.
	deadCode := false.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	s52 := objectMemory trueObject.
	self CmpCq: s52 R: t2.
	jump1 := self JumpZero: 0.
	self MoveR: t2 R: TempReg.
	self CallRT: ceSendMustBeBooleanTrampoline.
	currentBlock := self Label.
	jump2 jmpTarget: currentBlock.
	jump1 jmpTarget: currentBlock.
	^ 0
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_bytecodePrimNotIdenticalSistaV1_shortConditionalJumpFalse_14 [
	"AutoGenerated by Druid"

	| b556 jump5 jump3 jump1 t1 s2 currentBlock s49 jump6 live jump4 s45 jump2 t2 s52 b560 t0 s48 s50 |
	live := 0.
	t0 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t0).
	t1 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t1).
	t2 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t2).
	self annotateBytecode: self Label.
	(self ssValue: 1) copyToReg: t0.
	(self ssValue: 0) copyToReg: t1.
	self MoveR: t0 R: t2.
	self AndCq: 7 R: t2.
	self CmpCq: 0 R: t2.
	jump1 := self JumpNonZero: 0.
	self MoveM64: 0 r: t0 R: t2.
	self AndCq: 16r3FFFF7 R: t2.
	self CmpCq: 0 R: t2.
	jump2 := self JumpNonZero: 0.
	self MoveM64: 8 r: t0 R: t2.
	b560 := self Label.
	self MoveR: t2 R: t0.
	self AndCq: 7 R: t0.
	self CmpCq: 0 R: t0.
	jump3 := self JumpNonZero: 0.
	self MoveM64: 0 r: t2 R: t0.
	self AndCq: 16r3FFFF7 R: t0.
	self CmpCq: 0 R: t0.
	jump4 := self JumpNonZero: 0.
	self MoveM64: 8 r: t2 R: t0.
	self MoveR: t0 R: t2.
	jump5 := self Jump: b560.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	jump2 jmpTarget: currentBlock.
	jump3 jmpTarget: currentBlock.
	jump4 jmpTarget: currentBlock.
	self MoveR: t1 R: t0.
	self AndCq: 7 R: t0.
	self CmpCq: 0 R: t0.
	jump4 := self JumpNonZero: 0.
	self MoveM64: 0 r: t1 R: t0.
	self AndCq: 16r3FFFF7 R: t0.
	self CmpCq: 0 R: t0.
	jump3 := self JumpNonZero: 0.
	self MoveM64: 8 r: t1 R: t0.
	b556 := self Label.
	self MoveR: t0 R: t2.
	self AndCq: 7 R: t2.
	self CmpCq: 0 R: t2.
	jump2 := self JumpNonZero: 0.
	self MoveM64: 0 r: t0 R: t2.
	self AndCq: 16r3FFFF7 R: t2.
	self CmpCq: 0 R: t2.
	jump1 := self JumpNonZero: 0.
	self MoveM64: 8 r: t0 R: t2.
	self MoveR: t2 R: t0.
	jump6 := self Jump: b556.
	currentBlock := self Label.
	jump4 jmpTarget: currentBlock.
	jump3 jmpTarget: currentBlock.
	jump2 jmpTarget: currentBlock.
	jump1 jmpTarget: currentBlock.
	self ssPop: 2 popSpilled: true.
	(self ssValue: 1) copyToReg: t2.
	s45 := objectMemory falseObject.
	self ssFlushStackExceptTop: 0.
	self CmpCq: s45 R: t2.
	jump1 := self JumpNonZero: 0.
	s48 := bytecodePC.
	s49 := s48 + 7.
	self Jump: (self ensureFixupAt: s49).
	deadCode := true.
	jump2 := self Jump: 0.
	deadCode := false.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	s52 := objectMemory trueObject.
	self CmpCq: s52 R: t2.
	jump1 := self JumpZero: 0.
	self MoveR: t2 R: TempReg.
	self CallRT: ceSendMustBeBooleanTrampoline.
	currentBlock := self Label.
	jump2 jmpTarget: currentBlock.
	jump1 jmpTarget: currentBlock.
	^ 0
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_bytecodePrimNotIdenticalSistaV1_shortConditionalJumpFalse_15 [
	"AutoGenerated by Druid"

	| b556 jump5 jump3 jump1 t1 s2 currentBlock s49 jump6 live jump4 s45 jump2 t2 s52 b560 t0 s48 s50 |
	live := 0.
	t0 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t0).
	t1 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t1).
	t2 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t2).
	self annotateBytecode: self Label.
	(self ssValue: 1) copyToReg: t0.
	(self ssValue: 0) copyToReg: t1.
	self MoveR: t0 R: t2.
	self AndCq: 7 R: t2.
	self CmpCq: 0 R: t2.
	jump1 := self JumpNonZero: 0.
	self MoveM64: 0 r: t0 R: t2.
	self AndCq: 16r3FFFF7 R: t2.
	self CmpCq: 0 R: t2.
	jump2 := self JumpNonZero: 0.
	self MoveM64: 8 r: t0 R: t2.
	b560 := self Label.
	self MoveR: t2 R: t0.
	self AndCq: 7 R: t0.
	self CmpCq: 0 R: t0.
	jump3 := self JumpNonZero: 0.
	self MoveM64: 0 r: t2 R: t0.
	self AndCq: 16r3FFFF7 R: t0.
	self CmpCq: 0 R: t0.
	jump4 := self JumpNonZero: 0.
	self MoveM64: 8 r: t2 R: t0.
	self MoveR: t0 R: t2.
	jump5 := self Jump: b560.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	jump2 jmpTarget: currentBlock.
	jump3 jmpTarget: currentBlock.
	jump4 jmpTarget: currentBlock.
	self MoveR: t1 R: t0.
	self AndCq: 7 R: t0.
	self CmpCq: 0 R: t0.
	jump4 := self JumpNonZero: 0.
	self MoveM64: 0 r: t1 R: t0.
	self AndCq: 16r3FFFF7 R: t0.
	self CmpCq: 0 R: t0.
	jump3 := self JumpNonZero: 0.
	self MoveM64: 8 r: t1 R: t0.
	b556 := self Label.
	self MoveR: t0 R: t2.
	self AndCq: 7 R: t2.
	self CmpCq: 0 R: t2.
	jump2 := self JumpNonZero: 0.
	self MoveM64: 0 r: t0 R: t2.
	self AndCq: 16r3FFFF7 R: t2.
	self CmpCq: 0 R: t2.
	jump1 := self JumpNonZero: 0.
	self MoveM64: 8 r: t0 R: t2.
	self MoveR: t2 R: t0.
	jump6 := self Jump: b556.
	currentBlock := self Label.
	jump4 jmpTarget: currentBlock.
	jump3 jmpTarget: currentBlock.
	jump2 jmpTarget: currentBlock.
	jump1 jmpTarget: currentBlock.
	self ssPop: 2 popSpilled: true.
	(self ssValue: 1) copyToReg: t2.
	s45 := objectMemory falseObject.
	self ssFlushStackExceptTop: 0.
	self CmpCq: s45 R: t2.
	jump1 := self JumpNonZero: 0.
	s48 := bytecodePC.
	s49 := s48 + 8.
	self Jump: (self ensureFixupAt: s49).
	deadCode := true.
	jump2 := self Jump: 0.
	deadCode := false.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	s52 := objectMemory trueObject.
	self CmpCq: s52 R: t2.
	jump1 := self JumpZero: 0.
	self MoveR: t2 R: TempReg.
	self CallRT: ceSendMustBeBooleanTrampoline.
	currentBlock := self Label.
	jump2 jmpTarget: currentBlock.
	jump1 jmpTarget: currentBlock.
	^ 0
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_bytecodePrimNotIdenticalSistaV1_shortConditionalJumpFalse_16 [
	"AutoGenerated by Druid"

	| b556 jump5 jump3 jump1 t1 s2 currentBlock s49 jump6 live jump4 s45 jump2 t2 s52 b560 t0 s48 s50 |
	live := 0.
	t0 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t0).
	t1 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t1).
	t2 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t2).
	self annotateBytecode: self Label.
	(self ssValue: 1) copyToReg: t0.
	(self ssValue: 0) copyToReg: t1.
	self MoveR: t0 R: t2.
	self AndCq: 7 R: t2.
	self CmpCq: 0 R: t2.
	jump1 := self JumpNonZero: 0.
	self MoveM64: 0 r: t0 R: t2.
	self AndCq: 16r3FFFF7 R: t2.
	self CmpCq: 0 R: t2.
	jump2 := self JumpNonZero: 0.
	self MoveM64: 8 r: t0 R: t2.
	b560 := self Label.
	self MoveR: t2 R: t0.
	self AndCq: 7 R: t0.
	self CmpCq: 0 R: t0.
	jump3 := self JumpNonZero: 0.
	self MoveM64: 0 r: t2 R: t0.
	self AndCq: 16r3FFFF7 R: t0.
	self CmpCq: 0 R: t0.
	jump4 := self JumpNonZero: 0.
	self MoveM64: 8 r: t2 R: t0.
	self MoveR: t0 R: t2.
	jump5 := self Jump: b560.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	jump2 jmpTarget: currentBlock.
	jump3 jmpTarget: currentBlock.
	jump4 jmpTarget: currentBlock.
	self MoveR: t1 R: t0.
	self AndCq: 7 R: t0.
	self CmpCq: 0 R: t0.
	jump4 := self JumpNonZero: 0.
	self MoveM64: 0 r: t1 R: t0.
	self AndCq: 16r3FFFF7 R: t0.
	self CmpCq: 0 R: t0.
	jump3 := self JumpNonZero: 0.
	self MoveM64: 8 r: t1 R: t0.
	b556 := self Label.
	self MoveR: t0 R: t2.
	self AndCq: 7 R: t2.
	self CmpCq: 0 R: t2.
	jump2 := self JumpNonZero: 0.
	self MoveM64: 0 r: t0 R: t2.
	self AndCq: 16r3FFFF7 R: t2.
	self CmpCq: 0 R: t2.
	jump1 := self JumpNonZero: 0.
	self MoveM64: 8 r: t0 R: t2.
	self MoveR: t2 R: t0.
	jump6 := self Jump: b556.
	currentBlock := self Label.
	jump4 jmpTarget: currentBlock.
	jump3 jmpTarget: currentBlock.
	jump2 jmpTarget: currentBlock.
	jump1 jmpTarget: currentBlock.
	self ssPop: 2 popSpilled: true.
	(self ssValue: 1) copyToReg: t2.
	s45 := objectMemory falseObject.
	self ssFlushStackExceptTop: 0.
	self CmpCq: s45 R: t2.
	jump1 := self JumpNonZero: 0.
	s48 := bytecodePC.
	s49 := s48 + 9.
	self Jump: (self ensureFixupAt: s49).
	deadCode := true.
	jump2 := self Jump: 0.
	deadCode := false.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	s52 := objectMemory trueObject.
	self CmpCq: s52 R: t2.
	jump1 := self JumpZero: 0.
	self MoveR: t2 R: TempReg.
	self CallRT: ceSendMustBeBooleanTrampoline.
	currentBlock := self Label.
	jump2 jmpTarget: currentBlock.
	jump1 jmpTarget: currentBlock.
	^ 0
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_bytecodePrimNotIdenticalSistaV1_shortConditionalJumpFalse_9 [
	"AutoGenerated by Druid"

	| b556 jump5 jump3 jump1 t1 s2 currentBlock s49 jump6 live jump4 s45 jump2 t2 s52 b560 t0 s48 s50 |
	live := 0.
	t0 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t0).
	t1 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t1).
	t2 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t2).
	self annotateBytecode: self Label.
	(self ssValue: 1) copyToReg: t0.
	(self ssValue: 0) copyToReg: t1.
	self MoveR: t0 R: t2.
	self AndCq: 7 R: t2.
	self CmpCq: 0 R: t2.
	jump1 := self JumpNonZero: 0.
	self MoveM64: 0 r: t0 R: t2.
	self AndCq: 16r3FFFF7 R: t2.
	self CmpCq: 0 R: t2.
	jump2 := self JumpNonZero: 0.
	self MoveM64: 8 r: t0 R: t2.
	b560 := self Label.
	self MoveR: t2 R: t0.
	self AndCq: 7 R: t0.
	self CmpCq: 0 R: t0.
	jump3 := self JumpNonZero: 0.
	self MoveM64: 0 r: t2 R: t0.
	self AndCq: 16r3FFFF7 R: t0.
	self CmpCq: 0 R: t0.
	jump4 := self JumpNonZero: 0.
	self MoveM64: 8 r: t2 R: t0.
	self MoveR: t0 R: t2.
	jump5 := self Jump: b560.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	jump2 jmpTarget: currentBlock.
	jump3 jmpTarget: currentBlock.
	jump4 jmpTarget: currentBlock.
	self MoveR: t1 R: t0.
	self AndCq: 7 R: t0.
	self CmpCq: 0 R: t0.
	jump4 := self JumpNonZero: 0.
	self MoveM64: 0 r: t1 R: t0.
	self AndCq: 16r3FFFF7 R: t0.
	self CmpCq: 0 R: t0.
	jump3 := self JumpNonZero: 0.
	self MoveM64: 8 r: t1 R: t0.
	b556 := self Label.
	self MoveR: t0 R: t2.
	self AndCq: 7 R: t2.
	self CmpCq: 0 R: t2.
	jump2 := self JumpNonZero: 0.
	self MoveM64: 0 r: t0 R: t2.
	self AndCq: 16r3FFFF7 R: t2.
	self CmpCq: 0 R: t2.
	jump1 := self JumpNonZero: 0.
	self MoveM64: 8 r: t0 R: t2.
	self MoveR: t2 R: t0.
	jump6 := self Jump: b556.
	currentBlock := self Label.
	jump4 jmpTarget: currentBlock.
	jump3 jmpTarget: currentBlock.
	jump2 jmpTarget: currentBlock.
	jump1 jmpTarget: currentBlock.
	self ssPop: 2 popSpilled: true.
	(self ssValue: 1) copyToReg: t2.
	s45 := objectMemory falseObject.
	self ssFlushStackExceptTop: 0.
	self CmpCq: s45 R: t2.
	jump1 := self JumpNonZero: 0.
	s48 := bytecodePC.
	s49 := s48 + 2.
	self Jump: (self ensureFixupAt: s49).
	deadCode := true.
	jump2 := self Jump: 0.
	deadCode := false.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	s52 := objectMemory trueObject.
	self CmpCq: s52 R: t2.
	jump1 := self JumpZero: 0.
	self MoveR: t2 R: TempReg.
	self CallRT: ceSendMustBeBooleanTrampoline.
	currentBlock := self Label.
	jump2 jmpTarget: currentBlock.
	jump1 jmpTarget: currentBlock.
	^ 0
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_bytecodePrimNotIdenticalSistaV1_shortConditionalJumpTrue_1 [
	"AutoGenerated by Druid"

	| b556 jump5 jump3 jump1 t1 s2 currentBlock s49 jump6 live jump4 s45 jump2 t2 s52 b560 t0 s48 s50 |
	live := 0.
	t0 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t0).
	t1 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t1).
	t2 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t2).
	self annotateBytecode: self Label.
	(self ssValue: 1) copyToReg: t0.
	(self ssValue: 0) copyToReg: t1.
	self MoveR: t0 R: t2.
	self AndCq: 7 R: t2.
	self CmpCq: 0 R: t2.
	jump1 := self JumpNonZero: 0.
	self MoveM64: 0 r: t0 R: t2.
	self AndCq: 16r3FFFF7 R: t2.
	self CmpCq: 0 R: t2.
	jump2 := self JumpNonZero: 0.
	self MoveM64: 8 r: t0 R: t2.
	b560 := self Label.
	self MoveR: t2 R: t0.
	self AndCq: 7 R: t0.
	self CmpCq: 0 R: t0.
	jump3 := self JumpNonZero: 0.
	self MoveM64: 0 r: t2 R: t0.
	self AndCq: 16r3FFFF7 R: t0.
	self CmpCq: 0 R: t0.
	jump4 := self JumpNonZero: 0.
	self MoveM64: 8 r: t2 R: t0.
	self MoveR: t0 R: t2.
	jump5 := self Jump: b560.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	jump2 jmpTarget: currentBlock.
	jump3 jmpTarget: currentBlock.
	jump4 jmpTarget: currentBlock.
	self MoveR: t1 R: t0.
	self AndCq: 7 R: t0.
	self CmpCq: 0 R: t0.
	jump4 := self JumpNonZero: 0.
	self MoveM64: 0 r: t1 R: t0.
	self AndCq: 16r3FFFF7 R: t0.
	self CmpCq: 0 R: t0.
	jump3 := self JumpNonZero: 0.
	self MoveM64: 8 r: t1 R: t0.
	b556 := self Label.
	self MoveR: t0 R: t2.
	self AndCq: 7 R: t2.
	self CmpCq: 0 R: t2.
	jump2 := self JumpNonZero: 0.
	self MoveM64: 0 r: t0 R: t2.
	self AndCq: 16r3FFFF7 R: t2.
	self CmpCq: 0 R: t2.
	jump1 := self JumpNonZero: 0.
	self MoveM64: 8 r: t0 R: t2.
	self MoveR: t2 R: t0.
	jump6 := self Jump: b556.
	currentBlock := self Label.
	jump4 jmpTarget: currentBlock.
	jump3 jmpTarget: currentBlock.
	jump2 jmpTarget: currentBlock.
	jump1 jmpTarget: currentBlock.
	self ssPop: 2 popSpilled: true.
	(self ssValue: 1) copyToReg: t2.
	s45 := objectMemory trueObject.
	self ssFlushStackExceptTop: 0.
	self CmpCq: s45 R: t2.
	jump1 := self JumpNonZero: 0.
	s48 := bytecodePC.
	s49 := s48 + 2.
	self Jump: (self ensureFixupAt: s49).
	deadCode := true.
	jump2 := self Jump: 0.
	deadCode := false.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	s52 := objectMemory falseObject.
	self CmpCq: s52 R: t2.
	jump1 := self JumpZero: 0.
	self MoveR: t2 R: TempReg.
	self CallRT: ceSendMustBeBooleanTrampoline.
	currentBlock := self Label.
	jump2 jmpTarget: currentBlock.
	jump1 jmpTarget: currentBlock.
	^ 0
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_bytecodePrimNotIdenticalSistaV1_shortConditionalJumpTrue_2 [
	"AutoGenerated by Druid"

	| b556 jump5 jump3 jump1 t1 s2 currentBlock s49 jump6 live jump4 s45 jump2 t2 s52 b560 t0 s48 s50 |
	live := 0.
	t0 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t0).
	t1 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t1).
	t2 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t2).
	self annotateBytecode: self Label.
	(self ssValue: 1) copyToReg: t0.
	(self ssValue: 0) copyToReg: t1.
	self MoveR: t0 R: t2.
	self AndCq: 7 R: t2.
	self CmpCq: 0 R: t2.
	jump1 := self JumpNonZero: 0.
	self MoveM64: 0 r: t0 R: t2.
	self AndCq: 16r3FFFF7 R: t2.
	self CmpCq: 0 R: t2.
	jump2 := self JumpNonZero: 0.
	self MoveM64: 8 r: t0 R: t2.
	b560 := self Label.
	self MoveR: t2 R: t0.
	self AndCq: 7 R: t0.
	self CmpCq: 0 R: t0.
	jump3 := self JumpNonZero: 0.
	self MoveM64: 0 r: t2 R: t0.
	self AndCq: 16r3FFFF7 R: t0.
	self CmpCq: 0 R: t0.
	jump4 := self JumpNonZero: 0.
	self MoveM64: 8 r: t2 R: t0.
	self MoveR: t0 R: t2.
	jump5 := self Jump: b560.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	jump2 jmpTarget: currentBlock.
	jump3 jmpTarget: currentBlock.
	jump4 jmpTarget: currentBlock.
	self MoveR: t1 R: t0.
	self AndCq: 7 R: t0.
	self CmpCq: 0 R: t0.
	jump4 := self JumpNonZero: 0.
	self MoveM64: 0 r: t1 R: t0.
	self AndCq: 16r3FFFF7 R: t0.
	self CmpCq: 0 R: t0.
	jump3 := self JumpNonZero: 0.
	self MoveM64: 8 r: t1 R: t0.
	b556 := self Label.
	self MoveR: t0 R: t2.
	self AndCq: 7 R: t2.
	self CmpCq: 0 R: t2.
	jump2 := self JumpNonZero: 0.
	self MoveM64: 0 r: t0 R: t2.
	self AndCq: 16r3FFFF7 R: t2.
	self CmpCq: 0 R: t2.
	jump1 := self JumpNonZero: 0.
	self MoveM64: 8 r: t0 R: t2.
	self MoveR: t2 R: t0.
	jump6 := self Jump: b556.
	currentBlock := self Label.
	jump4 jmpTarget: currentBlock.
	jump3 jmpTarget: currentBlock.
	jump2 jmpTarget: currentBlock.
	jump1 jmpTarget: currentBlock.
	self ssPop: 2 popSpilled: true.
	(self ssValue: 1) copyToReg: t2.
	s45 := objectMemory trueObject.
	self ssFlushStackExceptTop: 0.
	self CmpCq: s45 R: t2.
	jump1 := self JumpNonZero: 0.
	s48 := bytecodePC.
	s49 := s48 + 3.
	self Jump: (self ensureFixupAt: s49).
	deadCode := true.
	jump2 := self Jump: 0.
	deadCode := false.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	s52 := objectMemory falseObject.
	self CmpCq: s52 R: t2.
	jump1 := self JumpZero: 0.
	self MoveR: t2 R: TempReg.
	self CallRT: ceSendMustBeBooleanTrampoline.
	currentBlock := self Label.
	jump2 jmpTarget: currentBlock.
	jump1 jmpTarget: currentBlock.
	^ 0
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_bytecodePrimNotIdenticalSistaV1_shortConditionalJumpTrue_3 [
	"AutoGenerated by Druid"

	| b556 jump5 jump3 jump1 t1 s2 currentBlock s49 jump6 live jump4 s45 jump2 t2 s52 b560 t0 s48 s50 |
	live := 0.
	t0 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t0).
	t1 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t1).
	t2 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t2).
	self annotateBytecode: self Label.
	(self ssValue: 1) copyToReg: t0.
	(self ssValue: 0) copyToReg: t1.
	self MoveR: t0 R: t2.
	self AndCq: 7 R: t2.
	self CmpCq: 0 R: t2.
	jump1 := self JumpNonZero: 0.
	self MoveM64: 0 r: t0 R: t2.
	self AndCq: 16r3FFFF7 R: t2.
	self CmpCq: 0 R: t2.
	jump2 := self JumpNonZero: 0.
	self MoveM64: 8 r: t0 R: t2.
	b560 := self Label.
	self MoveR: t2 R: t0.
	self AndCq: 7 R: t0.
	self CmpCq: 0 R: t0.
	jump3 := self JumpNonZero: 0.
	self MoveM64: 0 r: t2 R: t0.
	self AndCq: 16r3FFFF7 R: t0.
	self CmpCq: 0 R: t0.
	jump4 := self JumpNonZero: 0.
	self MoveM64: 8 r: t2 R: t0.
	self MoveR: t0 R: t2.
	jump5 := self Jump: b560.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	jump2 jmpTarget: currentBlock.
	jump3 jmpTarget: currentBlock.
	jump4 jmpTarget: currentBlock.
	self MoveR: t1 R: t0.
	self AndCq: 7 R: t0.
	self CmpCq: 0 R: t0.
	jump4 := self JumpNonZero: 0.
	self MoveM64: 0 r: t1 R: t0.
	self AndCq: 16r3FFFF7 R: t0.
	self CmpCq: 0 R: t0.
	jump3 := self JumpNonZero: 0.
	self MoveM64: 8 r: t1 R: t0.
	b556 := self Label.
	self MoveR: t0 R: t2.
	self AndCq: 7 R: t2.
	self CmpCq: 0 R: t2.
	jump2 := self JumpNonZero: 0.
	self MoveM64: 0 r: t0 R: t2.
	self AndCq: 16r3FFFF7 R: t2.
	self CmpCq: 0 R: t2.
	jump1 := self JumpNonZero: 0.
	self MoveM64: 8 r: t0 R: t2.
	self MoveR: t2 R: t0.
	jump6 := self Jump: b556.
	currentBlock := self Label.
	jump4 jmpTarget: currentBlock.
	jump3 jmpTarget: currentBlock.
	jump2 jmpTarget: currentBlock.
	jump1 jmpTarget: currentBlock.
	self ssPop: 2 popSpilled: true.
	(self ssValue: 1) copyToReg: t2.
	s45 := objectMemory trueObject.
	self ssFlushStackExceptTop: 0.
	self CmpCq: s45 R: t2.
	jump1 := self JumpNonZero: 0.
	s48 := bytecodePC.
	s49 := s48 + 4.
	self Jump: (self ensureFixupAt: s49).
	deadCode := true.
	jump2 := self Jump: 0.
	deadCode := false.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	s52 := objectMemory falseObject.
	self CmpCq: s52 R: t2.
	jump1 := self JumpZero: 0.
	self MoveR: t2 R: TempReg.
	self CallRT: ceSendMustBeBooleanTrampoline.
	currentBlock := self Label.
	jump2 jmpTarget: currentBlock.
	jump1 jmpTarget: currentBlock.
	^ 0
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_bytecodePrimNotIdenticalSistaV1_shortConditionalJumpTrue_4 [
	"AutoGenerated by Druid"

	| b556 jump5 jump3 jump1 t1 s2 currentBlock s49 jump6 live jump4 s45 jump2 t2 s52 b560 t0 s48 s50 |
	live := 0.
	t0 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t0).
	t1 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t1).
	t2 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t2).
	self annotateBytecode: self Label.
	(self ssValue: 1) copyToReg: t0.
	(self ssValue: 0) copyToReg: t1.
	self MoveR: t0 R: t2.
	self AndCq: 7 R: t2.
	self CmpCq: 0 R: t2.
	jump1 := self JumpNonZero: 0.
	self MoveM64: 0 r: t0 R: t2.
	self AndCq: 16r3FFFF7 R: t2.
	self CmpCq: 0 R: t2.
	jump2 := self JumpNonZero: 0.
	self MoveM64: 8 r: t0 R: t2.
	b560 := self Label.
	self MoveR: t2 R: t0.
	self AndCq: 7 R: t0.
	self CmpCq: 0 R: t0.
	jump3 := self JumpNonZero: 0.
	self MoveM64: 0 r: t2 R: t0.
	self AndCq: 16r3FFFF7 R: t0.
	self CmpCq: 0 R: t0.
	jump4 := self JumpNonZero: 0.
	self MoveM64: 8 r: t2 R: t0.
	self MoveR: t0 R: t2.
	jump5 := self Jump: b560.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	jump2 jmpTarget: currentBlock.
	jump3 jmpTarget: currentBlock.
	jump4 jmpTarget: currentBlock.
	self MoveR: t1 R: t0.
	self AndCq: 7 R: t0.
	self CmpCq: 0 R: t0.
	jump4 := self JumpNonZero: 0.
	self MoveM64: 0 r: t1 R: t0.
	self AndCq: 16r3FFFF7 R: t0.
	self CmpCq: 0 R: t0.
	jump3 := self JumpNonZero: 0.
	self MoveM64: 8 r: t1 R: t0.
	b556 := self Label.
	self MoveR: t0 R: t2.
	self AndCq: 7 R: t2.
	self CmpCq: 0 R: t2.
	jump2 := self JumpNonZero: 0.
	self MoveM64: 0 r: t0 R: t2.
	self AndCq: 16r3FFFF7 R: t2.
	self CmpCq: 0 R: t2.
	jump1 := self JumpNonZero: 0.
	self MoveM64: 8 r: t0 R: t2.
	self MoveR: t2 R: t0.
	jump6 := self Jump: b556.
	currentBlock := self Label.
	jump4 jmpTarget: currentBlock.
	jump3 jmpTarget: currentBlock.
	jump2 jmpTarget: currentBlock.
	jump1 jmpTarget: currentBlock.
	self ssPop: 2 popSpilled: true.
	(self ssValue: 1) copyToReg: t2.
	s45 := objectMemory trueObject.
	self ssFlushStackExceptTop: 0.
	self CmpCq: s45 R: t2.
	jump1 := self JumpNonZero: 0.
	s48 := bytecodePC.
	s49 := s48 + 5.
	self Jump: (self ensureFixupAt: s49).
	deadCode := true.
	jump2 := self Jump: 0.
	deadCode := false.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	s52 := objectMemory falseObject.
	self CmpCq: s52 R: t2.
	jump1 := self JumpZero: 0.
	self MoveR: t2 R: TempReg.
	self CallRT: ceSendMustBeBooleanTrampoline.
	currentBlock := self Label.
	jump2 jmpTarget: currentBlock.
	jump1 jmpTarget: currentBlock.
	^ 0
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_bytecodePrimNotIdenticalSistaV1_shortConditionalJumpTrue_5 [
	"AutoGenerated by Druid"

	| b556 jump5 jump3 jump1 t1 s2 currentBlock s49 jump6 live jump4 s45 jump2 t2 s52 b560 t0 s48 s50 |
	live := 0.
	t0 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t0).
	t1 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t1).
	t2 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t2).
	self annotateBytecode: self Label.
	(self ssValue: 1) copyToReg: t0.
	(self ssValue: 0) copyToReg: t1.
	self MoveR: t0 R: t2.
	self AndCq: 7 R: t2.
	self CmpCq: 0 R: t2.
	jump1 := self JumpNonZero: 0.
	self MoveM64: 0 r: t0 R: t2.
	self AndCq: 16r3FFFF7 R: t2.
	self CmpCq: 0 R: t2.
	jump2 := self JumpNonZero: 0.
	self MoveM64: 8 r: t0 R: t2.
	b560 := self Label.
	self MoveR: t2 R: t0.
	self AndCq: 7 R: t0.
	self CmpCq: 0 R: t0.
	jump3 := self JumpNonZero: 0.
	self MoveM64: 0 r: t2 R: t0.
	self AndCq: 16r3FFFF7 R: t0.
	self CmpCq: 0 R: t0.
	jump4 := self JumpNonZero: 0.
	self MoveM64: 8 r: t2 R: t0.
	self MoveR: t0 R: t2.
	jump5 := self Jump: b560.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	jump2 jmpTarget: currentBlock.
	jump3 jmpTarget: currentBlock.
	jump4 jmpTarget: currentBlock.
	self MoveR: t1 R: t0.
	self AndCq: 7 R: t0.
	self CmpCq: 0 R: t0.
	jump4 := self JumpNonZero: 0.
	self MoveM64: 0 r: t1 R: t0.
	self AndCq: 16r3FFFF7 R: t0.
	self CmpCq: 0 R: t0.
	jump3 := self JumpNonZero: 0.
	self MoveM64: 8 r: t1 R: t0.
	b556 := self Label.
	self MoveR: t0 R: t2.
	self AndCq: 7 R: t2.
	self CmpCq: 0 R: t2.
	jump2 := self JumpNonZero: 0.
	self MoveM64: 0 r: t0 R: t2.
	self AndCq: 16r3FFFF7 R: t2.
	self CmpCq: 0 R: t2.
	jump1 := self JumpNonZero: 0.
	self MoveM64: 8 r: t0 R: t2.
	self MoveR: t2 R: t0.
	jump6 := self Jump: b556.
	currentBlock := self Label.
	jump4 jmpTarget: currentBlock.
	jump3 jmpTarget: currentBlock.
	jump2 jmpTarget: currentBlock.
	jump1 jmpTarget: currentBlock.
	self ssPop: 2 popSpilled: true.
	(self ssValue: 1) copyToReg: t2.
	s45 := objectMemory trueObject.
	self ssFlushStackExceptTop: 0.
	self CmpCq: s45 R: t2.
	jump1 := self JumpNonZero: 0.
	s48 := bytecodePC.
	s49 := s48 + 6.
	self Jump: (self ensureFixupAt: s49).
	deadCode := true.
	jump2 := self Jump: 0.
	deadCode := false.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	s52 := objectMemory falseObject.
	self CmpCq: s52 R: t2.
	jump1 := self JumpZero: 0.
	self MoveR: t2 R: TempReg.
	self CallRT: ceSendMustBeBooleanTrampoline.
	currentBlock := self Label.
	jump2 jmpTarget: currentBlock.
	jump1 jmpTarget: currentBlock.
	^ 0
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_bytecodePrimNotIdenticalSistaV1_shortConditionalJumpTrue_6 [
	"AutoGenerated by Druid"

	| b556 jump5 jump3 jump1 t1 s2 currentBlock s49 jump6 live jump4 s45 jump2 t2 s52 b560 t0 s48 s50 |
	live := 0.
	t0 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t0).
	t1 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t1).
	t2 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t2).
	self annotateBytecode: self Label.
	(self ssValue: 1) copyToReg: t0.
	(self ssValue: 0) copyToReg: t1.
	self MoveR: t0 R: t2.
	self AndCq: 7 R: t2.
	self CmpCq: 0 R: t2.
	jump1 := self JumpNonZero: 0.
	self MoveM64: 0 r: t0 R: t2.
	self AndCq: 16r3FFFF7 R: t2.
	self CmpCq: 0 R: t2.
	jump2 := self JumpNonZero: 0.
	self MoveM64: 8 r: t0 R: t2.
	b560 := self Label.
	self MoveR: t2 R: t0.
	self AndCq: 7 R: t0.
	self CmpCq: 0 R: t0.
	jump3 := self JumpNonZero: 0.
	self MoveM64: 0 r: t2 R: t0.
	self AndCq: 16r3FFFF7 R: t0.
	self CmpCq: 0 R: t0.
	jump4 := self JumpNonZero: 0.
	self MoveM64: 8 r: t2 R: t0.
	self MoveR: t0 R: t2.
	jump5 := self Jump: b560.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	jump2 jmpTarget: currentBlock.
	jump3 jmpTarget: currentBlock.
	jump4 jmpTarget: currentBlock.
	self MoveR: t1 R: t0.
	self AndCq: 7 R: t0.
	self CmpCq: 0 R: t0.
	jump4 := self JumpNonZero: 0.
	self MoveM64: 0 r: t1 R: t0.
	self AndCq: 16r3FFFF7 R: t0.
	self CmpCq: 0 R: t0.
	jump3 := self JumpNonZero: 0.
	self MoveM64: 8 r: t1 R: t0.
	b556 := self Label.
	self MoveR: t0 R: t2.
	self AndCq: 7 R: t2.
	self CmpCq: 0 R: t2.
	jump2 := self JumpNonZero: 0.
	self MoveM64: 0 r: t0 R: t2.
	self AndCq: 16r3FFFF7 R: t2.
	self CmpCq: 0 R: t2.
	jump1 := self JumpNonZero: 0.
	self MoveM64: 8 r: t0 R: t2.
	self MoveR: t2 R: t0.
	jump6 := self Jump: b556.
	currentBlock := self Label.
	jump4 jmpTarget: currentBlock.
	jump3 jmpTarget: currentBlock.
	jump2 jmpTarget: currentBlock.
	jump1 jmpTarget: currentBlock.
	self ssPop: 2 popSpilled: true.
	(self ssValue: 1) copyToReg: t2.
	s45 := objectMemory trueObject.
	self ssFlushStackExceptTop: 0.
	self CmpCq: s45 R: t2.
	jump1 := self JumpNonZero: 0.
	s48 := bytecodePC.
	s49 := s48 + 7.
	self Jump: (self ensureFixupAt: s49).
	deadCode := true.
	jump2 := self Jump: 0.
	deadCode := false.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	s52 := objectMemory falseObject.
	self CmpCq: s52 R: t2.
	jump1 := self JumpZero: 0.
	self MoveR: t2 R: TempReg.
	self CallRT: ceSendMustBeBooleanTrampoline.
	currentBlock := self Label.
	jump2 jmpTarget: currentBlock.
	jump1 jmpTarget: currentBlock.
	^ 0
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_bytecodePrimNotIdenticalSistaV1_shortConditionalJumpTrue_7 [
	"AutoGenerated by Druid"

	| b556 jump5 jump3 jump1 t1 s2 currentBlock s49 jump6 live jump4 s45 jump2 t2 s52 b560 t0 s48 s50 |
	live := 0.
	t0 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t0).
	t1 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t1).
	t2 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t2).
	self annotateBytecode: self Label.
	(self ssValue: 1) copyToReg: t0.
	(self ssValue: 0) copyToReg: t1.
	self MoveR: t0 R: t2.
	self AndCq: 7 R: t2.
	self CmpCq: 0 R: t2.
	jump1 := self JumpNonZero: 0.
	self MoveM64: 0 r: t0 R: t2.
	self AndCq: 16r3FFFF7 R: t2.
	self CmpCq: 0 R: t2.
	jump2 := self JumpNonZero: 0.
	self MoveM64: 8 r: t0 R: t2.
	b560 := self Label.
	self MoveR: t2 R: t0.
	self AndCq: 7 R: t0.
	self CmpCq: 0 R: t0.
	jump3 := self JumpNonZero: 0.
	self MoveM64: 0 r: t2 R: t0.
	self AndCq: 16r3FFFF7 R: t0.
	self CmpCq: 0 R: t0.
	jump4 := self JumpNonZero: 0.
	self MoveM64: 8 r: t2 R: t0.
	self MoveR: t0 R: t2.
	jump5 := self Jump: b560.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	jump2 jmpTarget: currentBlock.
	jump3 jmpTarget: currentBlock.
	jump4 jmpTarget: currentBlock.
	self MoveR: t1 R: t0.
	self AndCq: 7 R: t0.
	self CmpCq: 0 R: t0.
	jump4 := self JumpNonZero: 0.
	self MoveM64: 0 r: t1 R: t0.
	self AndCq: 16r3FFFF7 R: t0.
	self CmpCq: 0 R: t0.
	jump3 := self JumpNonZero: 0.
	self MoveM64: 8 r: t1 R: t0.
	b556 := self Label.
	self MoveR: t0 R: t2.
	self AndCq: 7 R: t2.
	self CmpCq: 0 R: t2.
	jump2 := self JumpNonZero: 0.
	self MoveM64: 0 r: t0 R: t2.
	self AndCq: 16r3FFFF7 R: t2.
	self CmpCq: 0 R: t2.
	jump1 := self JumpNonZero: 0.
	self MoveM64: 8 r: t0 R: t2.
	self MoveR: t2 R: t0.
	jump6 := self Jump: b556.
	currentBlock := self Label.
	jump4 jmpTarget: currentBlock.
	jump3 jmpTarget: currentBlock.
	jump2 jmpTarget: currentBlock.
	jump1 jmpTarget: currentBlock.
	self ssPop: 2 popSpilled: true.
	(self ssValue: 1) copyToReg: t2.
	s45 := objectMemory trueObject.
	self ssFlushStackExceptTop: 0.
	self CmpCq: s45 R: t2.
	jump1 := self JumpNonZero: 0.
	s48 := bytecodePC.
	s49 := s48 + 8.
	self Jump: (self ensureFixupAt: s49).
	deadCode := true.
	jump2 := self Jump: 0.
	deadCode := false.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	s52 := objectMemory falseObject.
	self CmpCq: s52 R: t2.
	jump1 := self JumpZero: 0.
	self MoveR: t2 R: TempReg.
	self CallRT: ceSendMustBeBooleanTrampoline.
	currentBlock := self Label.
	jump2 jmpTarget: currentBlock.
	jump1 jmpTarget: currentBlock.
	^ 0
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_bytecodePrimNotIdenticalSistaV1_shortConditionalJumpTrue_8 [
	"AutoGenerated by Druid"

	| b556 jump5 jump3 jump1 t1 s2 currentBlock s49 jump6 live jump4 s45 jump2 t2 s52 b560 t0 s48 s50 |
	live := 0.
	t0 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t0).
	t1 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t1).
	t2 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t2).
	self annotateBytecode: self Label.
	(self ssValue: 1) copyToReg: t0.
	(self ssValue: 0) copyToReg: t1.
	self MoveR: t0 R: t2.
	self AndCq: 7 R: t2.
	self CmpCq: 0 R: t2.
	jump1 := self JumpNonZero: 0.
	self MoveM64: 0 r: t0 R: t2.
	self AndCq: 16r3FFFF7 R: t2.
	self CmpCq: 0 R: t2.
	jump2 := self JumpNonZero: 0.
	self MoveM64: 8 r: t0 R: t2.
	b560 := self Label.
	self MoveR: t2 R: t0.
	self AndCq: 7 R: t0.
	self CmpCq: 0 R: t0.
	jump3 := self JumpNonZero: 0.
	self MoveM64: 0 r: t2 R: t0.
	self AndCq: 16r3FFFF7 R: t0.
	self CmpCq: 0 R: t0.
	jump4 := self JumpNonZero: 0.
	self MoveM64: 8 r: t2 R: t0.
	self MoveR: t0 R: t2.
	jump5 := self Jump: b560.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	jump2 jmpTarget: currentBlock.
	jump3 jmpTarget: currentBlock.
	jump4 jmpTarget: currentBlock.
	self MoveR: t1 R: t0.
	self AndCq: 7 R: t0.
	self CmpCq: 0 R: t0.
	jump4 := self JumpNonZero: 0.
	self MoveM64: 0 r: t1 R: t0.
	self AndCq: 16r3FFFF7 R: t0.
	self CmpCq: 0 R: t0.
	jump3 := self JumpNonZero: 0.
	self MoveM64: 8 r: t1 R: t0.
	b556 := self Label.
	self MoveR: t0 R: t2.
	self AndCq: 7 R: t2.
	self CmpCq: 0 R: t2.
	jump2 := self JumpNonZero: 0.
	self MoveM64: 0 r: t0 R: t2.
	self AndCq: 16r3FFFF7 R: t2.
	self CmpCq: 0 R: t2.
	jump1 := self JumpNonZero: 0.
	self MoveM64: 8 r: t0 R: t2.
	self MoveR: t2 R: t0.
	jump6 := self Jump: b556.
	currentBlock := self Label.
	jump4 jmpTarget: currentBlock.
	jump3 jmpTarget: currentBlock.
	jump2 jmpTarget: currentBlock.
	jump1 jmpTarget: currentBlock.
	self ssPop: 2 popSpilled: true.
	(self ssValue: 1) copyToReg: t2.
	s45 := objectMemory trueObject.
	self ssFlushStackExceptTop: 0.
	self CmpCq: s45 R: t2.
	jump1 := self JumpNonZero: 0.
	s48 := bytecodePC.
	s49 := s48 + 9.
	self Jump: (self ensureFixupAt: s49).
	deadCode := true.
	jump2 := self Jump: 0.
	deadCode := false.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	s52 := objectMemory falseObject.
	self CmpCq: s52 R: t2.
	jump1 := self JumpZero: 0.
	self MoveR: t2 R: TempReg.
	self CallRT: ceSendMustBeBooleanTrampoline.
	currentBlock := self Label.
	jump2 jmpTarget: currentBlock.
	jump1 jmpTarget: currentBlock.
	^ 0
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_bytecodePushOnTwoBranches [
	"AutoGenerated by Druid"

	| t0 jump1 s4 t1 currentBlock s7 live jump2 |
	live := 0.
	t0 := self allocateRegNotConflictingWith: live ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t0).
	t1 := self allocateRegNotConflictingWith: live ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t1).
	(self ssValue: 0) copyToReg: t0.
	self CmpCq: 0 R: t0.
	jump1 := self JumpLessOrEqual: 0.
	s4 := 1.
	self MoveCq: s4 R: t1.
	jump2 := self Jump: 0.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	s7 := 2.
	self MoveCq: s7 R: t1.
	currentBlock := self Label.
	jump2 jmpTarget: currentBlock.
	self ssPushRegister: t1.
	^ 0
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_bytecodeTwoPopOnTwoBranches [
	"AutoGenerated by Druid"

	| t0 jump1 t3 t1 currentBlock jump2 live t2 |
	live := 0.
	t0 := self allocateRegNotConflictingWith: live ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t0).
	t1 := self allocateRegNotConflictingWith: live ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t1).
	t2 := self allocateRegNotConflictingWith: live ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t2).
	t3 := self allocateRegNotConflictingWith: live ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t3).
	(self ssValue: 0) copyToReg: t0.
	self CmpCq: 0 R: t0.
	jump1 := self JumpLessOrEqual: 0.
	(self ssValue: 0) copyToReg: t0.
	(self ssValue: 1) copyToReg: t1.
	self MoveR: t1 R: t2.
	jump2 := self Jump: 0.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	(self ssValue: 0) copyToReg: t2.
	(self ssValue: 1) copyToReg: t3.
	self MoveR: t2 R: t0.
	self MoveR: t3 R: t2.
	currentBlock := self Label.
	jump2 jmpTarget: currentBlock.
	self ssPop: 2 popSpilled: true.
	self AddR: t2 R: t0.
	self ssPushRegister: t0.
	^ 0
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_bytecodeTwoPushOnTwoBranches [
	"AutoGenerated by Druid"

	| s6 jump1 t1 s10 s5 currentBlock t0 jump2 s11 live |
	live := 0.
	t0 := self allocateRegNotConflictingWith: live ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t0).
	t1 := self allocateRegNotConflictingWith: live ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t1).
	(self ssValue: 0) copyToReg: t0.
	self ssPop: 1 popSpilled: true.
	self CmpCq: 0 R: t0.
	jump1 := self JumpLessOrEqual: 0.
	s5 := 1.
	s6 := 2.
	self MoveCq: s6 R: t0.
	self MoveCq: s5 R: t1.
	jump2 := self Jump: 0.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	s10 := 3.
	s11 := 4.
	self MoveCq: s11 R: t0.
	self MoveCq: s10 R: t1.
	currentBlock := self Label.
	jump2 jmpTarget: currentBlock.
	self AddR: t1 R: t0.
	self ssPushRegister: t0.
	^ 0
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_bytecodeWithDeoptimisation [
	"AutoGenerated by Druid"

	| live currentBlock t0 |
	live := 0.
	t0 := self allocateRegNotConflictingWith: live ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t0).
	self ssFlushStackExceptTop: 0.
	self deoptimize.
	^ 0
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_bytecodeWithFlushStackOnDominator [
	"AutoGenerated by Druid"

	| t0 jump1 currentBlock jump2 live |
	live := 0.
	t0 := self allocateRegNotConflictingWith: live ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t0).
	(self ssValue: 0) copyToReg: t0.
	self ssFlushStackExceptTop: 0.
	self CmpCq: 0 R: t0.
	jump1 := self JumpLessOrEqual: 0.
	self deoptimize.
	jump2 := self Jump: 0.
	deadCode := false.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	(self ssValue: 0) copyToReg: t0.
	self MoveR: t0 R: TempReg.
	self CallRT: ceSendMustBeBooleanTrampoline.
	self annotateBytecode: self Label.
	currentBlock := self Label.
	jump2 jmpTarget: currentBlock.
	^ 0
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_bytecodeWithPop [
	"AutoGenerated by Druid"

	| live currentBlock |
	live := 0.
	self ssPop: 1 popSpilled: true.
	^ 0
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_bytecodeWithUnknownBytecodeSend [
	"AutoGenerated by Druid"

	| live currentBlock |
	live := 0.
	self deoptimize.
	^ 0
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_duplicateTopBytecode [
	"AutoGenerated by Druid"

	| live currentBlock t0 |
	live := 0.
	t0 := self allocateRegNotConflictingWith: live ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t0).
	(self ssValue: 0) copyToReg: t0.
	self ssPushRegister: t0.
	^ 0
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_emptyPrimitive [
	"AutoGenerated by Druid"

	| currentBlock |
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_emptyPrimitiveWithArguments [
	"AutoGenerated by Druid"

	| currentBlock |
	self MoveR: Arg0Reg R: ClassReg.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_extBBytecode [
	"AutoGenerated by Druid"

	| s6 s3 s16 s10 s5 s2 currentBlock s7 s4 s17 live s11 s9 |
	live := 0.
	s2 := byte1.
	s3 := numExtB.
	s3 = 0 ifTrue: [
		s2 > 127 ifTrue: [
			s6 := s2 - 256.
			s7 := s6.
			extB := s7.
			s16 := numExtB.
			s17 := s16 + 1.
			numExtB := s17.
			^ 0 ].
		s9 := extB.
		s10 := s9 << 8.
		s11 := s10 + s2.
		s7 := s11.
		extB := s7.
		s16 := numExtB.
		s17 := s16 + 1.
		numExtB := s17.
		^ 0 ].
	s9 := extB.
	s10 := s9 << 8.
	s11 := s10 + s2.
	s7 := s11.
	extB := s7.
	s16 := numExtB.
	s17 := s16 + 1.
	numExtB := s17.
	^ 0
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_extPushFullClosureBytecode [
	"AutoGenerated by Druid"

	| b4 s4 s38 s9 s2 s20 currentBlock t1 s19 s12 s7 s25 live s5 s15 s3 s28 s37 s21 t2 s8 t0 s18 s11 |
	live := 0.
	live := live bitOr: (self registerMaskFor: ClassReg).
	live := live bitOr: (self registerMaskFor: SendNumArgsReg).
	live := live bitOr: (self registerMaskFor: ReceiverResultReg).
	t0 := self allocateRegNotConflictingWith: live ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t0).
	t1 := self allocateRegNotConflictingWith: live ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t1).
	t2 := self allocateRegNotConflictingWith: live ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t2).
	s2 := byte1.
	s3 := extA.
	s4 := s3 << 8.
	s5 := s2 + s4.
	extA := 0.
	s7 := byte2.
	s8 := s7 bitAnd: 63.
	s9 := s7 anyMask: 64.
	self voidReceiverResultRegContainsSelf.
	self ssAllocateCallReg: ReceiverResultReg and: SendNumArgsReg and: ClassReg.
	self
		genCreateFullClosureInIndex: s5
		numCopied: s8
		ignoreContext: s9
		contextNumArgs: methodOrBlockNumArgs
		large: (coInterpreter methodNeedsLargeContext: methodObj)
		inBlock: inBlock
		intoRegister: ReceiverResultReg.
	self MoveR: ReceiverResultReg R: t0.
	live := live bitClear: (self registerMaskFor: SendNumArgsReg).
	live := live bitClear: (self registerMaskFor: ClassReg).
	s11 := 1.
	s12 := s11.
	b4 := self Label.
	[ ((s12<=s8)) ] whileTrue: [
		(self ssValue: 0) copyToReg: t1.
		self ssPop: 1 popSpilled: true.
		s18 := FullClosureFirstCopiedValueIndex.
		s19 := s18 + s8.
		s20 := s19 - s12.
		s21 := s20 << 3.
		self MoveR: t0 R: t2.
		self AddCq: s21 R: t2.
		self MoveR: t1 M64: 8 r: t2.
		s25 := s12 + 1.
		s12 := s25 ].
	(s7 anyMask: 128) ifTrue: [
		(self ssValue: 0) copyToReg: t2.
		self ssPop: 1 popSpilled: true.
		s37 := FullClosureReceiverIndex.
		s38 := s37 << 3.
		self MoveR: t0 R: t1.
		self AddCq: s38 R: t1.
		self MoveR: t2 M64: 8 r: t1.
		self ssPushRegister: t0.
		^ 0 ].
	self ensureReceiverResultRegContainsSelf.
	self MoveR: ReceiverResultReg R: t2.
	s37 := FullClosureReceiverIndex.
	s38 := s37 << 3.
	self MoveR: t0 R: t1.
	self AddCq: s38 R: t1.
	self MoveR: t2 M64: 8 r: t1.
	self ssPushRegister: t0.
	^ 0
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_extPushIntegerBytecode [
	"AutoGenerated by Druid"

	| s5 s8 s4 s2 currentBlock s9 s10 live s3 |
	live := 0.
	s2 := byte1.
	s3 := extB.
	s4 := s3 << 8.
	s5 := s2 + s4.
	extB := 0.
	numExtB := 0.
	s8 := s2 + s4.
	s9 := s8 << 3.
	s10 := s9 + 1.
	self ssPushConstant: s10.
	^ 0
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_extSendSuperBytecode [
	"AutoGenerated by Druid"

	| s6 s3 s16 s10 s8 s5 s2 s18 currentBlock s12 s15 t0 s4 s17 s11 live |
	live := 0.
	t0 := self allocateRegNotConflictingWith: live ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t0).
	s2 := byte1.
	s3 := s2 >> 3.
	s4 := extA.
	s5 := s4 << 5.
	s6 := s3 + s5.
	extA := 0.
	s8 := BytecodeSetHasDirectedSuperSend.
	self ssFlushStackExceptTop: 0.
	s8 ifTrue: [
		s11 := extB.
		s11 >= 64 ifTrue: [
			self deoptimize.
			^ 0 ].
		s15 := s2 bitAnd: 7.
		s16 := extB.
		s17 := s16 << 3.
		s18 := s15 + s17.
		extB := 0.
		numExtB := 0.
		self marshallSendArguments: s18.
		self genMarshalledSendNoPush: s6 numArgs: s18 sendTable: superSendTrampolines.
		self ssPushRegister: ReceiverResultReg.
		^ 0 ].
	s15 := s2 bitAnd: 7.
	s16 := extB.
	s17 := s16 << 3.
	s18 := s15 + s17.
	extB := 0.
	numExtB := 0.
	self marshallSendArguments: s18.
	self genMarshalledSendNoPush: s6 numArgs: s18 sendTable: superSendTrampolines.
	self ssPushRegister: ReceiverResultReg.
	^ 0
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_extStoreAndPopReceiverVariableBytecode [
	"AutoGenerated by Druid"

	| jump5 s4 jump8 s2 t1 s27 currentBlock s42 jump1 jump6 s34 s47 s10 s5 live jump4 s45 s3 jump2 t2 s37 s13 s8 jump7 t0 |
	live := 0.
	t0 := self allocateRegNotConflictingWith: live ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t0).
	t1 := self allocateRegNotConflictingWith: live ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t1).
	t2 := self allocateRegNotConflictingWith: live ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t2).
	s2 := byte1.
	s3 := extA.
	s4 := s3 << 8.
	s5 := s2 + s4.
	(self ssValue: 0) copyToReg: t0.
	self ensureReceiverResultRegContainsSelf.
	self MoveR: ReceiverResultReg R: t1.
	s8 := ReceiverIndex.
	self ssFlushStackExceptTop: 0.
	s5 <= s8 ifTrue: [
		| jump7 jump5 jump3 jump1 jump8 jump6 jump4 jump2 |
		self MoveM64: 0 r: t1 R: t2.
		self AndCq: 16r3FFFFF R: t2.
		s13 := ClassMethodContextCompactIndex.
		self CmpCq: s13 R: t2.
		jump1 := self JumpNonZero: 0.
		self deoptimize.
		jump2 := self Jump: 0.
		deadCode := false.
		currentBlock := self Label.
		jump1 jmpTarget: currentBlock.
		self MoveM64: 0 r: t1 R: t2.
		self LogicalShiftRightCq: 23 R: t2.
		self AndCq: 1 R: t2.
		self CmpCq: 0 R: t2.
		jump1 := self JumpZero: 0.
		self deoptimize.
		jump3 := self Jump: 0.
		deadCode := false.
		currentBlock := self Label.
		jump1 jmpTarget: currentBlock.
		s27 := s5 << 3.
		self MoveR: t1 R: t2.
		self AddCq: s27 R: t2.
		self MoveR: t0 M64: 8 r: t2.
		self MoveR: t1 R: t2.
		self AndCq: 7 R: t2.
		self CmpCq: 0 R: t2.
		jump1 := self JumpNonZero: 0.
		s34 := objectMemory getMemoryMap getSpaceMaskToUse.
		self MoveR: t1 R: t2.
		self AndCq: s34 R: t2.
		s37 := objectMemory getMemoryMap getOldSpaceMask.
		self CmpCq: s37 R: t2.
		jump4 := self JumpNonZero: 0.
		self MoveR: t0 R: t2.
		self AndCq: 7 R: t2.
		self CmpCq: 0 R: t2.
		jump5 := self JumpNonZero: 0.
		s42 := objectMemory getMemoryMap getSpaceMaskToUse.
		self MoveR: t0 R: t2.
		self AndCq: s42 R: t2.
		s45 := objectMemory getMemoryMap getNewSpaceMask.
		self CmpCq: s45 R: t2.
		jump6 := self JumpNonZero: 0.
		s47 := objectMemory getMemoryMap getNewSpaceStart.
		self CmpCq: s47 R: t0.
		jump7 := self JumpBelow: 0.
		self MoveM64: 0 r: t1 R: t2.
		self LogicalShiftRightCq: 29 R: t2.
		self AndCq: 1 R: t2.
		self CmpCq: 0 R: t2.
		jump8 := self JumpNonZero: 0.
		self MoveR: t1 R: TempReg.
		backEnd saveAndRestoreLinkRegAround: [ self CallRT: ceStoreCheckTrampoline ].
		self annotateBytecode: self Label.
		currentBlock := self Label.
		jump3 jmpTarget: currentBlock.
		jump1 jmpTarget: currentBlock.
		jump4 jmpTarget: currentBlock.
		jump5 jmpTarget: currentBlock.
		jump6 jmpTarget: currentBlock.
		jump7 jmpTarget: currentBlock.
		jump8 jmpTarget: currentBlock.
		self ssPop: 1 popSpilled: true.
		currentBlock := self Label.
		jump2 jmpTarget: currentBlock.
		extA := 0.
		^ 0 ].
	self MoveM64: 0 r: t1 R: t2.
	self LogicalShiftRightCq: 23 R: t2.
	self AndCq: 1 R: t2.
	self CmpCq: 0 R: t2.
	jump2 := self JumpZero: 0.
	self deoptimize.
	jump8 := self Jump: 0.
	deadCode := false.
	currentBlock := self Label.
	jump2 jmpTarget: currentBlock.
	s27 := s5 << 3.
	self MoveR: t1 R: t2.
	self AddCq: s27 R: t2.
	self MoveR: t0 M64: 8 r: t2.
	self MoveR: t1 R: t2.
	self AndCq: 7 R: t2.
	self CmpCq: 0 R: t2.
	jump2 := self JumpNonZero: 0.
	s34 := objectMemory getMemoryMap getSpaceMaskToUse.
	self MoveR: t1 R: t2.
	self AndCq: s34 R: t2.
	s37 := objectMemory getMemoryMap getOldSpaceMask.
	self CmpCq: s37 R: t2.
	jump7 := self JumpNonZero: 0.
	self MoveR: t0 R: t2.
	self AndCq: 7 R: t2.
	self CmpCq: 0 R: t2.
	jump6 := self JumpNonZero: 0.
	s42 := objectMemory getMemoryMap getSpaceMaskToUse.
	self MoveR: t0 R: t2.
	self AndCq: s42 R: t2.
	s45 := objectMemory getMemoryMap getNewSpaceMask.
	self CmpCq: s45 R: t2.
	jump5 := self JumpNonZero: 0.
	s47 := objectMemory getMemoryMap getNewSpaceStart.
	self CmpCq: s47 R: t0.
	jump4 := self JumpBelow: 0.
	self MoveM64: 0 r: t1 R: t2.
	self LogicalShiftRightCq: 29 R: t2.
	self AndCq: 1 R: t2.
	self CmpCq: 0 R: t2.
	jump1 := self JumpNonZero: 0.
	self MoveR: t1 R: TempReg.
	backEnd saveAndRestoreLinkRegAround: [ self CallRT: ceStoreCheckTrampoline ].
	self annotateBytecode: self Label.
	currentBlock := self Label.
	jump8 jmpTarget: currentBlock.
	jump2 jmpTarget: currentBlock.
	jump7 jmpTarget: currentBlock.
	jump6 jmpTarget: currentBlock.
	jump5 jmpTarget: currentBlock.
	jump4 jmpTarget: currentBlock.
	jump1 jmpTarget: currentBlock.
	self ssPop: 1 popSpilled: true.
	extA := 0.
	^ 0
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_extStoreLiteralVariableBytecode [
	"AutoGenerated by Druid"

	| s11 jump5 s4 jump3 s53 s9 s2 t1 currentBlock jump1 s58 jumpNext jump6 jump8 s10 s5 live jump4 jumpTrue s63 s3 t2 b429 jump2 s43 jump9 s61 jump7 t0 s35 s50 |
	live := 0.
	t0 := self allocateRegNotConflictingWith: live ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t0).
	t1 := self allocateRegNotConflictingWith: live ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t1).
	t2 := self allocateRegNotConflictingWith: live ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t2).
	s2 := byte1.
	s3 := extA.
	s4 := s3 << 8.
	s5 := s2 + s4.
	extA := 0.
	(self ssValue: 0) copyToReg: t0.
	self genMoveConstant: methodObj R: t1.
	s9 := LiteralStart.
	s10 := s5 + s9.
	s11 := s10 << 3.
	self AddCq: s11 R: t1.
	self MoveM64: 8 r: t1 R: t1.
	self MoveM64: 0 r: t1 R: t2.
	self AndCq: 16r3FFFF7 R: t2.
	self CmpCq: 0 R: t2.
	jump1 := self JumpNonZero: 0.
	self MoveM64: 8 r: t1 R: t2.
	b429 := self Label.
	self MoveR: t2 R: t1.
	self AndCq: 7 R: t1.
	self CmpCq: 0 R: t1.
	jump2 := self JumpNonZero: 0.
	self MoveM64: 0 r: t2 R: t1.
	self AndCq: 16r3FFFF7 R: t1.
	self CmpCq: 0 R: t1.
	jump3 := self JumpNonZero: 0.
	self MoveM64: 8 r: t2 R: t1.
	self MoveR: t1 R: t2.
	jump4 := self Jump: b429.
	currentBlock := self Label.
	jump2 jmpTarget: currentBlock.
	jump3 jmpTarget: currentBlock.
	self MoveR: t2 R: t1.
	jump3 := self Jump: 0.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	currentBlock := self Label.
	jump3 jmpTarget: currentBlock.
	s35 := ValueIndex.
	self MoveM64: 0 r: t1 R: t2.
	self LogicalShiftRightCq: 23 R: t2.
	self AndCq: 1 R: t2.
	self ssFlushStackExceptTop: 0.
	self CmpCq: 0 R: t2.
	jump3 := self JumpZero: 0.
	self deoptimize.
	jump1 := self Jump: 0.
	deadCode := false.
	currentBlock := self Label.
	jump3 jmpTarget: currentBlock.
	s43 := s35 << 3.
	self MoveR: t1 R: t2.
	self AddCq: s43 R: t2.
	self MoveR: t0 M64: 8 r: t2.
	self MoveR: t1 R: t2.
	self AndCq: 7 R: t2.
	self CmpCq: 0 R: t2.
	jump3 := self JumpNonZero: 0.
	s50 := objectMemory getMemoryMap getSpaceMaskToUse.
	self MoveR: t1 R: t2.
	self AndCq: s50 R: t2.
	s53 := objectMemory getMemoryMap getOldSpaceMask.
	self CmpCq: s53 R: t2.
	jump2 := self JumpNonZero: 0.
	self MoveR: t0 R: t2.
	self AndCq: 7 R: t2.
	self CmpCq: 0 R: t2.
	jump5 := self JumpNonZero: 0.
	s58 := objectMemory getMemoryMap getSpaceMaskToUse.
	self MoveR: t0 R: t2.
	self AndCq: s58 R: t2.
	s61 := objectMemory getMemoryMap getNewSpaceMask.
	self CmpCq: s61 R: t2.
	jump6 := self JumpNonZero: 0.
	s63 := objectMemory getMemoryMap getNewSpaceStart.
	self CmpCq: s63 R: t0.
	jumpTrue := self JumpAboveOrEqual: 0.
	self MoveCq: 0 R: t0.
	jumpNext := self Jump: 0.
	jumpTrue jmpTarget: self Label.
	self MoveCq: 1 R: t0.
	jumpNext jmpTarget: self Label.
	self CmpCq: 1 R: t0.
	jump7 := self JumpNonZero: 0.
	self MoveM64: 0 r: t1 R: t2.
	self LogicalShiftRightCq: 29 R: t2.
	self AndCq: 1 R: t2.
	self CmpCq: 0 R: t2.
	jump8 := self JumpNonZero: 0.
	self MoveR: t1 R: TempReg.
	backEnd saveAndRestoreLinkRegAround: [ self CallRT: ceStoreCheckTrampoline ].
	self annotateBytecode: self Label.
	jump9 := self Jump: 0.
	currentBlock := self Label.
	jump6 jmpTarget: currentBlock.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	jump3 jmpTarget: currentBlock.
	jump2 jmpTarget: currentBlock.
	jump5 jmpTarget: currentBlock.
	jump7 jmpTarget: currentBlock.
	jump8 jmpTarget: currentBlock.
	jump9 jmpTarget: currentBlock.
	^ 0
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_extStoreReceiverVariableBytecode [
	"AutoGenerated by Druid"

	| jump5 s4 jump3 jump8 s2 t1 s27 currentBlock s42 jump1 jump6 s34 s47 s10 s5 live jump4 s45 s3 t2 s37 s13 s8 jump7 t0 |
	live := 0.
	t0 := self allocateRegNotConflictingWith: live ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t0).
	t1 := self allocateRegNotConflictingWith: live ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t1).
	t2 := self allocateRegNotConflictingWith: live ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t2).
	s2 := byte1.
	s3 := extA.
	s4 := s3 << 8.
	s5 := s2 + s4.
	(self ssValue: 0) copyToReg: t0.
	self ensureReceiverResultRegContainsSelf.
	self MoveR: ReceiverResultReg R: t1.
	s8 := ReceiverIndex.
	self ssFlushStackExceptTop: 0.
	s5 <= s8 ifTrue: [
		| jump7 jump5 jump3 jump1 jump8 jump6 jump4 jump2 |
		self MoveM64: 0 r: t1 R: t2.
		self AndCq: 16r3FFFFF R: t2.
		s13 := ClassMethodContextCompactIndex.
		self CmpCq: s13 R: t2.
		jump1 := self JumpNonZero: 0.
		self deoptimize.
		jump2 := self Jump: 0.
		deadCode := false.
		currentBlock := self Label.
		jump1 jmpTarget: currentBlock.
		self MoveM64: 0 r: t1 R: t2.
		self LogicalShiftRightCq: 23 R: t2.
		self AndCq: 1 R: t2.
		self CmpCq: 0 R: t2.
		jump1 := self JumpZero: 0.
		self deoptimize.
		jump3 := self Jump: 0.
		deadCode := false.
		currentBlock := self Label.
		jump1 jmpTarget: currentBlock.
		s27 := s5 << 3.
		self MoveR: t1 R: t2.
		self AddCq: s27 R: t2.
		self MoveR: t0 M64: 8 r: t2.
		self MoveR: t1 R: t2.
		self AndCq: 7 R: t2.
		self CmpCq: 0 R: t2.
		jump1 := self JumpNonZero: 0.
		s34 := objectMemory getMemoryMap getSpaceMaskToUse.
		self MoveR: t1 R: t2.
		self AndCq: s34 R: t2.
		s37 := objectMemory getMemoryMap getOldSpaceMask.
		self CmpCq: s37 R: t2.
		jump4 := self JumpNonZero: 0.
		self MoveR: t0 R: t2.
		self AndCq: 7 R: t2.
		self CmpCq: 0 R: t2.
		jump5 := self JumpNonZero: 0.
		s42 := objectMemory getMemoryMap getSpaceMaskToUse.
		self MoveR: t0 R: t2.
		self AndCq: s42 R: t2.
		s45 := objectMemory getMemoryMap getNewSpaceMask.
		self CmpCq: s45 R: t2.
		jump6 := self JumpNonZero: 0.
		s47 := objectMemory getMemoryMap getNewSpaceStart.
		self CmpCq: s47 R: t0.
		jump7 := self JumpBelow: 0.
		self MoveM64: 0 r: t1 R: t2.
		self LogicalShiftRightCq: 29 R: t2.
		self AndCq: 1 R: t2.
		self CmpCq: 0 R: t2.
		jump8 := self JumpNonZero: 0.
		self MoveR: t1 R: TempReg.
		backEnd saveAndRestoreLinkRegAround: [ self CallRT: ceStoreCheckTrampoline ].
		self annotateBytecode: self Label.
		currentBlock := self Label.
		jump2 jmpTarget: currentBlock.
		jump3 jmpTarget: currentBlock.
		jump1 jmpTarget: currentBlock.
		jump4 jmpTarget: currentBlock.
		jump5 jmpTarget: currentBlock.
		jump6 jmpTarget: currentBlock.
		jump7 jmpTarget: currentBlock.
		jump8 jmpTarget: currentBlock.
		extA := 0.
		^ 0 ].
	self MoveM64: 0 r: t1 R: t2.
	self LogicalShiftRightCq: 23 R: t2.
	self AndCq: 1 R: t2.
	self CmpCq: 0 R: t2.
	jump8 := self JumpZero: 0.
	self deoptimize.
	jump7 := self Jump: 0.
	deadCode := false.
	currentBlock := self Label.
	jump8 jmpTarget: currentBlock.
	s27 := s5 << 3.
	self MoveR: t1 R: t2.
	self AddCq: s27 R: t2.
	self MoveR: t0 M64: 8 r: t2.
	self MoveR: t1 R: t2.
	self AndCq: 7 R: t2.
	self CmpCq: 0 R: t2.
	jump8 := self JumpNonZero: 0.
	s34 := objectMemory getMemoryMap getSpaceMaskToUse.
	self MoveR: t1 R: t2.
	self AndCq: s34 R: t2.
	s37 := objectMemory getMemoryMap getOldSpaceMask.
	self CmpCq: s37 R: t2.
	jump6 := self JumpNonZero: 0.
	self MoveR: t0 R: t2.
	self AndCq: 7 R: t2.
	self CmpCq: 0 R: t2.
	jump5 := self JumpNonZero: 0.
	s42 := objectMemory getMemoryMap getSpaceMaskToUse.
	self MoveR: t0 R: t2.
	self AndCq: s42 R: t2.
	s45 := objectMemory getMemoryMap getNewSpaceMask.
	self CmpCq: s45 R: t2.
	jump4 := self JumpNonZero: 0.
	s47 := objectMemory getMemoryMap getNewSpaceStart.
	self CmpCq: s47 R: t0.
	jump1 := self JumpBelow: 0.
	self MoveM64: 0 r: t1 R: t2.
	self LogicalShiftRightCq: 29 R: t2.
	self AndCq: 1 R: t2.
	self CmpCq: 0 R: t2.
	jump3 := self JumpNonZero: 0.
	self MoveR: t1 R: TempReg.
	backEnd saveAndRestoreLinkRegAround: [ self CallRT: ceStoreCheckTrampoline ].
	self annotateBytecode: self Label.
	currentBlock := self Label.
	jump7 jmpTarget: currentBlock.
	jump8 jmpTarget: currentBlock.
	jump6 jmpTarget: currentBlock.
	jump5 jmpTarget: currentBlock.
	jump4 jmpTarget: currentBlock.
	jump1 jmpTarget: currentBlock.
	jump3 jmpTarget: currentBlock.
	extA := 0.
	^ 0
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_extUnconditionalJump [
	"AutoGenerated by Druid"

	| s6 s4 s9 s2 t1 currentBlock s27 s19 jump1 s7 s25 s17 live s5 s3 s28 s8 s26 t0 s11 |
	live := 0.
	t0 := self allocateRegNotConflictingWith: live ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t0).
	t1 := self allocateRegNotConflictingWith: live ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t1).
	s2 := byte1.
	s3 := extB.
	s4 := s3 << 8.
	s5 := s2 + s4.
	s5 < 0 ifTrue: [
		| jump1 |
		s7 := numExtB.
		s8 := s7 << 1.
		s9 := s8.
		extB := 0.
		numExtB := 0.
		s17 := s5 + s9.
		self ssFlushStackExceptTop: 0.
		s17 >= 0 ifTrue: [
			s25 := bytecodePC.
			s26 := s25 + s5.
			s27 := s26 + 2.
			self Jump: (self ensureFixupAt: s27).
			deadCode := true.
			^ 0 ].
		self MoveR: SPReg R: t0.
		self MoveAw: coInterpreter stackLimitAddress R: t1.
		self CmpR: t1 R: t0.
		jump1 := self JumpAboveOrEqual: 0.
		self CallRT: ceCheckForInterruptTrampoline.
		self annotateBytecode: self Label.
		currentBlock := self Label.
		jump1 jmpTarget: currentBlock.
		s25 := bytecodePC.
		s26 := s25 + s5.
		s27 := s26 + 2.
		self Jump: (self ensureFixupAt: s27).
		deadCode := true.
		^ 0 ].
	s11 := 0.
	s9 := s11.
	extB := 0.
	numExtB := 0.
	s17 := s5 + s9.
	self ssFlushStackExceptTop: 0.
	s17 >= 0 ifTrue: [
		s25 := bytecodePC.
		s26 := s25 + s5.
		s27 := s26 + 2.
		self Jump: (self ensureFixupAt: s27).
		deadCode := true.
		^ 0 ].
	self MoveR: SPReg R: t0.
	self MoveAw: coInterpreter stackLimitAddress R: t1.
	self CmpR: t1 R: t0.
	jump1 := self JumpAboveOrEqual: 0.
	self CallRT: ceCheckForInterruptTrampoline.
	self annotateBytecode: self Label.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	s25 := bytecodePC.
	s26 := s25 + s5.
	s27 := s26 + 2.
	self Jump: (self ensureFixupAt: s27).
	deadCode := true.
	^ 0
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_extendedPushBytecode [
	"AutoGenerated by Druid"

	| s6 s55 s4 s29 s2 s20 currentBlock t1 s19 s17 live s5 s54 s3 s28 s30 s21 s13 s8 s26 t0 |
	live := 0.
	t0 := self allocateRegNotConflictingWith: live ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t0).
	t1 := self allocateRegNotConflictingWith: live ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t1).
	s2 := byte1.
	s3 := s2 >> 6.
	s4 := s3 bitAnd: 3.
	s5 := s2 bitAnd: 63.
	s4 = 0 ifTrue: [
		self ensureReceiverResultRegContainsSelf.
		self MoveR: ReceiverResultReg R: t0.
		s8 := s5 << 3.
		self AddCq: s8 R: t0.
		self MoveM64: 8 r: t0 R: t0.
		self ssPushRegister: t0.
		^ 0 ].
	s4 = 1 ifTrue: [
		(self simStackTempAt: s5) copyToReg: t0.
		self ssPushRegister: t0.
		^ 0 ].
	s4 = 2 ifTrue: [
		self genMoveConstant: methodObj R: t0.
		s19 := LiteralStart.
		s20 := s5 + s19.
		s21 := s20 << 3.
		self AddCq: s21 R: t0.
		self MoveM64: 8 r: t0 R: t0.
		self ssPushRegister: t0.
		^ 0 ].
	s4 = 3 ifTrue: [
		| jump3 jump1 b320 jump4 jump2 |
		self genMoveConstant: methodObj R: t0.
		s28 := LiteralStart.
		s29 := s5 + s28.
		s30 := s29 << 3.
		self AddCq: s30 R: t0.
		self MoveM64: 8 r: t0 R: t0.
		self MoveM64: 0 r: t0 R: t1.
		self AndCq: 16r3FFFF7 R: t1.
		self CmpCq: 0 R: t1.
		jump1 := self JumpNonZero: 0.
		self MoveM64: 8 r: t0 R: t1.
		b320 := self Label.
		self MoveR: t1 R: t0.
		self AndCq: 7 R: t0.
		self CmpCq: 0 R: t0.
		jump2 := self JumpNonZero: 0.
		self MoveM64: 0 r: t1 R: t0.
		self AndCq: 16r3FFFF7 R: t0.
		self CmpCq: 0 R: t0.
		jump3 := self JumpNonZero: 0.
		self MoveM64: 8 r: t1 R: t0.
		self MoveR: t0 R: t1.
		jump4 := self Jump: b320.
		currentBlock := self Label.
		jump2 jmpTarget: currentBlock.
		jump3 jmpTarget: currentBlock.
		self MoveR: t1 R: t0.
		jump3 := self Jump: 0.
		currentBlock := self Label.
		jump1 jmpTarget: currentBlock.
		currentBlock := self Label.
		jump3 jmpTarget: currentBlock.
		s54 := ValueIndex.
		s55 := s54 << 3.
		self AddCq: s55 R: t0.
		self MoveM64: 8 r: t0 R: t0.
		self ssPushRegister: t0.
		^ 0 ].
	self ssPushRegister: t0.
	^ 0
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_failingPrimitive [
	"AutoGenerated by Druid"

	| currentBlock |
	^ 0
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_failingPrimitive2 [

	| currentBlock |
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_failingPrimitiveWithArg [
	"AutoGenerated by Druid"

	| currentBlock |
	self MoveR: Arg0Reg R: ClassReg.
	^ 0
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_failingSuccess [
	"AutoGenerated by Druid"

	| currentBlock |
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_fakePushConstantTrueBytecode [
	"AutoGenerated by Druid"

	| nextBytecode s2 currentBlock nextFixup live |
	nextFixup := self fixupAt: bytecodePC + 1.
	nextFixup notAFixup ifTrue: [
		nextBytecode := objectMemory fetchByte: bytecodePC + 1 ofObject: methodObj.
		nextBytecode = 92 ifTrue: [
			bytecodePC := bytecodePC + 1.
			^ self gen_pushConstantTrueBytecode_returnTopFromMethod_1 ] ].
	live := 0.
	s2 := objectMemory trueObject.
	self ssPushConstant: s2.
	^ 0
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_ifZeroFailPrimitive [
	"AutoGenerated by Druid"

	| jump1 currentBlock |
	self MoveR: ReceiverResultReg R: ClassReg.
	self MoveR: Arg0Reg R: SendNumArgsReg.
	self CmpCq: 0 R: ClassReg.
	jump1 := self JumpZero: 0.
	self MoveCq: 42 R: ReceiverResultReg.
	self genPrimReturn.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	^ 0
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_passingSuccess [
	"AutoGenerated by Druid"

	| currentBlock |
	self MoveCq: 1 R: ReceiverResultReg.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveAccessTempAfterCall [
	"AutoGenerated by Druid"

	| currentBlock |
	self MoveCq: 17 R: ReceiverResultReg.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveAdd [
	"AutoGenerated by Druid"

	| jump1 jump2 currentBlock |
	self mclassIsSmallInteger ifFalse: [ ^ UnimplementedPrimitive ].
	self MoveR: ReceiverResultReg R: ClassReg.
	self MoveR: Arg0Reg R: SendNumArgsReg.
	self TstCq: 1 R: SendNumArgsReg.
	jump1 := self JumpZero: 0.
	self AddCq:  -1 R: SendNumArgsReg.
	self AddR: ClassReg R: SendNumArgsReg.
	jump2 := self JumpOverflow: 0.
	self MoveR: SendNumArgsReg R: ReceiverResultReg.
	self genPrimReturn.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	jump2 jmpTarget: currentBlock.
	^ 0
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveAnd [
	"AutoGenerated by Druid"

	| s8 jump1 jump3 currentBlock jump2 s5 |
	self MoveR: ReceiverResultReg R: ClassReg.
	self CmpCq: 0 R: ClassReg.
	jump1 := self JumpLessOrEqual: 0.
	self CmpCq: 10 R: ClassReg.
	jump2 := self JumpLessOrEqual: 0.
	s5 := 42.
	self MoveCq: s5 R: ClassReg.
	jump3 := self Jump: 0.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	jump2 jmpTarget: currentBlock.
	s8 := 10.
	self MoveCq: s8 R: ClassReg.
	currentBlock := self Label.
	jump3 jmpTarget: currentBlock.
	self MoveR: ClassReg R: ReceiverResultReg.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveAndIfTrue [
	"AutoGenerated by Druid"

	| jump3 jump1 s6 currentBlock s9 jump2 |
	self MoveR: ReceiverResultReg R: ClassReg.
	self CmpCq: 1 R: ClassReg.
	jump1 := self JumpLessOrEqual: 0.
	self AndCq: 1 R: ClassReg.
	self CmpCq: 1 R: ClassReg.
	jump2 := self JumpNonZero: 0.
	s6 := 1.
	self MoveCq: s6 R: ClassReg.
	jump3 := self Jump: 0.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	jump2 jmpTarget: currentBlock.
	s9 := 2.
	self MoveCq: s9 R: ClassReg.
	currentBlock := self Label.
	jump3 jmpTarget: currentBlock.
	self MoveR: ClassReg R: ReceiverResultReg.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveArithmeticBitShiftRight [
	"AutoGenerated by Druid"

	| currentBlock |
	self MoveR: ReceiverResultReg R: ClassReg.
	self MoveR: Arg0Reg R: SendNumArgsReg.
	self ArithmeticShiftRightR: SendNumArgsReg R: ClassReg.
	self MoveR: ClassReg R: ReceiverResultReg.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveAsCharacter [
	"AutoGenerated by Druid"

	| s13 s14 s2 currentBlock s3 |
	s2 := self methodNumArgs.
	s2 = 0 ifTrue: [
		| jump1 jump2 jump3 |
		self MoveR: ReceiverResultReg R: ClassReg.
		self TstCq: 1 R: ClassReg.
		jump1 := self JumpZero: 0.
		self ArithmeticShiftRightCq: 3 R: ClassReg.
		self CmpCq: 0 R: ClassReg.
		jump2 := self JumpLess: 0.
		self CmpCq: 16r3FFFFFFF R: ClassReg.
		jump3 := self JumpGreater: 0.
		self LogicalShiftLeftCq: 3 R: ClassReg.
		self AddCq: 2 R: ClassReg.
		self MoveR: ClassReg R: ReceiverResultReg.
		self genPrimReturn.
		currentBlock := self Label.
		jump1 jmpTarget: currentBlock.
		jump2 jmpTarget: currentBlock.
		jump3 jmpTarget: currentBlock.
		^ 0 ].
	s13 := self methodNumArgs.
	s13 = 1 ifTrue: [
		| jump3 jump2 jump1 |
		self MoveR: Arg0Reg R: ClassReg.
		self TstCq: 1 R: ClassReg.
		jump3 := self JumpZero: 0.
		self ArithmeticShiftRightCq: 3 R: ClassReg.
		self CmpCq: 0 R: ClassReg.
		jump2 := self JumpLess: 0.
		self CmpCq: 16r3FFFFFFF R: ClassReg.
		jump1 := self JumpGreater: 0.
		self LogicalShiftLeftCq: 3 R: ClassReg.
		self AddCq: 2 R: ClassReg.
		self MoveR: ClassReg R: ReceiverResultReg.
		self genPrimReturn.
		currentBlock := self Label.
		jump3 jmpTarget: currentBlock.
		jump2 jmpTarget: currentBlock.
		jump1 jmpTarget: currentBlock.
		^ 0 ].
	^ 0
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveAsFloat [
	"AutoGenerated by Druid"

	| s34 jump5 jump3 jump1 currentBlock s31 jump2 jump4 |
	self MoveR: ReceiverResultReg R: ClassReg.
	self ArithmeticShiftRightCq: 3 R: ClassReg.
	self ConvertR: ClassReg Rd: DPFPReg0.
	self MoveRd: DPFPReg0 R: ClassReg.
	self MoveR: ClassReg R: SendNumArgsReg.
	self LogicalShiftRightCq: 52 R: SendNumArgsReg.
	self AndCq: 2047 R: SendNumArgsReg.
	self CmpCq: 896 R: SendNumArgsReg.
	jump1 := self JumpBelowOrEqual: 0.
	self CmpCq: 1151 R: SendNumArgsReg.
	jump2 := self JumpBelowOrEqual: 0.
	jump3 := self JumpAbove: 0.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	self AndCq: 16rFFFFFFFFFFFFF R: ClassReg.
	self CmpCq: 0 R: ClassReg.
	jump1 := self JumpNonZero: 0.
	self CmpCq: 0 R: SendNumArgsReg.
	jump4 := self JumpZero: 0.
	jump5 := self JumpNonZero: 0.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	self CmpCq: 896 R: SendNumArgsReg.
	jump1 := self JumpNonZero: 0.
	currentBlock := self Label.
	jump2 jmpTarget: currentBlock.
	jump4 jmpTarget: currentBlock.
	self MoveRd: DPFPReg0 R: SendNumArgsReg.
	self RotateLeftCq: 1 R: SendNumArgsReg.
	self CmpCq: 1 R: SendNumArgsReg.
	jump4 := self JumpBelowOrEqual: 0.
	self SubCq: 16r7000000000000000 R: SendNumArgsReg.
	jump2 := self Jump: 0.
	currentBlock := self Label.
	jump4 jmpTarget: currentBlock.
	currentBlock := self Label.
	jump2 jmpTarget: currentBlock.
	self LogicalShiftLeftCq: 3 R: SendNumArgsReg.
	self AddCq: 4 R: SendNumArgsReg.
	jump2 := self Jump: 0.
	currentBlock := self Label.
	jump3 jmpTarget: currentBlock.
	jump5 jmpTarget: currentBlock.
	jump1 jmpTarget: currentBlock.
	self MoveAw: objectMemory freeStartAddress R: SendNumArgsReg.
	self MoveAw: objectMemory freeStartAddress R: ClassReg.
	self AddCq: 16 R: ClassReg.
	s31 := objectMemory getScavengeThreshold.
	self CmpCq: s31 R: ClassReg.
	jump1 := self JumpAbove: 0.
	s34 := 72057594205700130.
	self MoveCq: s34 R: ClassReg.
	self MoveR: ClassReg M64: 0 r: SendNumArgsReg.
	self MoveAw: objectMemory freeStartAddress R: ClassReg.
	self AddCq: 16 R: ClassReg.
	self MoveR: ClassReg Aw: objectMemory freeStartAddress.
	self MoveRd: DPFPReg0 M64: 8 r: SendNumArgsReg.
	currentBlock := self Label.
	jump2 jmpTarget: currentBlock.
	self MoveR: SendNumArgsReg R: ReceiverResultReg.
	self genPrimReturn.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	^ 0
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveAsFloatAddition [
	"AutoGenerated by Druid"

	| currentBlock |
	self MoveR: ReceiverResultReg R: ClassReg.
	self MoveR: Arg0Reg R: SendNumArgsReg.
	self ConvertR: SendNumArgsReg Rd: DPFPReg0.
	self ConvertR: ClassReg Rd: DPFPReg1.
	self AddRd: DPFPReg1 Rd: DPFPReg0.
	self MoveRd: DPFPReg0 R: ClassReg.
	self MoveR: ClassReg R: ReceiverResultReg.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveAsFloatDivision [
	"AutoGenerated by Druid"

	| currentBlock |
	self MoveR: ReceiverResultReg R: ClassReg.
	self MoveR: Arg0Reg R: SendNumArgsReg.
	self ConvertR: SendNumArgsReg Rd: DPFPReg0.
	self ConvertR: ClassReg Rd: DPFPReg1.
	self DivRd: DPFPReg1 Rd: DPFPReg0.
	self MoveRd: DPFPReg0 R: ClassReg.
	self MoveR: ClassReg R: ReceiverResultReg.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveAsFloatMultiply [
	"AutoGenerated by Druid"

	| currentBlock |
	self MoveR: ReceiverResultReg R: ClassReg.
	self MoveR: Arg0Reg R: SendNumArgsReg.
	self ConvertR: SendNumArgsReg Rd: DPFPReg0.
	self ConvertR: ClassReg Rd: DPFPReg1.
	self MulRd: DPFPReg1 Rd: DPFPReg0.
	self MoveRd: DPFPReg0 R: ClassReg.
	self MoveR: ClassReg R: ReceiverResultReg.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveAsFloatSubtract [
	"AutoGenerated by Druid"

	| currentBlock |
	self MoveR: ReceiverResultReg R: ClassReg.
	self MoveR: Arg0Reg R: SendNumArgsReg.
	self ConvertR: SendNumArgsReg Rd: DPFPReg0.
	self ConvertR: ClassReg Rd: DPFPReg1.
	self SubRd: DPFPReg1 Rd: DPFPReg0.
	self MoveRd: DPFPReg0 R: ClassReg.
	self MoveR: ClassReg R: ReceiverResultReg.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveAsInteger [
	"AutoGenerated by Druid"

	| currentBlock |
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveAssertDeferredInline [
	"AutoGenerated by Druid"

	| jump1 jump2 jump3 currentBlock |
	self MoveCq: 0 R: TempReg.
	self MoveR: TempReg Aw: coInterpreter primitiveFailureCodeAddress.
	self MoveAw: coInterpreter primitiveFailureCodeAddress R: TempReg.
	self MoveR: ReceiverResultReg R: ClassReg.
	self CmpCq: 0 R: ClassReg.
	jump1 := self JumpNonZero: 0.
	self MoveR: TempReg Aw: coInterpreter primitiveFailureCodeAddress.
	self MoveCq: 1 R: ClassReg.
	self MoveR: ClassReg Aw: coInterpreter primitiveFailureCodeAddress.
	self MoveAw: coInterpreter primitiveFailureCodeAddress R: ClassReg.
	self MoveR: ClassReg Aw: coInterpreter primitiveFailureCodeAddress.
	self MoveAw: coInterpreter primitiveFailureCodeAddress R: ClassReg.
	self MoveCq: 42 R: ReceiverResultReg.
	self CmpCq: 0 R: ClassReg.
	jump2 := self JumpZero: 0.
	jump3 := self JumpNonZero: 0.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	self MoveR: TempReg Aw: coInterpreter primitiveFailureCodeAddress.
	self MoveAw: coInterpreter primitiveFailureCodeAddress R: ClassReg.
	self MoveCq: 42 R: ReceiverResultReg.
	self CmpCq: 0 R: ClassReg.
	jump1 := self JumpNonZero: 0.
	currentBlock := self Label.
	jump2 jmpTarget: currentBlock.
	self genPrimReturn.
	currentBlock := self Label.
	jump3 jmpTarget: currentBlock.
	jump1 jmpTarget: currentBlock.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveAssertIsIgnored [
	"AutoGenerated by Druid"

	| currentBlock |
	self MoveCq: 17 R: ReceiverResultReg.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveAt [
	"AutoGenerated by Druid"

	| jump1 jump10 jump9 jump6 jump3 jump12 currentBlock jump8 jump5 jump2 s73 jump11 s55 s93 jump7 jump4 |
	self SubCq: 24 R: SPReg.
	self MoveR: ReceiverResultReg R: Extra3Reg.
	self MoveR: Extra3Reg Mw: 0 r: SPReg.
	self MoveR: Arg0Reg R: Extra3Reg.
	self MoveR: Extra3Reg Mw: 8 r: SPReg.
	self MoveMw: 0 r: SPReg R: Extra3Reg.
	self TstCq: 7 R: Extra3Reg.
	jump1 := self JumpNonZero: 0.
	self MoveMw: 8 r: SPReg R: Extra3Reg.
	self MoveR: Extra3Reg R: Extra0Reg.
	self AndCq: 1 R: Extra0Reg.
	self CmpCq: 0 R: Extra0Reg.
	jump2 := self JumpZero: 0.
	self MoveMw: 0 r: SPReg R: Extra3Reg.
	self MoveM64: 0 r: Extra3Reg R: Extra0Reg.
	self AndCq: 16r3FFFF7 R: Extra0Reg.
	self CmpCq: 0 R: Extra0Reg.
	jump3 := self JumpZero: 0.
	self MoveMw: 8 r: SPReg R: Extra3Reg.
	self ArithmeticShiftRightCq: 3 R: Extra3Reg.
	self MoveR: Extra3Reg Mw: 8 r: SPReg.
	self MoveMw: 0 r: SPReg R: Extra3Reg.
	self MoveM64: 0 r: Extra3Reg R: Extra3Reg.
	self MoveR: Extra3Reg Mw: 16 r: SPReg.
	self MoveMw: 16 r: SPReg R: Extra3Reg.
	self MoveR: Extra3Reg R: Extra1Reg.
	self LogicalShiftRightCq: 24 R: Extra1Reg.
	self AndCq: 31 R: Extra1Reg.
	self MoveMw: 0 r: SPReg R: Extra3Reg.
	self MoveMb: 7 r: Extra3Reg R: Extra2Reg.
	self AndCq: 255 R: Extra2Reg.
	self CmpCq: 255 R: Extra2Reg.
	jump4 := self JumpNonZero: 0.
	self MoveMw: 0 r: SPReg R: Extra3Reg.
	self MoveM64: -8 r: Extra3Reg R: Extra2Reg.
	self LogicalShiftLeftCq: 8 R: Extra2Reg.
	self LogicalShiftRightCq: 8 R: Extra2Reg.
	jump5 := self Jump: 0.
	currentBlock := self Label.
	jump4 jmpTarget: currentBlock.
	currentBlock := self Label.
	jump5 jmpTarget: currentBlock.
	self CmpCq: 5 R: Extra1Reg.
	jump5 := self JumpAbove: 0.
	jump4 := self Jump: 0.
	currentBlock := self Label.
	jump5 jmpTarget: currentBlock.
	self CmpCq: 16 R: Extra1Reg.
	jump5 := self JumpBelow: 0.
	self LogicalShiftLeftCq: 3 R: Extra2Reg.
	self MoveR: Extra1Reg R: ClassReg.
	self AndCq: 7 R: ClassReg.
	self SubR: ClassReg R: Extra2Reg.
	self MoveR: Extra2Reg R: ClassReg.
	jump6 := self Jump: 0.
	currentBlock := self Label.
	jump5 jmpTarget: currentBlock.
	self CmpCq: 12 R: Extra1Reg.
	jump5 := self JumpBelow: 0.
	self LogicalShiftLeftCq: 2 R: Extra2Reg.
	self MoveR: Extra1Reg R: ClassReg.
	self AndCq: 3 R: ClassReg.
	self SubR: ClassReg R: Extra2Reg.
	self MoveR: Extra2Reg R: ClassReg.
	jump7 := self Jump: 0.
	currentBlock := self Label.
	jump5 jmpTarget: currentBlock.
	self CmpCq: 10 R: Extra1Reg.
	jump5 := self JumpBelow: 0.
	self LogicalShiftLeftCq: 1 R: Extra2Reg.
	self MoveR: Extra1Reg R: ClassReg.
	self AndCq: 1 R: ClassReg.
	self SubR: ClassReg R: Extra2Reg.
	jump8 := self Jump: 0.
	currentBlock := self Label.
	jump5 jmpTarget: currentBlock.
	self CmpCq: 9 R: Extra1Reg.
	jump5 := self JumpNonZero: 0.
	jump9 := self Jump: 0.
	currentBlock := self Label.
	jump5 jmpTarget: currentBlock.
	s55 := 0.
	self MoveCq: s55 R: Extra2Reg.
	currentBlock := self Label.
	jump4 jmpTarget: currentBlock.
	jump8 jmpTarget: currentBlock.
	jump9 jmpTarget: currentBlock.
	self CmpCq: 9 R: Extra1Reg.
	jump9 := self JumpBelow: 0.
	self MoveR: Extra2Reg R: ClassReg.
	currentBlock := self Label.
	jump7 jmpTarget: currentBlock.
	currentBlock := self Label.
	jump6 jmpTarget: currentBlock.
	jump6 := self Jump: 0.
	currentBlock := self Label.
	jump9 jmpTarget: currentBlock.
	self CmpCq: 2 R: Extra1Reg.
	jump9 := self JumpNonZero: 0.
	self MoveR: Extra2Reg R: ClassReg.
	currentBlock := self Label.
	jump6 jmpTarget: currentBlock.
	s73 := 0.
	self MoveCq: s73 R: Extra2Reg.
	jump6 := self Jump: 0.
	currentBlock := self Label.
	jump9 jmpTarget: currentBlock.
	self CmpCq: 2 R: Extra1Reg.
	jump9 := self JumpAboveOrEqual: 0.
	self MoveR: Extra2Reg R: ClassReg.
	jump7 := self Jump: 0.
	currentBlock := self Label.
	jump9 jmpTarget: currentBlock.
	self MoveMw: 0 r: SPReg R: Extra3Reg.
	self MoveM64: 0 r: Extra3Reg R: ClassReg.
	self AndCq: 16r3FFFFF R: ClassReg.
	self CmpCq: 31 R: ClassReg.
	jump9 := self JumpAbove: 0.
	self CmpCq: 31 R: ClassReg.
	jump8 := self JumpNonZero: 0.
	self MoveMw: 0 r: SPReg R: Extra3Reg.
	self MoveR: Extra3Reg R: ClassReg.
	jump4 := self Jump: 0.
	currentBlock := self Label.
	jump8 jmpTarget: currentBlock.
	self CmpCq: 8 R: ClassReg.
	jump8 := self JumpNonZero: 0.
	self genMoveConstant: objectMemory nilObject R: ClassReg.
	jump5 := self Jump: 0.
	currentBlock := self Label.
	jump9 jmpTarget: currentBlock.
	jump8 jmpTarget: currentBlock.
	self MoveR: ClassReg R: SendNumArgsReg.
	self LogicalShiftRightCq: 10 R: SendNumArgsReg.
	s93 := objectMemory hiddenRootsObject.
	self LogicalShiftLeftCq: 3 R: SendNumArgsReg.
	self AddCq: s93 R: SendNumArgsReg.
	self MoveM64: 8 r: SendNumArgsReg R: SendNumArgsReg.
	self genMoveConstant: objectMemory nilObject R: Extra0Reg.
	self CmpR: Extra0Reg R: SendNumArgsReg.
	jump8 := self JumpNonZero: 0.
	self genMoveConstant: objectMemory nilObject R: Extra0Reg.
	jump9 := self Jump: 0.
	currentBlock := self Label.
	jump8 jmpTarget: currentBlock.
	self AndCq: 1023 R: ClassReg.
	self LogicalShiftLeftCq: 3 R: ClassReg.
	self AddR: ClassReg R: SendNumArgsReg.
	self MoveM64: 8 r: SendNumArgsReg R: Extra0Reg.
	currentBlock := self Label.
	jump9 jmpTarget: currentBlock.
	self MoveR: Extra0Reg R: ClassReg.
	currentBlock := self Label.
	jump4 jmpTarget: currentBlock.
	jump5 jmpTarget: currentBlock.
	self MoveM64: 24 r: ClassReg R: Extra0Reg.
	self ArithmeticShiftRightCq: 3 R: Extra0Reg.
	self AndCq: 16rFFFF R: Extra0Reg.
	self MoveR: Extra2Reg R: ClassReg.
	self MoveR: Extra0Reg R: Extra2Reg.
	currentBlock := self Label.
	jump6 jmpTarget: currentBlock.
	jump7 jmpTarget: currentBlock.
	self CmpCq: 3 R: Extra1Reg.
	jump7 := self JumpNonZero: 0.
	self MoveMw: 16 r: SPReg R: Extra3Reg.
	self AndCq: 16r3FFFFF R: Extra3Reg.
	self MoveR: Extra3Reg Mw: 16 r: SPReg.
	self MoveMw: 16 r: SPReg R: Extra3Reg.
	self CmpCq: 36 R: Extra3Reg.
	jump6 := self JumpZero: 0.
	currentBlock := self Label.
	jump7 jmpTarget: currentBlock.
	self SubR: Extra2Reg R: ClassReg.
	self CmpCq: 24 R: Extra1Reg.
	jump7 := self JumpAboveOrEqual: 0.
	self MoveMw: 8 r: SPReg R: Extra3Reg.
	self CmpCq: 1 R: Extra3Reg.
	jump5 := self JumpBelow: 0.
	self MoveMw: 8 r: SPReg R: Extra3Reg.
	self CmpR: ClassReg R: Extra3Reg.
	jump4 := self JumpAbove: 0.
	self MoveMw: 8 r: SPReg R: Extra3Reg.
	self AddR: Extra2Reg R: Extra3Reg.
	self MoveR: Extra3Reg Mw: 8 r: SPReg.
	self CmpCq: 5 R: Extra1Reg.
	jump9 := self JumpAbove: 0.
	self MoveMw: 8 r: SPReg R: Extra3Reg.
	self SubCq: 1 R: Extra3Reg.
	self MoveR: Extra3Reg Mw: 8 r: SPReg.
	self MoveMw: 8 r: SPReg R: Extra3Reg.
	self LogicalShiftLeftCq: 3 R: Extra3Reg.
	self MoveR: Extra3Reg Mw: 8 r: SPReg.
	self MoveMw: 0 r: SPReg R: Extra3Reg.
	self MoveMw: 8 r: SPReg R: Extra4Reg.
	self AddR: Extra4Reg R: Extra3Reg.
	self MoveR: Extra3Reg Mw: 0 r: SPReg.
	self MoveMw: 0 r: SPReg R: Extra3Reg.
	self MoveM64: 8 r: Extra3Reg R: Extra0Reg.
	jump8 := self Jump: 0.
	currentBlock := self Label.
	jump9 jmpTarget: currentBlock.
	self CmpCq: 16 R: Extra1Reg.
	jump9 := self JumpBelow: 0.
	self MoveMw: 8 r: SPReg R: Extra3Reg.
	self MoveMw: 0 r: SPReg R: Extra4Reg.
	self AddR: Extra4Reg R: Extra3Reg.
	self MoveR: Extra3Reg Mw: 8 r: SPReg.
	self MoveMw: 8 r: SPReg R: Extra3Reg.
	self AddCq:  -1 R: Extra3Reg.
	self MoveR: Extra3Reg Mw: 8 r: SPReg.
	self MoveMw: 8 r: SPReg R: Extra3Reg.
	self MoveMb: 8 r: Extra3Reg R: Extra0Reg.
	self AndCq: 255 R: Extra0Reg.
	self LogicalShiftLeftCq: 3 R: Extra0Reg.
	self AddCq: 1 R: Extra0Reg.
	jump10 := self Jump: 0.
	currentBlock := self Label.
	jump9 jmpTarget: currentBlock.
	self CmpCq: 12 R: Extra1Reg.
	jump9 := self JumpBelow: 0.
	self MoveMw: 8 r: SPReg R: Extra3Reg.
	self SubCq: 1 R: Extra3Reg.
	self MoveR: Extra3Reg Mw: 8 r: SPReg.
	self MoveMw: 8 r: SPReg R: Extra3Reg.
	self LogicalShiftLeftCq: 1 R: Extra3Reg.
	self MoveR: Extra3Reg Mw: 8 r: SPReg.
	self MoveMw: 0 r: SPReg R: Extra3Reg.
	self MoveMw: 8 r: SPReg R: Extra4Reg.
	self AddR: Extra4Reg R: Extra3Reg.
	self MoveR: Extra3Reg Mw: 0 r: SPReg.
	self MoveMw: 0 r: SPReg R: Extra3Reg.
	self MoveM16: 8 r: Extra3Reg R: Extra0Reg.
	self AndCq: 16rFFFF R: Extra0Reg.
	self LogicalShiftLeftCq: 3 R: Extra0Reg.
	self AddCq: 1 R: Extra0Reg.
	jump11 := self Jump: 0.
	currentBlock := self Label.
	jump9 jmpTarget: currentBlock.
	self CmpCq: 9 R: Extra1Reg.
	jump9 := self JumpNonZero: 0.
	self MoveMw: 8 r: SPReg R: Extra3Reg.
	self SubCq: 1 R: Extra3Reg.
	self MoveR: Extra3Reg Mw: 8 r: SPReg.
	self MoveMw: 8 r: SPReg R: Extra3Reg.
	self LogicalShiftLeftCq: 3 R: Extra3Reg.
	self MoveR: Extra3Reg Mw: 8 r: SPReg.
	self MoveMw: 0 r: SPReg R: Extra3Reg.
	self MoveMw: 8 r: SPReg R: Extra4Reg.
	self AddR: Extra4Reg R: Extra3Reg.
	self MoveR: Extra3Reg Mw: 0 r: SPReg.
	self MoveMw: 0 r: SPReg R: Extra3Reg.
	self MoveM64: 8 r: Extra3Reg R: Extra0Reg.
	self CmpCq: 16rFFFFFFFFFFFFFFF R: Extra0Reg.
	jump12 := self JumpAbove: 0.
	self LogicalShiftLeftCq: 3 R: Extra0Reg.
	self AddCq: 1 R: Extra0Reg.
	currentBlock := self Label.
	jump8 jmpTarget: currentBlock.
	jump10 jmpTarget: currentBlock.
	jump11 jmpTarget: currentBlock.
	self MoveR: Extra0Reg R: ReceiverResultReg.
	self AddCq: 24 R: SPReg.
	self genPrimReturn.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	jump2 jmpTarget: currentBlock.
	jump3 jmpTarget: currentBlock.
	jump6 jmpTarget: currentBlock.
	jump7 jmpTarget: currentBlock.
	jump5 jmpTarget: currentBlock.
	jump4 jmpTarget: currentBlock.
	jump9 jmpTarget: currentBlock.
	jump12 jmpTarget: currentBlock.
	self AddCq: 24 R: SPReg.
	^ 0
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveAtPut [
	"AutoGenerated by Druid"

	| jump5 s153 jump10 s81 jump17 jump3 s145 jump15 jump24 jump8 jump1 currentBlock s101 jump13 jumpNext jump6 jump22 jump18 jump11 jump20 jump4 jumpTrue jump16 jump25 s63 jump9 jump2 s150 jump14 jump23 jump7 s142 s155 jump12 jump19 jump21 |
	self SubCq: 24 R: SPReg.
	self MoveR: ReceiverResultReg R: Extra3Reg.
	self MoveR: Extra3Reg Mw: 0 r: SPReg.
	self MoveR: Arg0Reg R: Extra3Reg.
	self MoveR: Extra3Reg Mw: 8 r: SPReg.
	self MoveR: Arg1Reg R: Extra3Reg.
	self MoveR: Extra3Reg Mw: 16 r: SPReg.
	self MoveMw: 0 r: SPReg R: Extra3Reg.
	self TstCq: 7 R: Extra3Reg.
	jump1 := self JumpNonZero: 0.
	self MoveMw: 8 r: SPReg R: Extra3Reg.
	self MoveR: Extra3Reg R: Extra1Reg.
	self AndCq: 1 R: Extra1Reg.
	self CmpCq: 0 R: Extra1Reg.
	jump2 := self JumpZero: 0.
	self MoveMw: 0 r: SPReg R: Extra3Reg.
	self MoveM64: 0 r: Extra3Reg R: Extra1Reg.
	self AndCq: 16r3FFFF7 R: Extra1Reg.
	self CmpCq: 0 R: Extra1Reg.
	jump3 := self JumpZero: 0.
	self MoveMw: 0 r: SPReg R: Extra3Reg.
	self MoveM64: 0 r: Extra3Reg R: Extra1Reg.
	self LogicalShiftRightCq: 23 R: Extra1Reg.
	self AndCq: 1 R: Extra1Reg.
	self CmpCq: 0 R: Extra1Reg.
	jump4 := self JumpNonZero: 0.
	self MoveMw: 8 r: SPReg R: Extra3Reg.
	self ArithmeticShiftRightCq: 3 R: Extra3Reg.
	self MoveR: Extra3Reg Mw: 8 r: SPReg.
	self MoveMw: 0 r: SPReg R: Extra3Reg.
	self MoveM64: 0 r: Extra3Reg R: Extra1Reg.
	self MoveR: Extra1Reg R: Extra2Reg.
	self AndCq: 16r3FFFFF R: Extra2Reg.
	self CmpCq: 36 R: Extra2Reg.
	jump5 := self JumpZero: 0.
	self LogicalShiftRightCq: 24 R: Extra1Reg.
	self AndCq: 31 R: Extra1Reg.
	self MoveMw: 0 r: SPReg R: Extra3Reg.
	self MoveMb: 7 r: Extra3Reg R: Extra2Reg.
	self AndCq: 255 R: Extra2Reg.
	self CmpCq: 255 R: Extra2Reg.
	jump6 := self JumpNonZero: 0.
	self MoveMw: 0 r: SPReg R: Extra3Reg.
	self MoveM64: -8 r: Extra3Reg R: Extra2Reg.
	self LogicalShiftLeftCq: 8 R: Extra2Reg.
	self LogicalShiftRightCq: 8 R: Extra2Reg.
	jump7 := self Jump: 0.
	currentBlock := self Label.
	jump6 jmpTarget: currentBlock.
	currentBlock := self Label.
	jump7 jmpTarget: currentBlock.
	self CmpCq: 5 R: Extra1Reg.
	jump7 := self JumpAbove: 0.
	jump6 := self Jump: 0.
	currentBlock := self Label.
	jump7 jmpTarget: currentBlock.
	self CmpCq: 16 R: Extra1Reg.
	jump7 := self JumpBelow: 0.
	self LogicalShiftLeftCq: 3 R: Extra2Reg.
	self MoveR: Extra1Reg R: ClassReg.
	self AndCq: 7 R: ClassReg.
	self SubR: ClassReg R: Extra2Reg.
	self MoveR: Extra2Reg R: ClassReg.
	jump8 := self Jump: 0.
	currentBlock := self Label.
	jump7 jmpTarget: currentBlock.
	self CmpCq: 12 R: Extra1Reg.
	jump7 := self JumpBelow: 0.
	self LogicalShiftLeftCq: 2 R: Extra2Reg.
	self MoveR: Extra1Reg R: ClassReg.
	self AndCq: 3 R: ClassReg.
	self SubR: ClassReg R: Extra2Reg.
	self MoveR: Extra2Reg R: ClassReg.
	jump9 := self Jump: 0.
	currentBlock := self Label.
	jump7 jmpTarget: currentBlock.
	self CmpCq: 10 R: Extra1Reg.
	jump7 := self JumpBelow: 0.
	self LogicalShiftLeftCq: 1 R: Extra2Reg.
	self MoveR: Extra1Reg R: ClassReg.
	self AndCq: 1 R: ClassReg.
	self SubR: ClassReg R: Extra2Reg.
	jump10 := self Jump: 0.
	currentBlock := self Label.
	jump7 jmpTarget: currentBlock.
	self CmpCq: 9 R: Extra1Reg.
	jump7 := self JumpNonZero: 0.
	jump11 := self Jump: 0.
	currentBlock := self Label.
	jump7 jmpTarget: currentBlock.
	s63 := 0.
	self MoveCq: s63 R: Extra2Reg.
	currentBlock := self Label.
	jump6 jmpTarget: currentBlock.
	jump10 jmpTarget: currentBlock.
	jump11 jmpTarget: currentBlock.
	self CmpCq: 9 R: Extra1Reg.
	jump11 := self JumpBelow: 0.
	self MoveR: Extra2Reg R: ClassReg.
	currentBlock := self Label.
	jump9 jmpTarget: currentBlock.
	currentBlock := self Label.
	jump8 jmpTarget: currentBlock.
	jump8 := self Jump: 0.
	currentBlock := self Label.
	jump11 jmpTarget: currentBlock.
	self CmpCq: 2 R: Extra1Reg.
	jump11 := self JumpNonZero: 0.
	self MoveR: Extra2Reg R: ClassReg.
	currentBlock := self Label.
	jump8 jmpTarget: currentBlock.
	s81 := 0.
	self MoveCq: s81 R: SendNumArgsReg.
	jump8 := self Jump: 0.
	currentBlock := self Label.
	jump11 jmpTarget: currentBlock.
	self CmpCq: 2 R: Extra1Reg.
	jump11 := self JumpAboveOrEqual: 0.
	self MoveR: Extra2Reg R: SendNumArgsReg.
	self MoveR: Extra2Reg R: ClassReg.
	jump9 := self Jump: 0.
	currentBlock := self Label.
	jump11 jmpTarget: currentBlock.
	self MoveMw: 0 r: SPReg R: Extra3Reg.
	self MoveM64: 0 r: Extra3Reg R: ClassReg.
	self AndCq: 16r3FFFFF R: ClassReg.
	self CmpCq: 31 R: ClassReg.
	jump11 := self JumpAbove: 0.
	self CmpCq: 31 R: ClassReg.
	jump10 := self JumpNonZero: 0.
	self MoveMw: 0 r: SPReg R: Extra3Reg.
	self MoveR: Extra3Reg R: ClassReg.
	jump6 := self Jump: 0.
	currentBlock := self Label.
	jump10 jmpTarget: currentBlock.
	self CmpCq: 8 R: ClassReg.
	jump10 := self JumpNonZero: 0.
	self genMoveConstant: objectMemory nilObject R: ClassReg.
	jump7 := self Jump: 0.
	currentBlock := self Label.
	jump11 jmpTarget: currentBlock.
	jump10 jmpTarget: currentBlock.
	self MoveR: ClassReg R: SendNumArgsReg.
	self LogicalShiftRightCq: 10 R: SendNumArgsReg.
	s101 := objectMemory hiddenRootsObject.
	self LogicalShiftLeftCq: 3 R: SendNumArgsReg.
	self AddCq: s101 R: SendNumArgsReg.
	self MoveM64: 8 r: SendNumArgsReg R: SendNumArgsReg.
	self genMoveConstant: objectMemory nilObject R: Extra0Reg.
	self CmpR: Extra0Reg R: SendNumArgsReg.
	jump10 := self JumpNonZero: 0.
	self genMoveConstant: objectMemory nilObject R: Extra0Reg.
	jump11 := self Jump: 0.
	currentBlock := self Label.
	jump10 jmpTarget: currentBlock.
	self AndCq: 1023 R: ClassReg.
	self LogicalShiftLeftCq: 3 R: ClassReg.
	self AddR: ClassReg R: SendNumArgsReg.
	self MoveM64: 8 r: SendNumArgsReg R: Extra0Reg.
	currentBlock := self Label.
	jump11 jmpTarget: currentBlock.
	self MoveR: Extra0Reg R: ClassReg.
	currentBlock := self Label.
	jump6 jmpTarget: currentBlock.
	jump7 jmpTarget: currentBlock.
	self MoveM64: 24 r: ClassReg R: Extra0Reg.
	self ArithmeticShiftRightCq: 3 R: Extra0Reg.
	self AndCq: 16rFFFF R: Extra0Reg.
	self MoveR: Extra0Reg R: SendNumArgsReg.
	self MoveR: Extra2Reg R: ClassReg.
	currentBlock := self Label.
	jump8 jmpTarget: currentBlock.
	jump9 jmpTarget: currentBlock.
	self SubR: SendNumArgsReg R: ClassReg.
	self CmpCq: 24 R: Extra1Reg.
	jump9 := self JumpAboveOrEqual: 0.
	self MoveMw: 8 r: SPReg R: Extra3Reg.
	self CmpCq: 1 R: Extra3Reg.
	jump8 := self JumpBelow: 0.
	self MoveMw: 8 r: SPReg R: Extra3Reg.
	self CmpR: ClassReg R: Extra3Reg.
	jump7 := self JumpAbove: 0.
	self MoveMw: 8 r: SPReg R: Extra3Reg.
	self AddR: SendNumArgsReg R: Extra3Reg.
	self MoveR: Extra3Reg Mw: 8 r: SPReg.
	self CmpCq: 5 R: Extra1Reg.
	jump6 := self JumpAbove: 0.
	self MoveMw: 8 r: SPReg R: Extra3Reg.
	self SubCq: 1 R: Extra3Reg.
	self MoveR: Extra3Reg Mw: 8 r: SPReg.
	self MoveMw: 8 r: SPReg R: Extra3Reg.
	self LogicalShiftLeftCq: 3 R: Extra3Reg.
	self MoveR: Extra3Reg Mw: 8 r: SPReg.
	self MoveMw: 0 r: SPReg R: Extra3Reg.
	self MoveR: Extra3Reg R: Extra0Reg.
	self MoveMw: 8 r: SPReg R: Extra3Reg.
	self AddR: Extra3Reg R: Extra0Reg.
	self MoveMw: 16 r: SPReg R: Extra3Reg.
	self MoveR: Extra3Reg M64: 8 r: Extra0Reg.
	self MoveMw: 0 r: SPReg R: Extra3Reg.
	self MoveR: Extra3Reg R: Extra0Reg.
	self AndCq: 7 R: Extra0Reg.
	self CmpCq: 0 R: Extra0Reg.
	jump11 := self JumpNonZero: 0.
	s142 := objectMemory getMemoryMap getSpaceMaskToUse.
	self MoveMw: 0 r: SPReg R: Extra3Reg.
	self MoveR: Extra3Reg R: Extra0Reg.
	self AndCq: s142 R: Extra0Reg.
	s145 := objectMemory getMemoryMap getOldSpaceMask.
	self CmpCq: s145 R: Extra0Reg.
	jump10 := self JumpNonZero: 0.
	self MoveMw: 16 r: SPReg R: Extra3Reg.
	self MoveR: Extra3Reg R: Extra0Reg.
	self AndCq: 7 R: Extra0Reg.
	self CmpCq: 0 R: Extra0Reg.
	jump12 := self JumpNonZero: 0.
	s150 := objectMemory getMemoryMap getSpaceMaskToUse.
	self MoveMw: 16 r: SPReg R: Extra3Reg.
	self MoveR: Extra3Reg R: Extra0Reg.
	self AndCq: s150 R: Extra0Reg.
	s153 := objectMemory getMemoryMap getNewSpaceMask.
	self CmpCq: s153 R: Extra0Reg.
	jump13 := self JumpNonZero: 0.
	s155 := objectMemory getMemoryMap getNewSpaceStart.
	self MoveMw: 16 r: SPReg R: Extra3Reg.
	self MoveR: Extra3Reg R: Extra0Reg.
	self CmpCq: s155 R: Extra0Reg.
	jumpTrue := self JumpAboveOrEqual: 0.
	self MoveCq: 0 R: Extra0Reg.
	jumpNext := self Jump: 0.
	jumpTrue jmpTarget: self Label.
	self MoveCq: 1 R: Extra0Reg.
	jumpNext jmpTarget: self Label.
	self CmpCq: 1 R: Extra0Reg.
	jump14 := self JumpNonZero: 0.
	self MoveMw: 0 r: SPReg R: Extra3Reg.
	self MoveM64: 0 r: Extra3Reg R: Extra0Reg.
	self LogicalShiftRightCq: 29 R: Extra0Reg.
	self AndCq: 1 R: Extra0Reg.
	self CmpCq: 0 R: Extra0Reg.
	jump15 := self JumpNonZero: 0.
	self MoveMw: 0 r: SPReg R: Extra3Reg.
	self MoveR: Extra3Reg R: TempReg.
	backEnd saveAndRestoreLinkRegAround: [ self CallRT: ceStoreCheckTrampoline ].
	jump16 := self Jump: 0.
	currentBlock := self Label.
	jump13 jmpTarget: currentBlock.
	jump13 := self Jump: 0.
	currentBlock := self Label.
	jump6 jmpTarget: currentBlock.
	self CmpCq: 16 R: Extra1Reg.
	jump6 := self JumpBelow: 0.
	self MoveMw: 16 r: SPReg R: Extra3Reg.
	self TstCq: 1 R: Extra3Reg.
	jump17 := self JumpZero: 0.
	self MoveMw: 16 r: SPReg R: Extra3Reg.
	self MoveR: Extra3Reg R: Extra0Reg.
	self ArithmeticShiftRightCq: 3 R: Extra0Reg.
	self CmpCq: 0 R: Extra0Reg.
	jump18 := self JumpBelow: 0.
	self CmpCq: 255 R: Extra0Reg.
	jump19 := self JumpAbove: 0.
	self MoveMw: 8 r: SPReg R: Extra3Reg.
	self MoveMw: 0 r: SPReg R: Extra4Reg.
	self AddR: Extra4Reg R: Extra3Reg.
	self MoveR: Extra3Reg Mw: 8 r: SPReg.
	self MoveMw: 8 r: SPReg R: Extra3Reg.
	self AddCq:  -1 R: Extra3Reg.
	self MoveR: Extra3Reg Mw: 8 r: SPReg.
	self MoveMw: 8 r: SPReg R: Extra3Reg.
	self MoveR: Extra0Reg Mb: 8 r: Extra3Reg.
	jump20 := self Jump: 0.
	currentBlock := self Label.
	jump6 jmpTarget: currentBlock.
	self CmpCq: 12 R: Extra1Reg.
	jump6 := self JumpBelow: 0.
	self MoveMw: 16 r: SPReg R: Extra3Reg.
	self TstCq: 1 R: Extra3Reg.
	jump21 := self JumpZero: 0.
	self MoveMw: 16 r: SPReg R: Extra3Reg.
	self MoveR: Extra3Reg R: Extra0Reg.
	self ArithmeticShiftRightCq: 3 R: Extra0Reg.
	self CmpCq: 0 R: Extra0Reg.
	jump22 := self JumpBelow: 0.
	self CmpCq: 16rFFFF R: Extra0Reg.
	jump23 := self JumpAbove: 0.
	self MoveMw: 8 r: SPReg R: Extra3Reg.
	self SubCq: 1 R: Extra3Reg.
	self MoveR: Extra3Reg Mw: 8 r: SPReg.
	self MoveMw: 8 r: SPReg R: Extra3Reg.
	self LogicalShiftLeftCq: 1 R: Extra3Reg.
	self MoveR: Extra3Reg Mw: 8 r: SPReg.
	self MoveMw: 0 r: SPReg R: Extra3Reg.
	self MoveMw: 8 r: SPReg R: Extra4Reg.
	self AddR: Extra4Reg R: Extra3Reg.
	self MoveR: Extra3Reg Mw: 0 r: SPReg.
	self MoveMw: 0 r: SPReg R: Extra3Reg.
	self MoveR: Extra3Reg R: Extra2Reg.
	self AddCq: 8 R: Extra2Reg.
	self MoveR: Extra2Reg R: Extra1Reg.
	self AndCq: 2 R: Extra1Reg.
	self CmpCq: 0 R: Extra1Reg.
	jump24 := self JumpNonZero: 0.
	self MoveMw: 0 r: SPReg R: Extra3Reg.
	self MoveM32: 8 r: Extra3Reg R: Extra1Reg.
	self AndCq: 16rFFFFFFFF R: Extra1Reg.
	self AndCq: 16rFFFF0000 R: Extra1Reg.
	self OrR: Extra0Reg R: Extra1Reg.
	self MoveMw: 0 r: SPReg R: Extra3Reg.
	self MoveR: Extra1Reg M32: 8 r: Extra3Reg.
	jump25 := self Jump: 0.
	currentBlock := self Label.
	jump24 jmpTarget: currentBlock.
	self MoveM32: -2 r: Extra2Reg R: Extra1Reg.
	self AndCq: 16rFFFFFFFF R: Extra1Reg.
	self AndCq: 16rFFFF R: Extra1Reg.
	self LogicalShiftLeftCq: 16 R: Extra0Reg.
	self OrR: Extra0Reg R: Extra1Reg.
	self MoveR: Extra1Reg M32: -2 r: Extra2Reg.
	currentBlock := self Label.
	jump11 jmpTarget: currentBlock.
	jump10 jmpTarget: currentBlock.
	jump12 jmpTarget: currentBlock.
	jump14 jmpTarget: currentBlock.
	jump15 jmpTarget: currentBlock.
	jump16 jmpTarget: currentBlock.
	jump13 jmpTarget: currentBlock.
	jump20 jmpTarget: currentBlock.
	jump25 jmpTarget: currentBlock.
	self MoveMw: 16 r: SPReg R: Extra3Reg.
	self MoveR: Extra3Reg R: ReceiverResultReg.
	self AddCq: 24 R: SPReg.
	self genPrimReturn.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	jump2 jmpTarget: currentBlock.
	jump3 jmpTarget: currentBlock.
	jump4 jmpTarget: currentBlock.
	jump5 jmpTarget: currentBlock.
	jump9 jmpTarget: currentBlock.
	jump8 jmpTarget: currentBlock.
	jump7 jmpTarget: currentBlock.
	jump17 jmpTarget: currentBlock.
	jump18 jmpTarget: currentBlock.
	jump19 jmpTarget: currentBlock.
	jump6 jmpTarget: currentBlock.
	jump21 jmpTarget: currentBlock.
	jump22 jmpTarget: currentBlock.
	jump23 jmpTarget: currentBlock.
	self AddCq: 24 R: SPReg.
	^ 0
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveAtPut_fixed [
	"AutoGenerated by Druid"

	| s129 jump6 jump10 jump7 jump11 s119 jump8 s158 jump12 jump9 s233 jump13 jump14 s209 s170 jump15 jumpTrue jump16 s224 s62 s124 s176 s179 jump1 jump2 s152 s127 jump3 s140 jump4 s154 currentBlock s116 jump5 s80 jumpNext s55 |
	self SubCq: 24 R: SPReg.

	self MoveR: ReceiverResultReg R: Extra3Reg.
	self MoveR: Extra3Reg Mw: 0 r: SPReg.
	self MoveR: Arg0Reg R: Extra3Reg.
	self MoveR: Extra3Reg Mw: 8 r: SPReg.
	self MoveR: Arg1Reg R: Extra3Reg.
	self MoveR: Extra3Reg Mw: 16 r: SPReg.

	self MoveMw: 0 r: SPReg R: Extra3Reg.
	self TstCq: 7 R: Extra3Reg.
	jump1 := self JumpNonZero: 0.
	self MoveMw: 8 r: SPReg R: Extra3Reg.
	self MoveR: Extra3Reg R: Extra1Reg.
	self AndCq: 1 R: Extra1Reg.
	self CmpCq: 0 R: Extra1Reg.
	jump2 := self JumpNonZero: 0.
	self CmpCq: 0 R: Extra1Reg.
	jump3 := self JumpZero: 0.
	currentBlock := self Label.
	jump2 jmpTarget: currentBlock.
	self MoveMw: 8 r: SPReg R: Extra3Reg.
	self ArithmeticShiftRightCq: 3 R: Extra3Reg.
	self MoveR: Extra3Reg Mw: 8 r: SPReg.
	self MoveMw: 0 r: SPReg R: Extra3Reg.
	self MoveM64: 0 r: Extra3Reg R: Extra1Reg.
	self MoveR: Extra1Reg R: Extra2Reg.
	self AndCq: 16r3FFFFF R: Extra2Reg.
	self CmpCq: 36 R: Extra2Reg.
	jump2 := self JumpZero: 0.
	self LogicalShiftRightCq: 24 R: Extra1Reg.
	self AndCq: 31 R: Extra1Reg.
	self MoveMw: 0 r: SPReg R: Extra3Reg.
	self MoveMb: 7 r: Extra3Reg R: Extra2Reg.
	self AndCq: 255 R: Extra2Reg.
	self CmpCq: 255 R: Extra2Reg.
	jump4 := self JumpNonZero: 0.
	self MoveMw: 0 r: SPReg R: Extra3Reg.
	self MoveM64: -8 r: Extra3Reg R: Extra2Reg.
	self LogicalShiftLeftCq: 8 R: Extra2Reg.
	self LogicalShiftRightCq: 8 R: Extra2Reg.
	jump5 := self Jump: 0.
	currentBlock := self Label.
	jump4 jmpTarget: currentBlock.
	currentBlock := self Label.
	jump5 jmpTarget: currentBlock.
	self CmpCq: 5 R: Extra1Reg.
	jump5 := self JumpAbove: 0.
	jump4 := self Jump: 0.
	currentBlock := self Label.
	jump5 jmpTarget: currentBlock.
	self CmpCq: 16 R: Extra1Reg.
	jump5 := self JumpBelow: 0.
	self LogicalShiftLeftCq: 3 R: Extra2Reg.
	self MoveR: Extra1Reg R: ClassReg.
	self AndCq: 7 R: ClassReg.
	self SubR: ClassReg R: Extra2Reg.
	jump6 := self Jump: 0.
	currentBlock := self Label.
	jump5 jmpTarget: currentBlock.
	self CmpCq: 12 R: Extra1Reg.
	jump5 := self JumpBelow: 0.
	self LogicalShiftLeftCq: 2 R: Extra2Reg.
	self MoveR: Extra1Reg R: ClassReg.
	self AndCq: 3 R: ClassReg.
	self SubR: ClassReg R: Extra2Reg.
	jump7 := self Jump: 0.
	currentBlock := self Label.
	jump5 jmpTarget: currentBlock.
	self CmpCq: 10 R: Extra1Reg.
	jump5 := self JumpBelow: 0.
	self LogicalShiftLeftCq: 1 R: Extra2Reg.
	self MoveR: Extra1Reg R: ClassReg.
	self AndCq: 1 R: ClassReg.
	self SubR: ClassReg R: Extra2Reg.
	jump8 := self Jump: 0.
	currentBlock := self Label.
	jump5 jmpTarget: currentBlock.
	self CmpCq: 9 R: Extra1Reg.
	jump5 := self JumpNonZero: 0.
	jump9 := self Jump: 0.
	currentBlock := self Label.
	jump5 jmpTarget: currentBlock.
	s55 := 0.
	self MoveCq: s55 R: Extra2Reg.
	currentBlock := self Label.
	jump4 jmpTarget: currentBlock.
	jump6 jmpTarget: currentBlock.
	jump7 jmpTarget: currentBlock.
	jump8 jmpTarget: currentBlock.
	jump9 jmpTarget: currentBlock.
	self CmpCq: 9 R: Extra1Reg.
	jump9 := self JumpBelow: 0.
	self CmpCq: 9 R: Extra1Reg.
	jump8 := self JumpAboveOrEqual: 0.
	jump7 := self JumpBelow: 0.
	currentBlock := self Label.
	jump9 jmpTarget: currentBlock.
	self CmpCq: 2 R: Extra1Reg.
	jump9 := self JumpNonZero: 0.
	currentBlock := self Label.
	jump8 jmpTarget: currentBlock.
	s62 := 0.
	self MoveCq: s62 R: ClassReg.
	jump8 := self Jump: 0.
	currentBlock := self Label.
	jump7 jmpTarget: currentBlock.
	jump9 jmpTarget: currentBlock.
	self CmpCq: 2 R: Extra1Reg.
	jump9 := self JumpAboveOrEqual: 0.
	self MoveR: Extra2Reg R: ClassReg.
	jump7 := self Jump: 0.
	currentBlock := self Label.
	jump9 jmpTarget: currentBlock.
	self MoveMw: 0 r: SPReg R: Extra3Reg.
	self MoveM64: 0 r: Extra3Reg R: ClassReg.
	self AndCq: 16r3FFFFF R: ClassReg.
	self CmpCq: 31 R: ClassReg.
	jump9 := self JumpAbove: 0.
	self CmpCq: 31 R: ClassReg.
	jump6 := self JumpNonZero: 0.
	self MoveMw: 0 r: SPReg R: Extra3Reg.
	self MoveR: Extra3Reg R: ClassReg.
	jump4 := self Jump: 0.
	currentBlock := self Label.
	jump6 jmpTarget: currentBlock.
	self CmpCq: 8 R: ClassReg.
	jump6 := self JumpNonZero: 0.
	self genMoveConstant: objectMemory nilObject R: ClassReg.
	jump5 := self Jump: 0.
	currentBlock := self Label.
	jump9 jmpTarget: currentBlock.
	jump6 jmpTarget: currentBlock.
	self MoveR: ClassReg R: SendNumArgsReg.
	self LogicalShiftRightCq: 10 R: SendNumArgsReg.
	s80 := objectMemory hiddenRootsObject.
	self LogicalShiftLeftCq: 3 R: SendNumArgsReg.
	self AddCq: s80 R: SendNumArgsReg.
	self MoveM64: 8 r: SendNumArgsReg R: SendNumArgsReg.
	self genMoveConstant: objectMemory nilObject R: Extra0Reg.
	self CmpR: Extra0Reg R: SendNumArgsReg.
	jump6 := self JumpNonZero: 0.
	self genMoveConstant: objectMemory nilObject R: Extra0Reg.
	jump9 := self Jump: 0.
	currentBlock := self Label.
	jump6 jmpTarget: currentBlock.
	self AndCq: 1023 R: ClassReg.
	self LogicalShiftLeftCq: 3 R: ClassReg.
	self AddR: ClassReg R: SendNumArgsReg.
	self MoveM64: 8 r: SendNumArgsReg R: Extra0Reg.
	currentBlock := self Label.
	jump9 jmpTarget: currentBlock.
	self MoveR: Extra0Reg R: ClassReg.
	currentBlock := self Label.
	jump4 jmpTarget: currentBlock.
	jump5 jmpTarget: currentBlock.
	self MoveM64: 24 r: ClassReg R: Extra0Reg.
	self ArithmeticShiftRightCq: 3 R: Extra0Reg.
	self AndCq: 16rFFFF R: Extra0Reg.
	self MoveR: Extra0Reg R: ClassReg.
	currentBlock := self Label.
	jump8 jmpTarget: currentBlock.
	jump7 jmpTarget: currentBlock.
	self SubR: ClassReg R: Extra2Reg.
	self CmpCq: 24 R: Extra1Reg.
	jump7 := self JumpAboveOrEqual: 0.
	self MoveMw: 8 r: SPReg R: Extra3Reg.
	self CmpCq: 1 R: Extra3Reg.
	jump8 := self JumpBelow: 0.
	self MoveMw: 8 r: SPReg R: Extra3Reg.
	self CmpR: Extra2Reg R: Extra3Reg.
	jump5 := self JumpAbove: 0.
	self MoveMw: 8 r: SPReg R: Extra3Reg.
	self AddR: ClassReg R: Extra3Reg.
	self MoveR: Extra3Reg Mw: 8 r: SPReg.
	self CmpCq: 5 R: Extra1Reg.
	jump4 := self JumpAbove: 0.
	self MoveMw: 8 r: SPReg R: Extra3Reg.
	self SubCq: 1 R: Extra3Reg.
	self MoveR: Extra3Reg Mw: 8 r: SPReg.
	self MoveMw: 0 r: SPReg R: Extra3Reg.
	self MoveR: Extra3Reg R: Extra0Reg.
	self AndCq: 7 R: Extra0Reg.
	self CmpCq: 0 R: Extra0Reg.
	jump9 := self JumpNonZero: 0.
	s116 := objectMemory getMemoryMap getSpaceMaskToUse.
	self MoveMw: 0 r: SPReg R: Extra3Reg.
	self MoveR: Extra3Reg R: Extra0Reg.
	self AndCq: s116 R: Extra0Reg.
	s119 := objectMemory getMemoryMap getOldSpaceMask.
	self CmpCq: s119 R: Extra0Reg.
	jump6 := self JumpNonZero: 0.
	self MoveMw: 16 r: SPReg R: Extra3Reg.
	self MoveR: Extra3Reg R: Extra0Reg.
	self AndCq: 7 R: Extra0Reg.
	self CmpCq: 0 R: Extra0Reg.
	jump10 := self JumpNonZero: 0.
	s124 := objectMemory getMemoryMap getSpaceMaskToUse.
	self MoveMw: 16 r: SPReg R: Extra3Reg.
	self MoveR: Extra3Reg R: Extra0Reg.
	self AndCq: s124 R: Extra0Reg.
	s127 := objectMemory getMemoryMap getNewSpaceMask.
	self CmpCq: s127 R: Extra0Reg.
	jump11 := self JumpNonZero: 0.
	s129 := objectMemory getMemoryMap getNewSpaceStart.
	self MoveMw: 16 r: SPReg R: Extra3Reg.
	self MoveR: Extra3Reg R: Extra0Reg.
	self CmpCq: s129 R: Extra0Reg.
	jumpTrue := self JumpAboveOrEqual: 0.
	self MoveCq: 0 R: Extra0Reg.
	jumpNext := self Jump: 0.
	jumpTrue jmpTarget: self Label.
	self MoveCq: 1 R: Extra0Reg.
	jumpNext jmpTarget: self Label.
	self CmpCq: 1 R: Extra0Reg.
	jump12 := self JumpNonZero: 0.
	self MoveMw: 0 r: SPReg R: Extra3Reg.
	self MoveM64: 0 r: Extra3Reg R: Extra0Reg.
	self LogicalShiftRightCq: 29 R: Extra0Reg.
	self AndCq: 1 R: Extra0Reg.
	self CmpCq: 0 R: Extra0Reg.
	jump13 := self JumpNonZero: 0.
	self MoveMw: 0 r: SPReg R: Extra3Reg.
	self MoveR: Extra3Reg R: TempReg.
	backEnd saveAndRestoreLinkRegAround: [
		self CallRT: ceStoreCheckTrampoline ].
	jump14 := self Jump: 0.
	currentBlock := self Label.
	jump11 jmpTarget: currentBlock.
	s140 := 0.
	currentBlock := self Label.
	jump9 jmpTarget: currentBlock.
	jump6 jmpTarget: currentBlock.
	jump10 jmpTarget: currentBlock.
	jump12 jmpTarget: currentBlock.
	jump13 jmpTarget: currentBlock.
	jump14 jmpTarget: currentBlock.
	self MoveMw: 0 r: SPReg R: Extra3Reg.
	self MoveM64: 0 r: Extra3Reg R: Extra0Reg.
	self LogicalShiftRightCq: 29 R: Extra0Reg.
	self AndCq: 1 R: Extra0Reg.
	self CmpCq: 0 R: Extra0Reg.
	jump14 := self JumpNonZero: 0.
	self MoveMw: 16 r: SPReg R: Extra3Reg.
	self TstCq: 7 R: Extra3Reg.
	jump13 := self JumpNonZero: 0.
	self MoveMw: 0 r: SPReg R: Extra3Reg.
	self CmpCq: 16r20000000000 R: Extra3Reg.
	jump12 := self JumpBelow: 0.
	self MoveMw: 16 r: SPReg R: Extra3Reg.
	self CmpCq: 16r20000000000 R: Extra3Reg.
	jump10 := self JumpAboveOrEqual: 0.
	self genMoveConstant: objectMemory nilObject R: Extra0Reg.
	self MoveMw: 16 r: SPReg R: Extra3Reg.
	self CmpR: Extra0Reg R: Extra3Reg.
	jump6 := self JumpBelow: 0.
	s152 := objectMemory trueObject.
	self MoveMw: 16 r: SPReg R: Extra3Reg.
	self CmpCq: s152 R: Extra3Reg.
	jump9 := self JumpBelowOrEqual: 0.
	currentBlock := self Label.
	jump6 jmpTarget: currentBlock.
	s154 := objectMemory getMemoryMap getNewSpaceStart.
	self MoveMw: 16 r: SPReg R: Extra3Reg.
	self CmpCq: s154 R: Extra3Reg.
	jump6 := self JumpBelow: 0.
	self MoveMw: 0 r: SPReg R: Extra3Reg.
	self MoveR: Extra3Reg R: TempReg.
	backEnd saveAndRestoreLinkRegAround: [
		self CallRT: ceStoreCheckTrampoline ].
	currentBlock := self Label.
	jump14 jmpTarget: currentBlock.
	jump13 jmpTarget: currentBlock.
	jump12 jmpTarget: currentBlock.
	jump10 jmpTarget: currentBlock.
	jump9 jmpTarget: currentBlock.
	jump6 jmpTarget: currentBlock.

	s158 := 0.
	"GET INDEX"
	self MoveMw: 8 r: SPReg R: Extra3Reg.
	self LogicalShiftLeftCq: 3 R: Extra3Reg.
	self MoveR: Extra3Reg Mw: 8 r: SPReg.

	self MoveMw: 0 r: SPReg R: Extra3Reg.
	self MoveMw: 8 r: SPReg R: Extra4Reg.
	self AddR: Extra4Reg R: Extra3Reg.
	self MoveR: Extra3Reg Mw: 0 r: SPReg.

	self MoveMw: 16 r: SPReg R: Extra3Reg.
	self MoveMw: 0 r: SPReg R: Extra4Reg.
	self MoveR: Extra3Reg M64: 8 r: Extra4Reg.
	
	
	
	self MoveCq: s158 R: Extra0Reg.
	jump6 := self Jump: 0.
	currentBlock := self Label.
	jump4 jmpTarget: currentBlock.
	self CmpCq: 16 R: Extra1Reg.
	jump4 := self JumpBelow: 0.
	self MoveMw: 16 r: SPReg R: Extra3Reg.
	self TstCq: 1 R: Extra3Reg.
	jump9 := self JumpZero: 0.
	self MoveMw: 16 r: SPReg R: Extra3Reg.
	self MoveR: Extra3Reg R: Extra0Reg.
	self ArithmeticShiftRightCq: 3 R: Extra0Reg.
	self CmpCq: 0 R: Extra0Reg.
	jump10 := self JumpBelow: 0.
	self CmpCq: 255 R: Extra0Reg.
	jump12 := self JumpAbove: 0.
	s170 := 0.
	self MoveMw: 8 r: SPReg R: Extra3Reg.
	self MoveMw: 0 r: SPReg R: Extra4Reg.
	self AddR: Extra4Reg R: Extra3Reg.
	self MoveR: Extra3Reg Mw: 8 r: SPReg.
	self MoveMw: 8 r: SPReg R: Extra3Reg.
	self AddCq:  -1 R: Extra3Reg.
	self MoveR: Extra3Reg Mw: 8 r: SPReg.
	self MoveMw: 8 r: SPReg R: Extra3Reg.
	self MoveR: Extra0Reg Mb: 8 r: Extra3Reg.
	self MoveCq: s170 R: Extra0Reg.
	jump13 := self Jump: 0.
	currentBlock := self Label.
	jump10 jmpTarget: currentBlock.
	jump12 jmpTarget: currentBlock.
	s176 := 3.
	self MoveCq: s176 R: Extra0Reg.
	jump12 := self Jump: 0.
	currentBlock := self Label.
	jump9 jmpTarget: currentBlock.
	s179 := 3.
	self MoveCq: 3 R: Extra0Reg.
	jump9 := self Jump: 0.
	currentBlock := self Label.
	jump4 jmpTarget: currentBlock.
	self CmpCq: 12 R: Extra1Reg.
	jump4 := self JumpBelow: 0.
	self MoveMw: 16 r: SPReg R: Extra3Reg.
	self TstCq: 1 R: Extra3Reg.
	jump10 := self JumpZero: 0.
	self MoveMw: 16 r: SPReg R: Extra3Reg.
	self MoveR: Extra3Reg R: Extra0Reg.
	self ArithmeticShiftRightCq: 3 R: Extra0Reg.
	self CmpCq: 0 R: Extra0Reg.
	jump14 := self JumpBelow: 0.
	self CmpCq: 16rFFFF R: Extra0Reg.
	jump11 := self JumpAbove: 0.
	self MoveMw: 8 r: SPReg R: Extra3Reg.
	self SubCq: 1 R: Extra3Reg.
	self MoveR: Extra3Reg Mw: 8 r: SPReg.
	self MoveMw: 8 r: SPReg R: Extra3Reg.
	self LogicalShiftLeftCq: 1 R: Extra3Reg.
	self MoveR: Extra3Reg Mw: 8 r: SPReg.
	self MoveMw: 0 r: SPReg R: Extra3Reg.
	self MoveMw: 8 r: SPReg R: Extra4Reg.
	self AddR: Extra4Reg R: Extra3Reg.
	self MoveR: Extra3Reg Mw: 0 r: SPReg.
	self MoveMw: 0 r: SPReg R: Extra3Reg.
	self MoveR: Extra3Reg R: Extra2Reg.
	self AddCq: 8 R: Extra2Reg.
	self MoveR: Extra2Reg R: Extra1Reg.
	self AndCq: 2 R: Extra1Reg.
	self CmpCq: 0 R: Extra1Reg.
	jump15 := self JumpNonZero: 0.
	self MoveMw: 0 r: SPReg R: Extra3Reg.
	self MoveM32: 8 r: Extra3Reg R: Extra1Reg.
	self AndCq: 16rFFFFFFFF R: Extra1Reg.
	self AndCq: 16rFFFF0000 R: Extra1Reg.
	self OrR: Extra0Reg R: Extra1Reg.
	self MoveMw: 0 r: SPReg R: Extra3Reg.
	self MoveR: Extra1Reg M32: 8 r: Extra3Reg.
	jump16 := self Jump: 0.
	currentBlock := self Label.
	jump15 jmpTarget: currentBlock.
	self MoveM32: -2 r: Extra2Reg R: Extra1Reg.
	self AndCq: 16rFFFFFFFF R: Extra1Reg.
	self AndCq: 16rFFFF R: Extra1Reg.
	self LogicalShiftLeftCq: 16 R: Extra0Reg.
	self OrR: Extra0Reg R: Extra1Reg.
	self MoveR: Extra1Reg M32: -2 r: Extra2Reg.
	currentBlock := self Label.
	jump16 jmpTarget: currentBlock.
	s209 := 0.
	self MoveCq: s209 R: Extra0Reg.
	currentBlock := self Label.
	jump6 jmpTarget: currentBlock.
	jump13 jmpTarget: currentBlock.
	jump12 jmpTarget: currentBlock.
	currentBlock := self Label.
	jump9 jmpTarget: currentBlock.
	self CmpCq: 0 R: Extra0Reg.
	jump9 := self JumpNonZero: 0.
	self MoveR: Extra0Reg R: Extra1Reg.

	self MoveMw: 16 r: SPReg R: Extra2Reg.

	self MoveR: Extra2Reg R: ReceiverResultReg.
	self CmpCq: 0 R: Extra1Reg.
	jump12 := self JumpZero: 0.
	jump13 := self JumpNonZero: 0.
	currentBlock := self Label.
	jump9 jmpTarget: currentBlock.
	self MoveR: Extra0Reg R: Extra2Reg.
	jump9 := self Jump: 0.
	currentBlock := self Label.
	jump14 jmpTarget: currentBlock.
	jump11 jmpTarget: currentBlock.
	s224 := 3.
	self MoveCq: s224 R: Extra2Reg.
	currentBlock := self Label.
	jump9 jmpTarget: currentBlock.
	self MoveMw: 16 r: SPReg R: Extra3Reg.
	self MoveR: Extra3Reg R: ReceiverResultReg.
	self CmpCq: 0 R: Extra2Reg.
	jump9 := self JumpNonZero: 0.
	currentBlock := self Label.
	jump12 jmpTarget: currentBlock.
	self AddCq: 24 R: SPReg.
	self genPrimReturn.
	currentBlock := self Label.
	jump10 jmpTarget: currentBlock.
	s233 := 3.
	self MoveMw: 16 r: SPReg R: Extra3Reg.
	self MoveR: Extra3Reg R: ReceiverResultReg.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	jump3 jmpTarget: currentBlock.
	jump2 jmpTarget: currentBlock.
	jump7 jmpTarget: currentBlock.
	jump8 jmpTarget: currentBlock.
	jump5 jmpTarget: currentBlock.
	jump4 jmpTarget: currentBlock.
	jump13 jmpTarget: currentBlock.
	jump9 jmpTarget: currentBlock.
	self AddCq: 24 R: SPReg.
	^ 0
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveBitAnd [
	"AutoGenerated by Druid"

	| jump1 currentBlock |
	self MoveR: ReceiverResultReg R: ClassReg.
	self MoveR: Arg0Reg R: SendNumArgsReg.
	self MoveR: SendNumArgsReg R: Extra0Reg.
	self AndR: ClassReg R: Extra0Reg.
	self TstCq: 1 R: Extra0Reg.
	jump1 := self JumpZero: 0.
	self AndR: ClassReg R: SendNumArgsReg.
	self MoveR: SendNumArgsReg R: ReceiverResultReg.
	self genPrimReturn.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	^ 0
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveBitShift [
	"AutoGenerated by Druid"

	| jump1 jump2 currentBlock |
	self MoveR: ReceiverResultReg R: ClassReg.
	self MoveR: Arg0Reg R: SendNumArgsReg.
	self CmpCq: 0 R: SendNumArgsReg.
	jump1 := self JumpLessOrEqual: 0.
	self LogicalShiftLeftR: SendNumArgsReg R: ClassReg.
	self MoveR: ClassReg R: SendNumArgsReg.
	jump2 := self Jump: 0.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	self MoveR: SendNumArgsReg R: SendNumArgsReg.
	self NegateR: SendNumArgsReg.
	self LogicalShiftRightR: SendNumArgsReg R: ClassReg.
	self MoveR: ClassReg R: SendNumArgsReg.
	currentBlock := self Label.
	jump2 jmpTarget: currentBlock.
	self MoveR: SendNumArgsReg R: ReceiverResultReg.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveBitXor [
	"AutoGenerated by Druid"

	| currentBlock |
	self MoveR: ReceiverResultReg R: ClassReg.
	self MoveR: Arg0Reg R: SendNumArgsReg.
	self XorR: ClassReg R: SendNumArgsReg.
	self MoveR: SendNumArgsReg R: ReceiverResultReg.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveBranchingWithAssigments [
	"AutoGenerated by Druid"

	| jump1 currentBlock s7 jump2 s3 |
	self MoveR: ReceiverResultReg R: ClassReg.
	s3 := 17.
	self CmpCq: 0 R: ClassReg.
	jump1 := self JumpLessOrEqual: 0.
	self MoveCq: s3 R: ClassReg.
	jump2 := self Jump: 0.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	s7 := 42.
	self MoveCq: s7 R: ClassReg.
	currentBlock := self Label.
	jump2 jmpTarget: currentBlock.
	self MoveR: ClassReg R: ReceiverResultReg.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveByteAt [

	| currentBlock |
	self MoveCq: 0 R: TempReg.
	self MoveMb: 0 r: ReceiverResultReg R: TempReg.
	self MoveR: TempReg R: ReceiverResultReg.
	self RetN: 1 * objectMemory wordSize.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveCallingBlockReadingExternalTemp [
	"AutoGenerated by Druid"

	| currentBlock |
	self MoveCq: 17 R: ReceiverResultReg.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveCallingBlockReturningArgument [
	"AutoGenerated by Druid"

	| currentBlock |
	self MoveCq: 17 R: ReceiverResultReg.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveCallingBlockReturningConstant [
	"AutoGenerated by Druid"

	| currentBlock |
	self MoveCq: 17 R: ReceiverResultReg.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveCallingBlockWithNonLocalReturn [
	"AutoGenerated by Druid"

	| currentBlock |
	self MoveCq: 17 R: ReceiverResultReg.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveCallingBlockWritingExternalTemp [
	"AutoGenerated by Druid"

	| currentBlock |
	self MoveCq: 17 R: ReceiverResultReg.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveCallingEmptyBlock [
	"AutoGenerated by Druid"

	| currentBlock |
	self MoveCq: 18 R: ReceiverResultReg.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveCallingMethodReturningConstant [
	"AutoGenerated by Druid"

	| currentBlock |
	self MoveCq: 73 R: ReceiverResultReg.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveCallingMethodWithEarlyReturn [
	"AutoGenerated by Druid"

	| jump1 s4 currentBlock s7 jump2 |
	self MoveR: ReceiverResultReg R: ClassReg.
	self CmpCq: 0 R: ClassReg.
	jump1 := self JumpNonZero: 0.
	s4 := 42.
	self MoveCq: s4 R: ClassReg.
	jump2 := self Jump: 0.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	s7 := 57.
	self MoveCq: s7 R: ClassReg.
	currentBlock := self Label.
	jump2 jmpTarget: currentBlock.
	self MoveR: ClassReg R: ReceiverResultReg.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveCascadedUint16AtPut [
	"AutoGenerated by Druid"

	| s6 currentBlock s3 |
	self MoveR: ReceiverResultReg R: ClassReg.
	s3 := 1.
	self MoveCq: s3 R: SendNumArgsReg.
	self MoveR: SendNumArgsReg M64: 0 r: ClassReg.
	s6 := 2.
	self MoveCq: s6 R: SendNumArgsReg.
	self MoveR: SendNumArgsReg M16: 2 r: ClassReg.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveCaseOfOtherwiseValue [
	"AutoGenerated by Druid"

	| s11 s8 jump1 s4 jump3 currentBlock jump2 |
	self MoveR: ReceiverResultReg R: ClassReg.
	self CmpCq: 0 R: ClassReg.
	jump1 := self JumpNonZero: 0.
	s4 := 57.
	self MoveCq: s4 R: ClassReg.
	jump2 := self Jump: 0.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	self CmpCq: 1 R: ClassReg.
	jump1 := self JumpNonZero: 0.
	s8 := 42.
	self MoveCq: s8 R: ClassReg.
	jump3 := self Jump: 0.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	s11 := 77.
	self MoveCq: s11 R: ClassReg.
	currentBlock := self Label.
	jump2 jmpTarget: currentBlock.
	jump3 jmpTarget: currentBlock.
	self MoveR: ClassReg R: ReceiverResultReg.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveClass [
	"AutoGenerated by Druid"

	| s57 s32 s87 s2 s56 currentBlock s3 |
	s2 := self methodNumArgs.
	s2 = 0 ifTrue: [
		| jump5 jump3 jump1 jump6 jump4 jump2 |
		self MoveR: ReceiverResultReg R: ClassReg.
		self MoveR: ClassReg R: SendNumArgsReg.
		self AndCq: 7 R: SendNumArgsReg.
		self CmpCq: 0 R: SendNumArgsReg.
		jump1 := self JumpNonZero: 0.
		self MoveM64: 0 r: ClassReg R: SendNumArgsReg.
		self AndCq: 16r3FFFF7 R: SendNumArgsReg.
		self CmpCq: 0 R: SendNumArgsReg.
		jump2 := self JumpZero: 0.
		currentBlock := self Label.
		jump1 jmpTarget: currentBlock.
		self MoveR: ClassReg R: SendNumArgsReg.
		self AndCq: 7 R: SendNumArgsReg.
		self CmpCq: 0 R: SendNumArgsReg.
		jump1 := self JumpZero: 0.
		self MoveAw: objectMemory hiddenRootsObject + 8 R: ClassReg.
		self LogicalShiftLeftCq: 3 R: SendNumArgsReg.
		self AddR: SendNumArgsReg R: ClassReg.
		self MoveM64: 8 r: ClassReg R: ClassReg.
		jump3 := self Jump: 0.
		currentBlock := self Label.
		jump1 jmpTarget: currentBlock.
		self MoveM64: 0 r: ClassReg R: SendNumArgsReg.
		self AndCq: 16r3FFFFF R: SendNumArgsReg.
		self CmpCq: 31 R: SendNumArgsReg.
		jump1 := self JumpAbove: 0.
		self CmpCq: 31 R: SendNumArgsReg.
		jump4 := self JumpNonZero: 0.
		self MoveR: ClassReg R: SendNumArgsReg.
		jump5 := self Jump: 0.
		currentBlock := self Label.
		jump4 jmpTarget: currentBlock.
		self CmpCq: 8 R: SendNumArgsReg.
		jump4 := self JumpNonZero: 0.
		self genMoveConstant: objectMemory nilObject R: SendNumArgsReg.
		jump6 := self Jump: 0.
		currentBlock := self Label.
		jump1 jmpTarget: currentBlock.
		jump4 jmpTarget: currentBlock.
		self MoveR: SendNumArgsReg R: ClassReg.
		self LogicalShiftRightCq: 10 R: ClassReg.
		s32 := objectMemory hiddenRootsObject.
		self LogicalShiftLeftCq: 3 R: ClassReg.
		self AddCq: s32 R: ClassReg.
		self MoveM64: 8 r: ClassReg R: ClassReg.
		self genMoveConstant: objectMemory nilObject R: Extra0Reg.
		self CmpR: Extra0Reg R: ClassReg.
		jump4 := self JumpNonZero: 0.
		self genMoveConstant: objectMemory nilObject R: Extra0Reg.
		jump1 := self Jump: 0.
		currentBlock := self Label.
		jump4 jmpTarget: currentBlock.
		self AndCq: 1023 R: SendNumArgsReg.
		self LogicalShiftLeftCq: 3 R: SendNumArgsReg.
		self AddR: SendNumArgsReg R: ClassReg.
		self MoveM64: 8 r: ClassReg R: Extra0Reg.
		currentBlock := self Label.
		jump1 jmpTarget: currentBlock.
		self MoveR: Extra0Reg R: SendNumArgsReg.
		currentBlock := self Label.
		jump5 jmpTarget: currentBlock.
		jump6 jmpTarget: currentBlock.
		self MoveR: SendNumArgsReg R: ClassReg.
		currentBlock := self Label.
		jump3 jmpTarget: currentBlock.
		self MoveR: ClassReg R: ReceiverResultReg.
		self genPrimReturn.
		currentBlock := self Label.
		jump2 jmpTarget: currentBlock.
		^ 0 ].
	s56 := self methodNumArgs.
	s56 = 1 ifTrue: [
		| jump5 jump3 jump1 jump6 jump4 jump2 |
		self MoveR: Arg0Reg R: Extra0Reg.
		self MoveR: Extra0Reg R: ClassReg.
		self AndCq: 7 R: ClassReg.
		self CmpCq: 0 R: ClassReg.
		jump2 := self JumpNonZero: 0.
		self MoveM64: 0 r: Extra0Reg R: ClassReg.
		self AndCq: 16r3FFFF7 R: ClassReg.
		self CmpCq: 0 R: ClassReg.
		jump3 := self JumpZero: 0.
		currentBlock := self Label.
		jump2 jmpTarget: currentBlock.
		self MoveR: Extra0Reg R: ClassReg.
		self AndCq: 7 R: ClassReg.
		self CmpCq: 0 R: ClassReg.
		jump2 := self JumpZero: 0.
		self MoveAw: objectMemory hiddenRootsObject + 8 R: Extra0Reg.
		self LogicalShiftLeftCq: 3 R: ClassReg.
		self AddR: ClassReg R: Extra0Reg.
		self MoveM64: 8 r: Extra0Reg R: Extra0Reg.
		jump6 := self Jump: 0.
		currentBlock := self Label.
		jump2 jmpTarget: currentBlock.
		self MoveM64: 0 r: Extra0Reg R: ClassReg.
		self AndCq: 16r3FFFFF R: ClassReg.
		self CmpCq: 31 R: ClassReg.
		jump2 := self JumpAbove: 0.
		self CmpCq: 31 R: ClassReg.
		jump5 := self JumpNonZero: 0.
		self MoveR: Extra0Reg R: ClassReg.
		jump1 := self Jump: 0.
		currentBlock := self Label.
		jump5 jmpTarget: currentBlock.
		self CmpCq: 8 R: ClassReg.
		jump5 := self JumpNonZero: 0.
		self genMoveConstant: objectMemory nilObject R: ClassReg.
		jump4 := self Jump: 0.
		currentBlock := self Label.
		jump2 jmpTarget: currentBlock.
		jump5 jmpTarget: currentBlock.
		self MoveR: ClassReg R: Extra0Reg.
		self LogicalShiftRightCq: 10 R: Extra0Reg.
		s87 := objectMemory hiddenRootsObject.
		self LogicalShiftLeftCq: 3 R: Extra0Reg.
		self AddCq: s87 R: Extra0Reg.
		self MoveM64: 8 r: Extra0Reg R: Extra0Reg.
		self genMoveConstant: objectMemory nilObject R: SendNumArgsReg.
		self CmpR: SendNumArgsReg R: Extra0Reg.
		jump5 := self JumpNonZero: 0.
		self genMoveConstant: objectMemory nilObject R: SendNumArgsReg.
		jump2 := self Jump: 0.
		currentBlock := self Label.
		jump5 jmpTarget: currentBlock.
		self AndCq: 1023 R: ClassReg.
		self LogicalShiftLeftCq: 3 R: ClassReg.
		self AddR: ClassReg R: Extra0Reg.
		self MoveM64: 8 r: Extra0Reg R: SendNumArgsReg.
		currentBlock := self Label.
		jump2 jmpTarget: currentBlock.
		self MoveR: SendNumArgsReg R: ClassReg.
		currentBlock := self Label.
		jump1 jmpTarget: currentBlock.
		jump4 jmpTarget: currentBlock.
		self MoveR: ClassReg R: Extra0Reg.
		currentBlock := self Label.
		jump6 jmpTarget: currentBlock.
		self MoveR: Extra0Reg R: ReceiverResultReg.
		self genPrimReturn.
		currentBlock := self Label.
		jump3 jmpTarget: currentBlock.
		^ 0 ].
	^ 0
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveClassVariable [
	"AutoGenerated by Druid"

	| currentBlock |
	self MoveCq: 34 R: ReceiverResultReg.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveClassVariableWithBranch [
	"AutoGenerated by Druid"

	| jump1 s4 currentBlock s7 jump2 |
	self MoveR: ReceiverResultReg R: ClassReg.
	self CmpCq: 0 R: ClassReg.
	jump1 := self JumpNonZero: 0.
	s4 := 1.
	self MoveCq: s4 R: ClassReg.
	jump2 := self Jump: 0.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	s7 := 2.
	self MoveCq: s7 R: ClassReg.
	currentBlock := self Label.
	jump2 jmpTarget: currentBlock.
	self AddCq: 34 R: ClassReg.
	self MoveR: ClassReg R: ReceiverResultReg.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveConditionWithAnyMask [
	"AutoGenerated by Druid"

	| jump1 s4 currentBlock s7 jump2 |
	self MoveR: ReceiverResultReg R: ClassReg.
	self TstCq: 1 R: ClassReg.
	jump1 := self JumpZero: 0.
	s4 := 1.
	self MoveCq: s4 R: ClassReg.
	jump2 := self Jump: 0.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	s7 := 2.
	self MoveCq: s7 R: ClassReg.
	currentBlock := self Label.
	jump2 jmpTarget: currentBlock.
	self MoveR: ClassReg R: ReceiverResultReg.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveConditionWithAnyMaskInverted [
	"AutoGenerated by Druid"

	| jump1 s4 currentBlock s7 jump2 |
	self MoveR: ReceiverResultReg R: ClassReg.
	self TstCq: 1 R: ClassReg.
	jump1 := self JumpZero: 0.
	s4 := 1.
	self MoveCq: s4 R: ClassReg.
	jump2 := self Jump: 0.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	s7 := 2.
	self MoveCq: s7 R: ClassReg.
	currentBlock := self Label.
	jump2 jmpTarget: currentBlock.
	self MoveR: ClassReg R: ReceiverResultReg.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveConditionWithObjectReference [
	"AutoGenerated by Druid"

	| s8 jump1 currentBlock jump2 s5 s3 |
	self MoveR: ReceiverResultReg R: ClassReg.
	s3 := objectMemory trueObject.
	self CmpCq: s3 R: ClassReg.
	jump1 := self JumpAboveOrEqual: 0.
	s5 := 1.
	self MoveCq: s5 R: ClassReg.
	jump2 := self Jump: 0.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	s8 := 2.
	self MoveCq: s8 R: ClassReg.
	currentBlock := self Label.
	jump2 jmpTarget: currentBlock.
	self MoveR: ClassReg R: ReceiverResultReg.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveConstantFloatAsInteger [
	"AutoGenerated by Druid"

	| currentBlock |
	self MoveCq: 17 R: ReceiverResultReg.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveDNA [
	"AutoGenerated by Druid"

	| jump1 s22 jump3 s27 currentBlock s15 s7 s4 jump2 s26 s14 s9 |
	self MoveR: ReceiverResultReg R: ClassReg.
	self CmpCq: 10 R: ClassReg.
	jump1 := self JumpLessOrEqual: 0.
	s4 := 1.
	self MoveCq: s4 R: ClassReg.
	jump2 := self Jump: 0.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	s7 := 99.
	self CmpCq: 0 R: ClassReg.
	jump1 := self JumpLessOrEqual: 0.
	s9 := 5.
	self CmpCq: 7 R: ClassReg.
	jump3 := self JumpLessOrEqual: 0.
	self MoveCq: s7 R: ClassReg.
	currentBlock := self Label.
	jump2 jmpTarget: currentBlock.
	s14 := 5.
	s15 := 15.
	self MoveCq: s15 R: SendNumArgsReg.
	self MoveCq: s14 R: Extra0Reg.
	jump2 := self Jump: 0.
	currentBlock := self Label.
	jump3 jmpTarget: currentBlock.
	self MoveCq: s9 R: Extra0Reg.
	jump3 := self Jump: 0.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	s22 := 17.
	self MoveCq: s22 R: Extra0Reg.
	currentBlock := self Label.
	jump3 jmpTarget: currentBlock.
	s26 := 99.
	s27 := 42.
	self MoveCq: s27 R: SendNumArgsReg.
	self MoveCq: s26 R: ClassReg.
	currentBlock := self Label.
	jump2 jmpTarget: currentBlock.
	self AddR: Extra0Reg R: ClassReg.
	self AddR: SendNumArgsReg R: ClassReg.
	self MoveR: ClassReg R: ReceiverResultReg.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveDeadBranchWithError [
	"AutoGenerated by Druid"

	| currentBlock |
	self MoveCq: 17 R: ReceiverResultReg.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveDecrement [

	| currentBlock |
	self MoveR: ReceiverResultReg R: TempReg.
	self SubCq: 1 R: TempReg.
	self MoveR: TempReg R: ReceiverResultReg.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveDecrementConstantArgument [
	"AutoGenerated by Druid"

	| currentBlock |
	self MoveR: ReceiverResultReg R: ClassReg.
	self SubCq: 1 R: ClassReg.
	self MoveR: ClassReg R: ReceiverResultReg.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveDecrementConstantReceiver [
	"AutoGenerated by Druid"

	| currentBlock s3 |
	self MoveR: ReceiverResultReg R: ClassReg.
	s3 := 42.
	self MoveCq: s3 R: SendNumArgsReg.
	self SubR: ClassReg R: SendNumArgsReg.
	self MoveR: SendNumArgsReg R: ReceiverResultReg.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveDivide [
	"AutoGenerated by Druid"

	| currentBlock |
	self MoveR: ReceiverResultReg R: ClassReg.
	self MoveR: Arg0Reg R: SendNumArgsReg.
	self
		DivR: SendNumArgsReg
		R: ClassReg
		Quo: ClassReg
		Rem: SendNumArgsReg.
	self MoveR: ClassReg R: ReceiverResultReg.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveDivideByConstant [
	"AutoGenerated by Druid"

	| currentBlock s3 |
	self MoveR: ReceiverResultReg R: ClassReg.
	s3 := 2.
	self MoveCq: s3 R: SendNumArgsReg.
	self
		DivR: SendNumArgsReg
		R: ClassReg
		Quo: ClassReg
		Rem: SendNumArgsReg.
	self MoveR: ClassReg R: ReceiverResultReg.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveDivisionAsFloat [
	"AutoGenerated by Druid"

	| currentBlock |
	self MoveR: ReceiverResultReg R: ClassReg.
	self MoveR: Arg0Reg R: SendNumArgsReg.
	self ConvertR: SendNumArgsReg Rd: DPFPReg0.
	self ConvertR: ClassReg Rd: DPFPReg1.
	self DivRd: DPFPReg1 Rd: DPFPReg0.
	self MoveRd: DPFPReg0 R: ClassReg.
	self MoveR: ClassReg R: ReceiverResultReg.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveDoubleBitAndSubtreeLeftVariableLeft [
	"AutoGenerated by Druid"

	| currentBlock |
	self MoveR: ReceiverResultReg R: ClassReg.
	self AndCq: 16r3FFFFF R: ClassReg.
	self MoveR: ClassReg R: ReceiverResultReg.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveDoubleBitAndSubtreeLeftVariableRight [
	"AutoGenerated by Druid"

	| currentBlock |
	self MoveR: ReceiverResultReg R: ClassReg.
	self AndCq: 16r3FFFFF R: ClassReg.
	self MoveR: ClassReg R: ReceiverResultReg.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveDoubleBitAndSubtreeRightVariableLeft [
	"AutoGenerated by Druid"

	| currentBlock |
	self MoveR: ReceiverResultReg R: ClassReg.
	self AndCq: 16r3FFFFF R: ClassReg.
	self MoveR: ClassReg R: ReceiverResultReg.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveDoubleBitAndSubtreeRightVariableRight [
	"AutoGenerated by Druid"

	| currentBlock |
	self MoveR: ReceiverResultReg R: ClassReg.
	self AndCq: 16r3FFFFF R: ClassReg.
	self MoveR: ClassReg R: ReceiverResultReg.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveDoubleDeferredInline [
	"AutoGenerated by Druid"

	| jump1 currentBlock |
	self MoveR: ReceiverResultReg R: TempReg.
	self MoveCq: 0 R: ClassReg.
	self MoveR: ClassReg Aw: coInterpreter primitiveFailureCodeAddress.
	self MoveAw: coInterpreter primitiveFailureCodeAddress R: ClassReg.
	self MoveR: Arg0Reg R: SendNumArgsReg.
	self MoveCq: 2 R: SendNumArgsReg.
	self MulR: TempReg R: SendNumArgsReg.
	self MoveR: ClassReg Aw: coInterpreter primitiveFailureCodeAddress.
	self MoveAw: coInterpreter primitiveFailureCodeAddress R: ClassReg.
	self MoveR: SendNumArgsReg R: ReceiverResultReg.
	self CmpCq: 0 R: ClassReg.
	jump1 := self JumpNonZero: 0.
	self genPrimReturn.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveEqualsThan [
	"AutoGenerated by Druid"

	| jump1 s4 currentBlock s7 jump2 |
	self MoveR: ReceiverResultReg R: ClassReg.
	self CmpCq: 10 R: ClassReg.
	jump1 := self JumpNonZero: 0.
	s4 := 5.
	self MoveCq: s4 R: ClassReg.
	jump2 := self Jump: 0.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	s7 := 11.
	self MoveCq: s7 R: ClassReg.
	currentBlock := self Label.
	jump2 jmpTarget: currentBlock.
	self MoveR: ClassReg R: ReceiverResultReg.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveEqualsThanFloatConstant [
	"AutoGenerated by Druid"

	| jumpNext currentBlock jumpTrue |
	self MoveR: ReceiverResultReg R: ClassReg.
	self ConvertR: ClassReg Rd: DPFPReg0.
	self MoveCq: (objectMemory rawFloatBitsOf: 0.0) R: ClassReg.
	self MoveR: ClassReg Rd: DPFPReg1.
	self CmpRd: DPFPReg1 Rd: DPFPReg0.
	jumpTrue := self JumpFPEqual: 0.
	self MoveCq: 0 R: ClassReg.
	jumpNext := self Jump: 0.
	jumpTrue jmpTarget: self Label.
	self MoveCq: 1 R: ClassReg.
	jumpNext jmpTarget: self Label.
	self MoveR: ClassReg R: ReceiverResultReg.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveEqualsThanFloats [
	"AutoGenerated by Druid"

	| jumpNext currentBlock jumpTrue |
	self MoveR: ReceiverResultReg R: ClassReg.
	self MoveR: Arg0Reg R: SendNumArgsReg.
	self ConvertR: SendNumArgsReg Rd: DPFPReg0.
	self ConvertR: ClassReg Rd: DPFPReg1.
	self CmpRd: DPFPReg1 Rd: DPFPReg0.
	jumpTrue := self JumpFPEqual: 0.
	self MoveCq: 0 R: ClassReg.
	jumpNext := self Jump: 0.
	jumpTrue jmpTarget: self Label.
	self MoveCq: 1 R: ClassReg.
	jumpNext jmpTarget: self Label.
	self MoveR: ClassReg R: ReceiverResultReg.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveEqualsThanInverted [
	"AutoGenerated by Druid"

	| jump1 s4 currentBlock s7 jump2 |
	self MoveR: ReceiverResultReg R: ClassReg.
	self CmpCq: 10 R: ClassReg.
	jump1 := self JumpNonZero: 0.
	s4 := 5.
	self MoveCq: s4 R: ClassReg.
	jump2 := self Jump: 0.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	s7 := 11.
	self MoveCq: s7 R: ClassReg.
	currentBlock := self Label.
	jump2 jmpTarget: currentBlock.
	self MoveR: ClassReg R: ReceiverResultReg.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveEqualsThanReferenceValue [

	| jumpNext currentBlock jumpTrue |
	self MoveR: ReceiverResultReg R: TempReg.
	self CmpCw: objectMemory trueObject R: TempReg.
	jumpTrue := self JumpZero: 0.
	self MoveCq: 0 R: TempReg.
	jumpNext := self Jump: 0.
	jumpTrue jmpTarget: self Label.
	self MoveCq: 1 R: TempReg.
	jumpNext jmpTarget: self Label.
	self MoveR: TempReg R: ReceiverResultReg.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveEqualsThanValue [
	"AutoGenerated by Druid"

	| jumpTrue jumpNext currentBlock s3 |
	self MoveR: ReceiverResultReg R: ClassReg.
	s3 := 0.
	self CmpCq: s3 R: ClassReg.
	jumpTrue := self JumpZero: 0.
	self MoveCq: 0 R: ClassReg.
	jumpNext := self Jump: 0.
	jumpTrue jmpTarget: self Label.
	self MoveCq: 1 R: ClassReg.
	jumpNext jmpTarget: self Label.
	self MoveR: ClassReg R: ReceiverResultReg.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveFalseAsInteger [
	"AutoGenerated by Druid"

	| currentBlock |
	self MoveCq: 0 R: ReceiverResultReg.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveFalseAssignmentAsInteger [
	"AutoGenerated by Druid"

	| currentBlock |
	self MoveCq: 0 R: ReceiverResultReg.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveFalseNot [
	"AutoGenerated by Druid"

	| currentBlock |
	self MoveCq: 1 R: ReceiverResultReg.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveFloat64At [
	"AutoGenerated by Druid"

	| currentBlock |
	self MoveR: ReceiverResultReg R: ClassReg.
	self MoveM64: 0 r: ClassReg Rd: DPFPReg0.
	self MoveRd: DPFPReg0 R: ClassReg.
	self MoveR: ClassReg R: ReceiverResultReg.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveFloat64AtPut [
	"AutoGenerated by Druid"

	| currentBlock |
	self MoveR: ReceiverResultReg R: ClassReg.
	self MoveR: Arg0Reg R: SendNumArgsReg.
	self ConvertR: SendNumArgsReg Rd: DPFPReg0.
	self MoveRd: DPFPReg0 M64: 0 r: ClassReg.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveFloatAdd [
	"AutoGenerated by Druid"

	| jump1 s89 jumpNext jump9 jump6 jump3 currentBlock jump8 jump5 jump2 s121 jumpTrue s118 s93 jump7 jump4 |
	self MoveR: ReceiverResultReg R: ClassReg.
	self MoveR: Arg0Reg R: SendNumArgsReg.
	self MoveR: ClassReg R: Extra0Reg.
	self AndCq: 7 R: Extra0Reg.
	self CmpCq: 0 R: Extra0Reg.
	jump1 := self JumpZero: 0.
	self CmpCq: 4 R: Extra0Reg.
	jump2 := self JumpNonZero: 0.
	self MoveR: ClassReg R: Extra0Reg.
	self LogicalShiftRightCq: 3 R: Extra0Reg.
	self CmpCq: 1 R: Extra0Reg.
	jump3 := self JumpBelowOrEqual: 0.
	self AddCq: 16r7000000000000000 R: Extra0Reg.
	jump4 := self Jump: 0.
	currentBlock := self Label.
	jump3 jmpTarget: currentBlock.
	currentBlock := self Label.
	jump4 jmpTarget: currentBlock.
	self MoveR: Extra0Reg R: ClassReg.
	self LogicalShiftLeftCq: 63 R: ClassReg.
	self LogicalShiftRightCq: 1 R: Extra0Reg.
	self AddR: Extra0Reg R: ClassReg.
	self MoveR: ClassReg Rd: DPFPReg0.
	jump4 := self Jump: 0.
	currentBlock := self Label.
	jump2 jmpTarget: currentBlock.
	self CmpCq: 1 R: Extra0Reg.
	jump2 := self JumpNonZero: 0.
	self MoveR: ClassReg R: Extra0Reg.
	self LogicalShiftLeftCq: 9 R: Extra0Reg.
	self ArithmeticShiftRightCq: 9 R: Extra0Reg.
	self CmpR: ClassReg R: Extra0Reg.
	jump3 := self JumpNonZero: 0.
	self ArithmeticShiftRightCq: 3 R: ClassReg.
	self ConvertR: ClassReg Rd: DPFPReg0.
	jump5 := self Jump: 0.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	self MoveM64: 0 r: ClassReg R: Extra0Reg.
	self AndCq: 16r3FFFFF R: Extra0Reg.
	self CmpCq: 34 R: Extra0Reg.
	jump1 := self JumpNonZero: 0.
	self MoveM64: 8 r: ClassReg Rd: DPFPReg0.
	currentBlock := self Label.
	jump4 jmpTarget: currentBlock.
	jump5 jmpTarget: currentBlock.
	self MoveR: SendNumArgsReg R: Extra0Reg.
	self AndCq: 7 R: Extra0Reg.
	self CmpCq: 0 R: Extra0Reg.
	jump5 := self JumpZero: 0.
	self CmpCq: 4 R: Extra0Reg.
	jump4 := self JumpNonZero: 0.
	self MoveR: SendNumArgsReg R: Extra0Reg.
	self LogicalShiftRightCq: 3 R: Extra0Reg.
	self CmpCq: 1 R: Extra0Reg.
	jump6 := self JumpBelowOrEqual: 0.
	self AddCq: 16r7000000000000000 R: Extra0Reg.
	jump7 := self Jump: 0.
	currentBlock := self Label.
	jump6 jmpTarget: currentBlock.
	currentBlock := self Label.
	jump7 jmpTarget: currentBlock.
	self MoveR: Extra0Reg R: SendNumArgsReg.
	self LogicalShiftLeftCq: 63 R: SendNumArgsReg.
	self LogicalShiftRightCq: 1 R: Extra0Reg.
	self AddR: Extra0Reg R: SendNumArgsReg.
	self MoveR: SendNumArgsReg Rd: DPFPReg1.
	jump7 := self Jump: 0.
	currentBlock := self Label.
	jump4 jmpTarget: currentBlock.
	self CmpCq: 1 R: Extra0Reg.
	jump4 := self JumpNonZero: 0.
	self MoveR: SendNumArgsReg R: Extra0Reg.
	self LogicalShiftLeftCq: 9 R: Extra0Reg.
	self ArithmeticShiftRightCq: 9 R: Extra0Reg.
	self CmpR: SendNumArgsReg R: Extra0Reg.
	jump6 := self JumpNonZero: 0.
	self ArithmeticShiftRightCq: 3 R: SendNumArgsReg.
	self ConvertR: SendNumArgsReg Rd: DPFPReg1.
	jump8 := self Jump: 0.
	currentBlock := self Label.
	jump5 jmpTarget: currentBlock.
	self MoveM64: 0 r: SendNumArgsReg R: Extra0Reg.
	self AndCq: 16r3FFFFF R: Extra0Reg.
	self CmpCq: 34 R: Extra0Reg.
	jump5 := self JumpNonZero: 0.
	self MoveM64: 8 r: SendNumArgsReg Rd: DPFPReg1.
	currentBlock := self Label.
	jump7 jmpTarget: currentBlock.
	jump8 jmpTarget: currentBlock.
	self AddRd: DPFPReg1 Rd: DPFPReg0.
	self MoveRd: DPFPReg0 R: Extra0Reg.
	self MoveR: Extra0Reg R: SendNumArgsReg.
	self LogicalShiftRightCq: 52 R: SendNumArgsReg.
	self AndCq: 2047 R: SendNumArgsReg.
	self CmpCq: 896 R: SendNumArgsReg.
	jump8 := self JumpBelowOrEqual: 0.
	self CmpCq: 1151 R: SendNumArgsReg.
	jumpTrue := self JumpBelowOrEqual: 0.
	self MoveCq: 0 R: SendNumArgsReg.
	jumpNext := self Jump: 0.
	jumpTrue jmpTarget: self Label.
	self MoveCq: 1 R: SendNumArgsReg.
	jumpNext jmpTarget: self Label.
	jump7 := self Jump: 0.
	currentBlock := self Label.
	jump8 jmpTarget: currentBlock.
	self AndCq: 16rFFFFFFFFFFFFF R: Extra0Reg.
	self CmpCq: 0 R: Extra0Reg.
	jump8 := self JumpNonZero: 0.
	s89 := 0.
	self CmpCq: s89 R: SendNumArgsReg.
	jumpTrue := self JumpZero: 0.
	self MoveCq: 0 R: SendNumArgsReg.
	jumpNext := self Jump: 0.
	jumpTrue jmpTarget: self Label.
	self MoveCq: 1 R: SendNumArgsReg.
	jumpNext jmpTarget: self Label.
	jump9 := self Jump: 0.
	currentBlock := self Label.
	jump8 jmpTarget: currentBlock.
	s93 := 896.
	self CmpCq: s93 R: SendNumArgsReg.
	jumpTrue := self JumpZero: 0.
	self MoveCq: 0 R: SendNumArgsReg.
	jumpNext := self Jump: 0.
	jumpTrue jmpTarget: self Label.
	self MoveCq: 1 R: SendNumArgsReg.
	jumpNext jmpTarget: self Label.
	currentBlock := self Label.
	jump9 jmpTarget: currentBlock.
	currentBlock := self Label.
	jump7 jmpTarget: currentBlock.
	self CmpCq: 1 R: SendNumArgsReg.
	jump7 := self JumpNonZero: 0.
	self MoveRd: DPFPReg0 R: SendNumArgsReg.
	self RotateLeftCq: 1 R: SendNumArgsReg.
	self CmpCq: 1 R: SendNumArgsReg.
	jump9 := self JumpBelowOrEqual: 0.
	self SubCq: 16r7000000000000000 R: SendNumArgsReg.
	jump8 := self Jump: 0.
	currentBlock := self Label.
	jump9 jmpTarget: currentBlock.
	currentBlock := self Label.
	jump8 jmpTarget: currentBlock.
	self LogicalShiftLeftCq: 3 R: SendNumArgsReg.
	self AddCq: 4 R: SendNumArgsReg.
	jump8 := self Jump: 0.
	currentBlock := self Label.
	jump7 jmpTarget: currentBlock.
	self MoveAw: objectMemory freeStartAddress R: SendNumArgsReg.
	self MoveAw: objectMemory freeStartAddress R: Extra0Reg.
	self AddCq: 16 R: Extra0Reg.
	s118 := objectMemory getScavengeThreshold.
	self CmpCq: s118 R: Extra0Reg.
	jump7 := self JumpAbove: 0.
	s121 := 72057594205700130.
	self MoveCq: s121 R: Extra0Reg.
	self MoveR: Extra0Reg M64: 0 r: SendNumArgsReg.
	self MoveAw: objectMemory freeStartAddress R: Extra0Reg.
	self AddCq: 16 R: Extra0Reg.
	self MoveR: Extra0Reg Aw: objectMemory freeStartAddress.
	self MoveRd: DPFPReg0 M64: 8 r: SendNumArgsReg.
	currentBlock := self Label.
	jump8 jmpTarget: currentBlock.
	self MoveR: SendNumArgsReg R: ReceiverResultReg.
	self genPrimReturn.
	currentBlock := self Label.
	jump2 jmpTarget: currentBlock.
	jump3 jmpTarget: currentBlock.
	jump1 jmpTarget: currentBlock.
	jump4 jmpTarget: currentBlock.
	jump6 jmpTarget: currentBlock.
	jump5 jmpTarget: currentBlock.
	jump7 jmpTarget: currentBlock.
	^ 0
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveFloatDivide [
	"AutoGenerated by Druid"

	| jump1 jump10 jumpNext jump9 jump6 jump3 s119 currentBlock jump8 jump5 jump2 s121 jumpTrue jump7 jump4 |
	self MoveR: ReceiverResultReg R: ClassReg.
	self MoveR: Arg0Reg R: SendNumArgsReg.
	self MoveR: ClassReg R: Extra0Reg.
	self AndCq: 7 R: Extra0Reg.
	self CmpCq: 0 R: Extra0Reg.
	jump1 := self JumpZero: 0.
	self CmpCq: 4 R: Extra0Reg.
	jump2 := self JumpNonZero: 0.
	self MoveR: ClassReg R: Extra0Reg.
	self LogicalShiftRightCq: 3 R: Extra0Reg.
	self CmpCq: 1 R: Extra0Reg.
	jump3 := self JumpBelowOrEqual: 0.
	self AddCq: 16r7000000000000000 R: Extra0Reg.
	jump4 := self Jump: 0.
	currentBlock := self Label.
	jump3 jmpTarget: currentBlock.
	currentBlock := self Label.
	jump4 jmpTarget: currentBlock.
	self MoveR: Extra0Reg R: ClassReg.
	self LogicalShiftLeftCq: 63 R: ClassReg.
	self LogicalShiftRightCq: 1 R: Extra0Reg.
	self AddR: Extra0Reg R: ClassReg.
	self MoveR: ClassReg Rd: DPFPReg0.
	jump4 := self Jump: 0.
	currentBlock := self Label.
	jump2 jmpTarget: currentBlock.
	self CmpCq: 1 R: Extra0Reg.
	jump2 := self JumpNonZero: 0.
	self MoveR: ClassReg R: Extra0Reg.
	self LogicalShiftLeftCq: 9 R: Extra0Reg.
	self ArithmeticShiftRightCq: 9 R: Extra0Reg.
	self CmpR: ClassReg R: Extra0Reg.
	jump3 := self JumpNonZero: 0.
	self ArithmeticShiftRightCq: 3 R: ClassReg.
	self ConvertR: ClassReg Rd: DPFPReg0.
	jump5 := self Jump: 0.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	self MoveM64: 0 r: ClassReg R: Extra0Reg.
	self AndCq: 16r3FFFFF R: Extra0Reg.
	self CmpCq: 34 R: Extra0Reg.
	jump1 := self JumpNonZero: 0.
	self MoveM64: 8 r: ClassReg Rd: DPFPReg0.
	currentBlock := self Label.
	jump4 jmpTarget: currentBlock.
	jump5 jmpTarget: currentBlock.
	self MoveR: SendNumArgsReg R: Extra0Reg.
	self AndCq: 7 R: Extra0Reg.
	self CmpCq: 0 R: Extra0Reg.
	jump5 := self JumpZero: 0.
	self CmpCq: 4 R: Extra0Reg.
	jump4 := self JumpNonZero: 0.
	self MoveR: SendNumArgsReg R: Extra0Reg.
	self LogicalShiftRightCq: 3 R: Extra0Reg.
	self CmpCq: 1 R: Extra0Reg.
	jump6 := self JumpBelowOrEqual: 0.
	self AddCq: 16r7000000000000000 R: Extra0Reg.
	jump7 := self Jump: 0.
	currentBlock := self Label.
	jump6 jmpTarget: currentBlock.
	currentBlock := self Label.
	jump7 jmpTarget: currentBlock.
	self MoveR: Extra0Reg R: SendNumArgsReg.
	self LogicalShiftLeftCq: 63 R: SendNumArgsReg.
	self LogicalShiftRightCq: 1 R: Extra0Reg.
	self AddR: Extra0Reg R: SendNumArgsReg.
	self MoveR: SendNumArgsReg Rd: DPFPReg1.
	jump7 := self Jump: 0.
	currentBlock := self Label.
	jump4 jmpTarget: currentBlock.
	self CmpCq: 1 R: Extra0Reg.
	jump4 := self JumpNonZero: 0.
	self MoveR: SendNumArgsReg R: Extra0Reg.
	self LogicalShiftLeftCq: 9 R: Extra0Reg.
	self ArithmeticShiftRightCq: 9 R: Extra0Reg.
	self CmpR: SendNumArgsReg R: Extra0Reg.
	jump6 := self JumpNonZero: 0.
	self ArithmeticShiftRightCq: 3 R: SendNumArgsReg.
	self ConvertR: SendNumArgsReg Rd: DPFPReg1.
	jump8 := self Jump: 0.
	currentBlock := self Label.
	jump5 jmpTarget: currentBlock.
	self MoveM64: 0 r: SendNumArgsReg R: Extra0Reg.
	self AndCq: 16r3FFFFF R: Extra0Reg.
	self CmpCq: 34 R: Extra0Reg.
	jump5 := self JumpNonZero: 0.
	self MoveM64: 8 r: SendNumArgsReg Rd: DPFPReg1.
	currentBlock := self Label.
	jump7 jmpTarget: currentBlock.
	jump8 jmpTarget: currentBlock.
	self CmpCq: 0.0 Rd: DPFPReg1.
	jump8 := self JumpFPEqual: 0.
	self DivRd: DPFPReg1 Rd: DPFPReg0.
	self MoveRd: DPFPReg0 R: Extra0Reg.
	self MoveR: Extra0Reg R: SendNumArgsReg.
	self LogicalShiftRightCq: 52 R: SendNumArgsReg.
	self AndCq: 2047 R: SendNumArgsReg.
	self CmpCq: 896 R: SendNumArgsReg.
	jump7 := self JumpBelowOrEqual: 0.
	self CmpCq: 1151 R: SendNumArgsReg.
	jumpTrue := self JumpBelowOrEqual: 0.
	self MoveCq: 0 R: SendNumArgsReg.
	jumpNext := self Jump: 0.
	jumpTrue jmpTarget: self Label.
	self MoveCq: 1 R: SendNumArgsReg.
	jumpNext jmpTarget: self Label.
	jump9 := self Jump: 0.
	currentBlock := self Label.
	jump7 jmpTarget: currentBlock.
	self AndCq: 16rFFFFFFFFFFFFF R: Extra0Reg.
	self CmpCq: 0 R: Extra0Reg.
	jump7 := self JumpNonZero: 0.
	self CmpCq: 0 R: SendNumArgsReg.
	jumpTrue := self JumpZero: 0.
	self MoveCq: 0 R: SendNumArgsReg.
	jumpNext := self Jump: 0.
	jumpTrue jmpTarget: self Label.
	self MoveCq: 1 R: SendNumArgsReg.
	jumpNext jmpTarget: self Label.
	jump10 := self Jump: 0.
	currentBlock := self Label.
	jump7 jmpTarget: currentBlock.
	self CmpCq: 896 R: SendNumArgsReg.
	jumpTrue := self JumpZero: 0.
	self MoveCq: 0 R: SendNumArgsReg.
	jumpNext := self Jump: 0.
	jumpTrue jmpTarget: self Label.
	self MoveCq: 1 R: SendNumArgsReg.
	jumpNext jmpTarget: self Label.
	currentBlock := self Label.
	jump10 jmpTarget: currentBlock.
	currentBlock := self Label.
	jump9 jmpTarget: currentBlock.
	self CmpCq: 1 R: SendNumArgsReg.
	jump9 := self JumpNonZero: 0.
	self MoveRd: DPFPReg0 R: SendNumArgsReg.
	self RotateLeftCq: 1 R: SendNumArgsReg.
	self CmpCq: 1 R: SendNumArgsReg.
	jump10 := self JumpBelowOrEqual: 0.
	self SubCq: 16r7000000000000000 R: SendNumArgsReg.
	jump7 := self Jump: 0.
	currentBlock := self Label.
	jump10 jmpTarget: currentBlock.
	currentBlock := self Label.
	jump7 jmpTarget: currentBlock.
	self LogicalShiftLeftCq: 3 R: SendNumArgsReg.
	self AddCq: 4 R: SendNumArgsReg.
	self MoveR: SendNumArgsReg R: ReceiverResultReg.
	jump7 := self Jump: 0.
	currentBlock := self Label.
	jump9 jmpTarget: currentBlock.
	self MoveAw: objectMemory freeStartAddress R: SendNumArgsReg.
	self MoveAw: objectMemory freeStartAddress R: Extra0Reg.
	self AddCq: 16 R: Extra0Reg.
	s119 := objectMemory getScavengeThreshold.
	self CmpCq: s119 R: Extra0Reg.
	jump9 := self JumpAbove: 0.
	s121 := 72057594205700130.
	self MoveCq: s121 R: Extra0Reg.
	self MoveR: Extra0Reg M64: 0 r: SendNumArgsReg.
	self MoveAw: objectMemory freeStartAddress R: Extra0Reg.
	self AddCq: 16 R: Extra0Reg.
	self MoveR: Extra0Reg Aw: objectMemory freeStartAddress.
	self MoveRd: DPFPReg0 M64: 8 r: SendNumArgsReg.
	self MoveR: SendNumArgsReg R: ReceiverResultReg.
	currentBlock := self Label.
	jump7 jmpTarget: currentBlock.
	self genPrimReturn.
	currentBlock := self Label.
	jump8 jmpTarget: currentBlock.
	currentBlock := self Label.
	jump2 jmpTarget: currentBlock.
	jump3 jmpTarget: currentBlock.
	jump1 jmpTarget: currentBlock.
	jump4 jmpTarget: currentBlock.
	jump6 jmpTarget: currentBlock.
	jump5 jmpTarget: currentBlock.
	jump9 jmpTarget: currentBlock.
	^ 0
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveFloatEqual [
	"AutoGenerated by Druid"

	| jump1 jump6 jump3 currentBlock s82 jump8 jump5 s79 jump2 jump7 jump4 |
	self MoveR: ReceiverResultReg R: ClassReg.
	self MoveR: Arg0Reg R: SendNumArgsReg.
	self MoveR: ClassReg R: Extra0Reg.
	self AndCq: 7 R: Extra0Reg.
	self CmpCq: 0 R: Extra0Reg.
	jump1 := self JumpZero: 0.
	self CmpCq: 4 R: Extra0Reg.
	jump2 := self JumpNonZero: 0.
	self MoveR: ClassReg R: Extra0Reg.
	self LogicalShiftRightCq: 3 R: Extra0Reg.
	self CmpCq: 1 R: Extra0Reg.
	jump3 := self JumpBelowOrEqual: 0.
	self AddCq: 16r7000000000000000 R: Extra0Reg.
	jump4 := self Jump: 0.
	currentBlock := self Label.
	jump3 jmpTarget: currentBlock.
	currentBlock := self Label.
	jump4 jmpTarget: currentBlock.
	self MoveR: Extra0Reg R: ClassReg.
	self LogicalShiftLeftCq: 63 R: ClassReg.
	self LogicalShiftRightCq: 1 R: Extra0Reg.
	self AddR: Extra0Reg R: ClassReg.
	self MoveR: ClassReg Rd: DPFPReg0.
	jump4 := self Jump: 0.
	currentBlock := self Label.
	jump2 jmpTarget: currentBlock.
	self CmpCq: 1 R: Extra0Reg.
	jump2 := self JumpNonZero: 0.
	self MoveR: ClassReg R: Extra0Reg.
	self LogicalShiftLeftCq: 9 R: Extra0Reg.
	self ArithmeticShiftRightCq: 9 R: Extra0Reg.
	self CmpR: ClassReg R: Extra0Reg.
	jump3 := self JumpNonZero: 0.
	self ArithmeticShiftRightCq: 3 R: ClassReg.
	self ConvertR: ClassReg Rd: DPFPReg0.
	jump5 := self Jump: 0.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	self MoveM64: 0 r: ClassReg R: Extra0Reg.
	self AndCq: 16r3FFFFF R: Extra0Reg.
	self CmpCq: 34 R: Extra0Reg.
	jump1 := self JumpNonZero: 0.
	self MoveM64: 8 r: ClassReg Rd: DPFPReg0.
	currentBlock := self Label.
	jump4 jmpTarget: currentBlock.
	jump5 jmpTarget: currentBlock.
	self MoveR: SendNumArgsReg R: Extra0Reg.
	self AndCq: 7 R: Extra0Reg.
	self CmpCq: 0 R: Extra0Reg.
	jump5 := self JumpZero: 0.
	self CmpCq: 4 R: Extra0Reg.
	jump4 := self JumpNonZero: 0.
	self MoveR: SendNumArgsReg R: Extra0Reg.
	self LogicalShiftRightCq: 3 R: Extra0Reg.
	self CmpCq: 1 R: Extra0Reg.
	jump6 := self JumpBelowOrEqual: 0.
	self AddCq: 16r7000000000000000 R: Extra0Reg.
	jump7 := self Jump: 0.
	currentBlock := self Label.
	jump6 jmpTarget: currentBlock.
	currentBlock := self Label.
	jump7 jmpTarget: currentBlock.
	self MoveR: Extra0Reg R: SendNumArgsReg.
	self LogicalShiftLeftCq: 63 R: SendNumArgsReg.
	self LogicalShiftRightCq: 1 R: Extra0Reg.
	self AddR: Extra0Reg R: SendNumArgsReg.
	self MoveR: SendNumArgsReg Rd: DPFPReg1.
	jump7 := self Jump: 0.
	currentBlock := self Label.
	jump4 jmpTarget: currentBlock.
	self CmpCq: 1 R: Extra0Reg.
	jump4 := self JumpNonZero: 0.
	self MoveR: SendNumArgsReg R: Extra0Reg.
	self LogicalShiftLeftCq: 9 R: Extra0Reg.
	self ArithmeticShiftRightCq: 9 R: Extra0Reg.
	self CmpR: SendNumArgsReg R: Extra0Reg.
	jump6 := self JumpNonZero: 0.
	self ArithmeticShiftRightCq: 3 R: SendNumArgsReg.
	self ConvertR: SendNumArgsReg Rd: DPFPReg1.
	jump8 := self Jump: 0.
	currentBlock := self Label.
	jump5 jmpTarget: currentBlock.
	self MoveM64: 0 r: SendNumArgsReg R: Extra0Reg.
	self AndCq: 16r3FFFFF R: Extra0Reg.
	self CmpCq: 34 R: Extra0Reg.
	jump5 := self JumpNonZero: 0.
	self MoveM64: 8 r: SendNumArgsReg Rd: DPFPReg1.
	currentBlock := self Label.
	jump7 jmpTarget: currentBlock.
	jump8 jmpTarget: currentBlock.
	self CmpRd: DPFPReg1 Rd: DPFPReg0.
	jump8 := self JumpFPNotEqual: 0.
	s79 := objectMemory trueObject.
	self MoveCq: s79 R: Extra0Reg.
	jump7 := self Jump: 0.
	currentBlock := self Label.
	jump8 jmpTarget: currentBlock.
	s82 := objectMemory falseObject.
	self MoveCq: s82 R: Extra0Reg.
	currentBlock := self Label.
	jump7 jmpTarget: currentBlock.
	self MoveR: Extra0Reg R: ReceiverResultReg.
	self genPrimReturn.
	currentBlock := self Label.
	jump2 jmpTarget: currentBlock.
	jump3 jmpTarget: currentBlock.
	jump1 jmpTarget: currentBlock.
	jump4 jmpTarget: currentBlock.
	jump6 jmpTarget: currentBlock.
	jump5 jmpTarget: currentBlock.
	^ 0
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveFloatMultiply [
	"AutoGenerated by Druid"

	| jump1 s89 jumpNext jump9 jump6 jump3 currentBlock jump8 jump5 jump2 s121 jumpTrue s118 s93 jump7 jump4 |
	self MoveR: ReceiverResultReg R: ClassReg.
	self MoveR: Arg0Reg R: SendNumArgsReg.
	self MoveR: ClassReg R: Extra0Reg.
	self AndCq: 7 R: Extra0Reg.
	self CmpCq: 0 R: Extra0Reg.
	jump1 := self JumpZero: 0.
	self CmpCq: 4 R: Extra0Reg.
	jump2 := self JumpNonZero: 0.
	self MoveR: ClassReg R: Extra0Reg.
	self LogicalShiftRightCq: 3 R: Extra0Reg.
	self CmpCq: 1 R: Extra0Reg.
	jump3 := self JumpBelowOrEqual: 0.
	self AddCq: 16r7000000000000000 R: Extra0Reg.
	jump4 := self Jump: 0.
	currentBlock := self Label.
	jump3 jmpTarget: currentBlock.
	currentBlock := self Label.
	jump4 jmpTarget: currentBlock.
	self MoveR: Extra0Reg R: ClassReg.
	self LogicalShiftLeftCq: 63 R: ClassReg.
	self LogicalShiftRightCq: 1 R: Extra0Reg.
	self AddR: Extra0Reg R: ClassReg.
	self MoveR: ClassReg Rd: DPFPReg0.
	jump4 := self Jump: 0.
	currentBlock := self Label.
	jump2 jmpTarget: currentBlock.
	self CmpCq: 1 R: Extra0Reg.
	jump2 := self JumpNonZero: 0.
	self MoveR: ClassReg R: Extra0Reg.
	self LogicalShiftLeftCq: 9 R: Extra0Reg.
	self ArithmeticShiftRightCq: 9 R: Extra0Reg.
	self CmpR: ClassReg R: Extra0Reg.
	jump3 := self JumpNonZero: 0.
	self ArithmeticShiftRightCq: 3 R: ClassReg.
	self ConvertR: ClassReg Rd: DPFPReg0.
	jump5 := self Jump: 0.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	self MoveM64: 0 r: ClassReg R: Extra0Reg.
	self AndCq: 16r3FFFFF R: Extra0Reg.
	self CmpCq: 34 R: Extra0Reg.
	jump1 := self JumpNonZero: 0.
	self MoveM64: 8 r: ClassReg Rd: DPFPReg0.
	currentBlock := self Label.
	jump4 jmpTarget: currentBlock.
	jump5 jmpTarget: currentBlock.
	self MoveR: SendNumArgsReg R: Extra0Reg.
	self AndCq: 7 R: Extra0Reg.
	self CmpCq: 0 R: Extra0Reg.
	jump5 := self JumpZero: 0.
	self CmpCq: 4 R: Extra0Reg.
	jump4 := self JumpNonZero: 0.
	self MoveR: SendNumArgsReg R: Extra0Reg.
	self LogicalShiftRightCq: 3 R: Extra0Reg.
	self CmpCq: 1 R: Extra0Reg.
	jump6 := self JumpBelowOrEqual: 0.
	self AddCq: 16r7000000000000000 R: Extra0Reg.
	jump7 := self Jump: 0.
	currentBlock := self Label.
	jump6 jmpTarget: currentBlock.
	currentBlock := self Label.
	jump7 jmpTarget: currentBlock.
	self MoveR: Extra0Reg R: SendNumArgsReg.
	self LogicalShiftLeftCq: 63 R: SendNumArgsReg.
	self LogicalShiftRightCq: 1 R: Extra0Reg.
	self AddR: Extra0Reg R: SendNumArgsReg.
	self MoveR: SendNumArgsReg Rd: DPFPReg1.
	jump7 := self Jump: 0.
	currentBlock := self Label.
	jump4 jmpTarget: currentBlock.
	self CmpCq: 1 R: Extra0Reg.
	jump4 := self JumpNonZero: 0.
	self MoveR: SendNumArgsReg R: Extra0Reg.
	self LogicalShiftLeftCq: 9 R: Extra0Reg.
	self ArithmeticShiftRightCq: 9 R: Extra0Reg.
	self CmpR: SendNumArgsReg R: Extra0Reg.
	jump6 := self JumpNonZero: 0.
	self ArithmeticShiftRightCq: 3 R: SendNumArgsReg.
	self ConvertR: SendNumArgsReg Rd: DPFPReg1.
	jump8 := self Jump: 0.
	currentBlock := self Label.
	jump5 jmpTarget: currentBlock.
	self MoveM64: 0 r: SendNumArgsReg R: Extra0Reg.
	self AndCq: 16r3FFFFF R: Extra0Reg.
	self CmpCq: 34 R: Extra0Reg.
	jump5 := self JumpNonZero: 0.
	self MoveM64: 8 r: SendNumArgsReg Rd: DPFPReg1.
	currentBlock := self Label.
	jump7 jmpTarget: currentBlock.
	jump8 jmpTarget: currentBlock.
	self MulRd: DPFPReg1 Rd: DPFPReg0.
	self MoveRd: DPFPReg0 R: Extra0Reg.
	self MoveR: Extra0Reg R: SendNumArgsReg.
	self LogicalShiftRightCq: 52 R: SendNumArgsReg.
	self AndCq: 2047 R: SendNumArgsReg.
	self CmpCq: 896 R: SendNumArgsReg.
	jump8 := self JumpBelowOrEqual: 0.
	self CmpCq: 1151 R: SendNumArgsReg.
	jumpTrue := self JumpBelowOrEqual: 0.
	self MoveCq: 0 R: SendNumArgsReg.
	jumpNext := self Jump: 0.
	jumpTrue jmpTarget: self Label.
	self MoveCq: 1 R: SendNumArgsReg.
	jumpNext jmpTarget: self Label.
	jump7 := self Jump: 0.
	currentBlock := self Label.
	jump8 jmpTarget: currentBlock.
	self AndCq: 16rFFFFFFFFFFFFF R: Extra0Reg.
	self CmpCq: 0 R: Extra0Reg.
	jump8 := self JumpNonZero: 0.
	s89 := 0.
	self CmpCq: s89 R: SendNumArgsReg.
	jumpTrue := self JumpZero: 0.
	self MoveCq: 0 R: SendNumArgsReg.
	jumpNext := self Jump: 0.
	jumpTrue jmpTarget: self Label.
	self MoveCq: 1 R: SendNumArgsReg.
	jumpNext jmpTarget: self Label.
	jump9 := self Jump: 0.
	currentBlock := self Label.
	jump8 jmpTarget: currentBlock.
	s93 := 896.
	self CmpCq: s93 R: SendNumArgsReg.
	jumpTrue := self JumpZero: 0.
	self MoveCq: 0 R: SendNumArgsReg.
	jumpNext := self Jump: 0.
	jumpTrue jmpTarget: self Label.
	self MoveCq: 1 R: SendNumArgsReg.
	jumpNext jmpTarget: self Label.
	currentBlock := self Label.
	jump9 jmpTarget: currentBlock.
	currentBlock := self Label.
	jump7 jmpTarget: currentBlock.
	self CmpCq: 1 R: SendNumArgsReg.
	jump7 := self JumpNonZero: 0.
	self MoveRd: DPFPReg0 R: SendNumArgsReg.
	self RotateLeftCq: 1 R: SendNumArgsReg.
	self CmpCq: 1 R: SendNumArgsReg.
	jump9 := self JumpBelowOrEqual: 0.
	self SubCq: 16r7000000000000000 R: SendNumArgsReg.
	jump8 := self Jump: 0.
	currentBlock := self Label.
	jump9 jmpTarget: currentBlock.
	currentBlock := self Label.
	jump8 jmpTarget: currentBlock.
	self LogicalShiftLeftCq: 3 R: SendNumArgsReg.
	self AddCq: 4 R: SendNumArgsReg.
	jump8 := self Jump: 0.
	currentBlock := self Label.
	jump7 jmpTarget: currentBlock.
	self MoveAw: objectMemory freeStartAddress R: SendNumArgsReg.
	self MoveAw: objectMemory freeStartAddress R: Extra0Reg.
	self AddCq: 16 R: Extra0Reg.
	s118 := objectMemory getScavengeThreshold.
	self CmpCq: s118 R: Extra0Reg.
	jump7 := self JumpAbove: 0.
	s121 := 72057594205700130.
	self MoveCq: s121 R: Extra0Reg.
	self MoveR: Extra0Reg M64: 0 r: SendNumArgsReg.
	self MoveAw: objectMemory freeStartAddress R: Extra0Reg.
	self AddCq: 16 R: Extra0Reg.
	self MoveR: Extra0Reg Aw: objectMemory freeStartAddress.
	self MoveRd: DPFPReg0 M64: 8 r: SendNumArgsReg.
	currentBlock := self Label.
	jump8 jmpTarget: currentBlock.
	self MoveR: SendNumArgsReg R: ReceiverResultReg.
	self genPrimReturn.
	currentBlock := self Label.
	jump2 jmpTarget: currentBlock.
	jump3 jmpTarget: currentBlock.
	jump1 jmpTarget: currentBlock.
	jump4 jmpTarget: currentBlock.
	jump6 jmpTarget: currentBlock.
	jump5 jmpTarget: currentBlock.
	jump7 jmpTarget: currentBlock.
	^ 0
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveFloatNotEqual [
	"AutoGenerated by Druid"

	| jump1 jump6 jump3 currentBlock s82 jump8 jump5 s79 jump2 jump7 jump4 |
	self MoveR: ReceiverResultReg R: ClassReg.
	self MoveR: Arg0Reg R: SendNumArgsReg.
	self MoveR: ClassReg R: Extra0Reg.
	self AndCq: 7 R: Extra0Reg.
	self CmpCq: 0 R: Extra0Reg.
	jump1 := self JumpZero: 0.
	self CmpCq: 4 R: Extra0Reg.
	jump2 := self JumpNonZero: 0.
	self MoveR: ClassReg R: Extra0Reg.
	self LogicalShiftRightCq: 3 R: Extra0Reg.
	self CmpCq: 1 R: Extra0Reg.
	jump3 := self JumpBelowOrEqual: 0.
	self AddCq: 16r7000000000000000 R: Extra0Reg.
	jump4 := self Jump: 0.
	currentBlock := self Label.
	jump3 jmpTarget: currentBlock.
	currentBlock := self Label.
	jump4 jmpTarget: currentBlock.
	self MoveR: Extra0Reg R: ClassReg.
	self LogicalShiftLeftCq: 63 R: ClassReg.
	self LogicalShiftRightCq: 1 R: Extra0Reg.
	self AddR: Extra0Reg R: ClassReg.
	self MoveR: ClassReg Rd: DPFPReg0.
	jump4 := self Jump: 0.
	currentBlock := self Label.
	jump2 jmpTarget: currentBlock.
	self CmpCq: 1 R: Extra0Reg.
	jump2 := self JumpNonZero: 0.
	self MoveR: ClassReg R: Extra0Reg.
	self LogicalShiftLeftCq: 9 R: Extra0Reg.
	self ArithmeticShiftRightCq: 9 R: Extra0Reg.
	self CmpR: ClassReg R: Extra0Reg.
	jump3 := self JumpNonZero: 0.
	self ArithmeticShiftRightCq: 3 R: ClassReg.
	self ConvertR: ClassReg Rd: DPFPReg0.
	jump5 := self Jump: 0.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	self MoveM64: 0 r: ClassReg R: Extra0Reg.
	self AndCq: 16r3FFFFF R: Extra0Reg.
	self CmpCq: 34 R: Extra0Reg.
	jump1 := self JumpNonZero: 0.
	self MoveM64: 8 r: ClassReg Rd: DPFPReg0.
	currentBlock := self Label.
	jump4 jmpTarget: currentBlock.
	jump5 jmpTarget: currentBlock.
	self MoveR: SendNumArgsReg R: Extra0Reg.
	self AndCq: 7 R: Extra0Reg.
	self CmpCq: 0 R: Extra0Reg.
	jump5 := self JumpZero: 0.
	self CmpCq: 4 R: Extra0Reg.
	jump4 := self JumpNonZero: 0.
	self MoveR: SendNumArgsReg R: Extra0Reg.
	self LogicalShiftRightCq: 3 R: Extra0Reg.
	self CmpCq: 1 R: Extra0Reg.
	jump6 := self JumpBelowOrEqual: 0.
	self AddCq: 16r7000000000000000 R: Extra0Reg.
	jump7 := self Jump: 0.
	currentBlock := self Label.
	jump6 jmpTarget: currentBlock.
	currentBlock := self Label.
	jump7 jmpTarget: currentBlock.
	self MoveR: Extra0Reg R: SendNumArgsReg.
	self LogicalShiftLeftCq: 63 R: SendNumArgsReg.
	self LogicalShiftRightCq: 1 R: Extra0Reg.
	self AddR: Extra0Reg R: SendNumArgsReg.
	self MoveR: SendNumArgsReg Rd: DPFPReg1.
	jump7 := self Jump: 0.
	currentBlock := self Label.
	jump4 jmpTarget: currentBlock.
	self CmpCq: 1 R: Extra0Reg.
	jump4 := self JumpNonZero: 0.
	self MoveR: SendNumArgsReg R: Extra0Reg.
	self LogicalShiftLeftCq: 9 R: Extra0Reg.
	self ArithmeticShiftRightCq: 9 R: Extra0Reg.
	self CmpR: SendNumArgsReg R: Extra0Reg.
	jump6 := self JumpNonZero: 0.
	self ArithmeticShiftRightCq: 3 R: SendNumArgsReg.
	self ConvertR: SendNumArgsReg Rd: DPFPReg1.
	jump8 := self Jump: 0.
	currentBlock := self Label.
	jump5 jmpTarget: currentBlock.
	self MoveM64: 0 r: SendNumArgsReg R: Extra0Reg.
	self AndCq: 16r3FFFFF R: Extra0Reg.
	self CmpCq: 34 R: Extra0Reg.
	jump5 := self JumpNonZero: 0.
	self MoveM64: 8 r: SendNumArgsReg Rd: DPFPReg1.
	currentBlock := self Label.
	jump7 jmpTarget: currentBlock.
	jump8 jmpTarget: currentBlock.
	self CmpRd: DPFPReg1 Rd: DPFPReg0.
	jump8 := self JumpFPNotEqual: 0.
	s79 := objectMemory falseObject.
	self MoveCq: s79 R: Extra0Reg.
	jump7 := self Jump: 0.
	currentBlock := self Label.
	jump8 jmpTarget: currentBlock.
	s82 := objectMemory trueObject.
	self MoveCq: s82 R: Extra0Reg.
	currentBlock := self Label.
	jump7 jmpTarget: currentBlock.
	self MoveR: Extra0Reg R: ReceiverResultReg.
	self genPrimReturn.
	currentBlock := self Label.
	jump2 jmpTarget: currentBlock.
	jump3 jmpTarget: currentBlock.
	jump1 jmpTarget: currentBlock.
	jump4 jmpTarget: currentBlock.
	jump6 jmpTarget: currentBlock.
	jump5 jmpTarget: currentBlock.
	^ 0
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveFloatSubtract [
	"AutoGenerated by Druid"

	| jump1 s89 jumpNext jump9 jump6 jump3 currentBlock jump8 jump5 jump2 s121 jumpTrue s118 s93 jump7 jump4 |
	self MoveR: ReceiverResultReg R: ClassReg.
	self MoveR: Arg0Reg R: SendNumArgsReg.
	self MoveR: ClassReg R: Extra0Reg.
	self AndCq: 7 R: Extra0Reg.
	self CmpCq: 0 R: Extra0Reg.
	jump1 := self JumpZero: 0.
	self CmpCq: 4 R: Extra0Reg.
	jump2 := self JumpNonZero: 0.
	self MoveR: ClassReg R: Extra0Reg.
	self LogicalShiftRightCq: 3 R: Extra0Reg.
	self CmpCq: 1 R: Extra0Reg.
	jump3 := self JumpBelowOrEqual: 0.
	self AddCq: 16r7000000000000000 R: Extra0Reg.
	jump4 := self Jump: 0.
	currentBlock := self Label.
	jump3 jmpTarget: currentBlock.
	currentBlock := self Label.
	jump4 jmpTarget: currentBlock.
	self MoveR: Extra0Reg R: ClassReg.
	self LogicalShiftLeftCq: 63 R: ClassReg.
	self LogicalShiftRightCq: 1 R: Extra0Reg.
	self AddR: Extra0Reg R: ClassReg.
	self MoveR: ClassReg Rd: DPFPReg0.
	jump4 := self Jump: 0.
	currentBlock := self Label.
	jump2 jmpTarget: currentBlock.
	self CmpCq: 1 R: Extra0Reg.
	jump2 := self JumpNonZero: 0.
	self MoveR: ClassReg R: Extra0Reg.
	self LogicalShiftLeftCq: 9 R: Extra0Reg.
	self ArithmeticShiftRightCq: 9 R: Extra0Reg.
	self CmpR: ClassReg R: Extra0Reg.
	jump3 := self JumpNonZero: 0.
	self ArithmeticShiftRightCq: 3 R: ClassReg.
	self ConvertR: ClassReg Rd: DPFPReg0.
	jump5 := self Jump: 0.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	self MoveM64: 0 r: ClassReg R: Extra0Reg.
	self AndCq: 16r3FFFFF R: Extra0Reg.
	self CmpCq: 34 R: Extra0Reg.
	jump1 := self JumpNonZero: 0.
	self MoveM64: 8 r: ClassReg Rd: DPFPReg0.
	currentBlock := self Label.
	jump4 jmpTarget: currentBlock.
	jump5 jmpTarget: currentBlock.
	self MoveR: SendNumArgsReg R: Extra0Reg.
	self AndCq: 7 R: Extra0Reg.
	self CmpCq: 0 R: Extra0Reg.
	jump5 := self JumpZero: 0.
	self CmpCq: 4 R: Extra0Reg.
	jump4 := self JumpNonZero: 0.
	self MoveR: SendNumArgsReg R: Extra0Reg.
	self LogicalShiftRightCq: 3 R: Extra0Reg.
	self CmpCq: 1 R: Extra0Reg.
	jump6 := self JumpBelowOrEqual: 0.
	self AddCq: 16r7000000000000000 R: Extra0Reg.
	jump7 := self Jump: 0.
	currentBlock := self Label.
	jump6 jmpTarget: currentBlock.
	currentBlock := self Label.
	jump7 jmpTarget: currentBlock.
	self MoveR: Extra0Reg R: SendNumArgsReg.
	self LogicalShiftLeftCq: 63 R: SendNumArgsReg.
	self LogicalShiftRightCq: 1 R: Extra0Reg.
	self AddR: Extra0Reg R: SendNumArgsReg.
	self MoveR: SendNumArgsReg Rd: DPFPReg1.
	jump7 := self Jump: 0.
	currentBlock := self Label.
	jump4 jmpTarget: currentBlock.
	self CmpCq: 1 R: Extra0Reg.
	jump4 := self JumpNonZero: 0.
	self MoveR: SendNumArgsReg R: Extra0Reg.
	self LogicalShiftLeftCq: 9 R: Extra0Reg.
	self ArithmeticShiftRightCq: 9 R: Extra0Reg.
	self CmpR: SendNumArgsReg R: Extra0Reg.
	jump6 := self JumpNonZero: 0.
	self ArithmeticShiftRightCq: 3 R: SendNumArgsReg.
	self ConvertR: SendNumArgsReg Rd: DPFPReg1.
	jump8 := self Jump: 0.
	currentBlock := self Label.
	jump5 jmpTarget: currentBlock.
	self MoveM64: 0 r: SendNumArgsReg R: Extra0Reg.
	self AndCq: 16r3FFFFF R: Extra0Reg.
	self CmpCq: 34 R: Extra0Reg.
	jump5 := self JumpNonZero: 0.
	self MoveM64: 8 r: SendNumArgsReg Rd: DPFPReg1.
	currentBlock := self Label.
	jump7 jmpTarget: currentBlock.
	jump8 jmpTarget: currentBlock.
	self SubRd: DPFPReg1 Rd: DPFPReg0.
	self MoveRd: DPFPReg0 R: Extra0Reg.
	self MoveR: Extra0Reg R: SendNumArgsReg.
	self LogicalShiftRightCq: 52 R: SendNumArgsReg.
	self AndCq: 2047 R: SendNumArgsReg.
	self CmpCq: 896 R: SendNumArgsReg.
	jump8 := self JumpBelowOrEqual: 0.
	self CmpCq: 1151 R: SendNumArgsReg.
	jumpTrue := self JumpBelowOrEqual: 0.
	self MoveCq: 0 R: SendNumArgsReg.
	jumpNext := self Jump: 0.
	jumpTrue jmpTarget: self Label.
	self MoveCq: 1 R: SendNumArgsReg.
	jumpNext jmpTarget: self Label.
	jump7 := self Jump: 0.
	currentBlock := self Label.
	jump8 jmpTarget: currentBlock.
	self AndCq: 16rFFFFFFFFFFFFF R: Extra0Reg.
	self CmpCq: 0 R: Extra0Reg.
	jump8 := self JumpNonZero: 0.
	s89 := 0.
	self CmpCq: s89 R: SendNumArgsReg.
	jumpTrue := self JumpZero: 0.
	self MoveCq: 0 R: SendNumArgsReg.
	jumpNext := self Jump: 0.
	jumpTrue jmpTarget: self Label.
	self MoveCq: 1 R: SendNumArgsReg.
	jumpNext jmpTarget: self Label.
	jump9 := self Jump: 0.
	currentBlock := self Label.
	jump8 jmpTarget: currentBlock.
	s93 := 896.
	self CmpCq: s93 R: SendNumArgsReg.
	jumpTrue := self JumpZero: 0.
	self MoveCq: 0 R: SendNumArgsReg.
	jumpNext := self Jump: 0.
	jumpTrue jmpTarget: self Label.
	self MoveCq: 1 R: SendNumArgsReg.
	jumpNext jmpTarget: self Label.
	currentBlock := self Label.
	jump9 jmpTarget: currentBlock.
	currentBlock := self Label.
	jump7 jmpTarget: currentBlock.
	self CmpCq: 1 R: SendNumArgsReg.
	jump7 := self JumpNonZero: 0.
	self MoveRd: DPFPReg0 R: SendNumArgsReg.
	self RotateLeftCq: 1 R: SendNumArgsReg.
	self CmpCq: 1 R: SendNumArgsReg.
	jump9 := self JumpBelowOrEqual: 0.
	self SubCq: 16r7000000000000000 R: SendNumArgsReg.
	jump8 := self Jump: 0.
	currentBlock := self Label.
	jump9 jmpTarget: currentBlock.
	currentBlock := self Label.
	jump8 jmpTarget: currentBlock.
	self LogicalShiftLeftCq: 3 R: SendNumArgsReg.
	self AddCq: 4 R: SendNumArgsReg.
	jump8 := self Jump: 0.
	currentBlock := self Label.
	jump7 jmpTarget: currentBlock.
	self MoveAw: objectMemory freeStartAddress R: SendNumArgsReg.
	self MoveAw: objectMemory freeStartAddress R: Extra0Reg.
	self AddCq: 16 R: Extra0Reg.
	s118 := objectMemory getScavengeThreshold.
	self CmpCq: s118 R: Extra0Reg.
	jump7 := self JumpAbove: 0.
	s121 := 72057594205700130.
	self MoveCq: s121 R: Extra0Reg.
	self MoveR: Extra0Reg M64: 0 r: SendNumArgsReg.
	self MoveAw: objectMemory freeStartAddress R: Extra0Reg.
	self AddCq: 16 R: Extra0Reg.
	self MoveR: Extra0Reg Aw: objectMemory freeStartAddress.
	self MoveRd: DPFPReg0 M64: 8 r: SendNumArgsReg.
	currentBlock := self Label.
	jump8 jmpTarget: currentBlock.
	self MoveR: SendNumArgsReg R: ReceiverResultReg.
	self genPrimReturn.
	currentBlock := self Label.
	jump2 jmpTarget: currentBlock.
	jump3 jmpTarget: currentBlock.
	jump1 jmpTarget: currentBlock.
	jump4 jmpTarget: currentBlock.
	jump6 jmpTarget: currentBlock.
	jump5 jmpTarget: currentBlock.
	jump7 jmpTarget: currentBlock.
	^ 0
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveFullClosureValue [
	"AutoGenerated by Druid"

	| s23 s44 s2 currentBlock s22 s43 s3 |
	s2 := self methodNumArgs.
	s2 = 0 ifTrue: [
		| jump1 jump2 jump3 jump4 |
		self MoveR: ReceiverResultReg R: ClassReg.
		self MoveM64: 24 r: ClassReg R: SendNumArgsReg.
		self ArithmeticShiftRightCq: 3 R: SendNumArgsReg.
		self CmpCq: 0 R: SendNumArgsReg.
		jump1 := self JumpNonZero: 0.
		self MoveM64: 16 r: ClassReg R: SendNumArgsReg.
		self MoveR: SendNumArgsReg R: ClassReg.
		self AndCq: 7 R: ClassReg.
		self CmpCq: 0 R: ClassReg.
		jump2 := self JumpNonZero: 0.
		self MoveM64: 0 r: SendNumArgsReg R: ClassReg.
		self LogicalShiftRightCq: 24 R: ClassReg.
		self AndCq: 31 R: ClassReg.
		self CmpCq: 24 R: ClassReg.
		jump3 := self JumpBelow: 0.
		self MoveM64: 8 r: SendNumArgsReg R: ClassReg.
		self AndCq: 1 R: ClassReg.
		self CmpCq: 0 R: ClassReg.
		jump4 := self JumpNonZero: 0.
		self MoveM64: 8 r: SendNumArgsReg R: ClassReg.
		self AddCq: self fullBlockEntryOffset R: ClassReg.
		self JumpR: ClassReg.
		self genPrimReturn.
		currentBlock := self Label.
		jump1 jmpTarget: currentBlock.
		jump2 jmpTarget: currentBlock.
		jump3 jmpTarget: currentBlock.
		jump4 jmpTarget: currentBlock.
		^ 0 ].
	s22 := self methodNumArgs.
	s22 = 1 ifTrue: [
		| jump4 jump3 jump2 jump1 |
		self MoveR: ReceiverResultReg R: ClassReg.
		self MoveR: Arg0Reg R: SendNumArgsReg.
		self MoveM64: 24 r: ClassReg R: SendNumArgsReg.
		self ArithmeticShiftRightCq: 3 R: SendNumArgsReg.
		self CmpCq: 1 R: SendNumArgsReg.
		jump4 := self JumpNonZero: 0.
		self MoveM64: 16 r: ClassReg R: SendNumArgsReg.
		self MoveR: SendNumArgsReg R: ClassReg.
		self AndCq: 7 R: ClassReg.
		self CmpCq: 0 R: ClassReg.
		jump3 := self JumpNonZero: 0.
		self MoveM64: 0 r: SendNumArgsReg R: ClassReg.
		self LogicalShiftRightCq: 24 R: ClassReg.
		self AndCq: 31 R: ClassReg.
		self CmpCq: 24 R: ClassReg.
		jump2 := self JumpBelow: 0.
		self MoveM64: 8 r: SendNumArgsReg R: ClassReg.
		self AndCq: 1 R: ClassReg.
		self CmpCq: 0 R: ClassReg.
		jump1 := self JumpNonZero: 0.
		self MoveM64: 8 r: SendNumArgsReg R: ClassReg.
		self AddCq: self fullBlockEntryOffset R: ClassReg.
		self JumpR: ClassReg.
		self genPrimReturn.
		currentBlock := self Label.
		jump4 jmpTarget: currentBlock.
		jump3 jmpTarget: currentBlock.
		jump2 jmpTarget: currentBlock.
		jump1 jmpTarget: currentBlock.
		^ 0 ].
	s43 := self methodNumArgs.
	s43 = 2 ifTrue: [
		| jump1 jump2 jump3 jump4 |
		self MoveR: ReceiverResultReg R: ClassReg.
		self MoveR: Arg0Reg R: SendNumArgsReg.
		self MoveR: Arg1Reg R: SendNumArgsReg.
		self MoveM64: 24 r: ClassReg R: SendNumArgsReg.
		self ArithmeticShiftRightCq: 3 R: SendNumArgsReg.
		self CmpCq: 2 R: SendNumArgsReg.
		jump1 := self JumpNonZero: 0.
		self MoveM64: 16 r: ClassReg R: SendNumArgsReg.
		self MoveR: SendNumArgsReg R: ClassReg.
		self AndCq: 7 R: ClassReg.
		self CmpCq: 0 R: ClassReg.
		jump2 := self JumpNonZero: 0.
		self MoveM64: 0 r: SendNumArgsReg R: ClassReg.
		self LogicalShiftRightCq: 24 R: ClassReg.
		self AndCq: 31 R: ClassReg.
		self CmpCq: 24 R: ClassReg.
		jump3 := self JumpBelow: 0.
		self MoveM64: 8 r: SendNumArgsReg R: ClassReg.
		self AndCq: 1 R: ClassReg.
		self CmpCq: 0 R: ClassReg.
		jump4 := self JumpNonZero: 0.
		self MoveM64: 8 r: SendNumArgsReg R: ClassReg.
		self AddCq: self fullBlockEntryOffset R: ClassReg.
		self JumpR: ClassReg.
		self genPrimReturn.
		currentBlock := self Label.
		jump1 jmpTarget: currentBlock.
		jump2 jmpTarget: currentBlock.
		jump3 jmpTarget: currentBlock.
		jump4 jmpTarget: currentBlock.
		^ 0 ].
	^ 0
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveGreaterOrEqualThanArgument [
	"AutoGenerated by Druid"

	| jumpNext currentBlock jumpTrue |
	self MoveR: Arg0Reg R: ClassReg.
	self CmpCq: 0 R: ClassReg.
	jumpTrue := self JumpGreaterOrEqual: 0.
	self MoveCq: 0 R: ClassReg.
	jumpNext := self Jump: 0.
	jumpTrue jmpTarget: self Label.
	self MoveCq: 1 R: ClassReg.
	jumpNext jmpTarget: self Label.
	self MoveR: ClassReg R: ReceiverResultReg.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveGreaterOrEqualThanValue [
	"AutoGenerated by Druid"

	| jumpNext currentBlock jumpTrue |
	self MoveR: ReceiverResultReg R: ClassReg.
	self CmpCq: 0 R: ClassReg.
	jumpTrue := self JumpGreaterOrEqual: 0.
	self MoveCq: 0 R: ClassReg.
	jumpNext := self Jump: 0.
	jumpTrue jmpTarget: self Label.
	self MoveCq: 1 R: ClassReg.
	jumpNext jmpTarget: self Label.
	self MoveR: ClassReg R: ReceiverResultReg.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveGreaterOrEqualsThan [
	"AutoGenerated by Druid"

	| jump1 s4 currentBlock s7 jump2 |
	self MoveR: ReceiverResultReg R: ClassReg.
	self CmpCq: 10 R: ClassReg.
	jump1 := self JumpLess: 0.
	s4 := 5.
	self MoveCq: s4 R: ClassReg.
	jump2 := self Jump: 0.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	s7 := 11.
	self MoveCq: s7 R: ClassReg.
	currentBlock := self Label.
	jump2 jmpTarget: currentBlock.
	self MoveR: ClassReg R: ReceiverResultReg.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveGreaterOrEqualsThanFloats [
	"AutoGenerated by Druid"

	| jumpNext currentBlock jumpTrue |
	self MoveR: ReceiverResultReg R: ClassReg.
	self MoveR: Arg0Reg R: SendNumArgsReg.
	self ConvertR: SendNumArgsReg Rd: DPFPReg0.
	self ConvertR: ClassReg Rd: DPFPReg1.
	self CmpRd: DPFPReg1 Rd: DPFPReg0.
	jumpTrue := self JumpFPGreaterOrEqual: 0.
	self MoveCq: 0 R: ClassReg.
	jumpNext := self Jump: 0.
	jumpTrue jmpTarget: self Label.
	self MoveCq: 1 R: ClassReg.
	jumpNext jmpTarget: self Label.
	self MoveR: ClassReg R: ReceiverResultReg.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveGreaterOrEqualsThanInverted [
	"AutoGenerated by Druid"

	| jump1 s4 currentBlock s7 jump2 |
	self MoveR: ReceiverResultReg R: ClassReg.
	self CmpCq: 10 R: ClassReg.
	jump1 := self JumpGreater: 0.
	s4 := 5.
	self MoveCq: s4 R: ClassReg.
	jump2 := self Jump: 0.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	s7 := 11.
	self MoveCq: s7 R: ClassReg.
	currentBlock := self Label.
	jump2 jmpTarget: currentBlock.
	self MoveR: ClassReg R: ReceiverResultReg.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveGreaterThan [
	"AutoGenerated by Druid"

	| jump1 s4 currentBlock s7 jump2 |
	self MoveR: ReceiverResultReg R: ClassReg.
	self CmpCq: 10 R: ClassReg.
	jump1 := self JumpLessOrEqual: 0.
	s4 := 5.
	self MoveCq: s4 R: ClassReg.
	jump2 := self Jump: 0.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	s7 := 11.
	self MoveCq: s7 R: ClassReg.
	currentBlock := self Label.
	jump2 jmpTarget: currentBlock.
	self MoveR: ClassReg R: ReceiverResultReg.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveGreaterThanArgument [
	"AutoGenerated by Druid"

	| jumpNext currentBlock jumpTrue |
	self MoveR: Arg0Reg R: ClassReg.
	self CmpCq: 0 R: ClassReg.
	jumpTrue := self JumpGreater: 0.
	self MoveCq: 0 R: ClassReg.
	jumpNext := self Jump: 0.
	jumpTrue jmpTarget: self Label.
	self MoveCq: 1 R: ClassReg.
	jumpNext jmpTarget: self Label.
	self MoveR: ClassReg R: ReceiverResultReg.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveGreaterThanBitAnd [
	"AutoGenerated by Druid"

	| s8 jump1 currentBlock jump2 s5 |
	self MoveR: ReceiverResultReg R: ClassReg.
	self AndCq: 16rFFFFFFFFFFFFFFFF R: ClassReg.
	self CmpCq: 1 R: ClassReg.
	jump1 := self JumpBelowOrEqual: 0.
	s5 := 1.
	self MoveCq: s5 R: ClassReg.
	jump2 := self Jump: 0.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	s8 := 2.
	self MoveCq: s8 R: ClassReg.
	currentBlock := self Label.
	jump2 jmpTarget: currentBlock.
	self MoveR: ClassReg R: ReceiverResultReg.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveGreaterThanFloats [
	"AutoGenerated by Druid"

	| jumpNext currentBlock jumpTrue |
	self MoveR: ReceiverResultReg R: ClassReg.
	self MoveR: Arg0Reg R: SendNumArgsReg.
	self ConvertR: SendNumArgsReg Rd: DPFPReg0.
	self ConvertR: ClassReg Rd: DPFPReg1.
	self CmpRd: DPFPReg1 Rd: DPFPReg0.
	jumpTrue := self JumpFPGreater: 0.
	self MoveCq: 0 R: ClassReg.
	jumpNext := self Jump: 0.
	jumpTrue jmpTarget: self Label.
	self MoveCq: 1 R: ClassReg.
	jumpNext jmpTarget: self Label.
	self MoveR: ClassReg R: ReceiverResultReg.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveGreaterThanInverted [
	"AutoGenerated by Druid"

	| jump1 s4 currentBlock s7 jump2 |
	self MoveR: ReceiverResultReg R: ClassReg.
	self CmpCq: 10 R: ClassReg.
	jump1 := self JumpGreaterOrEqual: 0.
	s4 := 5.
	self MoveCq: s4 R: ClassReg.
	jump2 := self Jump: 0.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	s7 := 11.
	self MoveCq: s7 R: ClassReg.
	currentBlock := self Label.
	jump2 jmpTarget: currentBlock.
	self MoveR: ClassReg R: ReceiverResultReg.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveGreaterThanReferenceValue [
	"AutoGenerated by Druid"

	| jumpTrue jumpNext currentBlock s3 |
	self MoveR: ReceiverResultReg R: ClassReg.
	s3 := objectMemory trueObject.
	self CmpCq: s3 R: ClassReg.
	jumpTrue := self JumpAbove: 0.
	self MoveCq: 0 R: ClassReg.
	jumpNext := self Jump: 0.
	jumpTrue jmpTarget: self Label.
	self MoveCq: 1 R: ClassReg.
	jumpNext jmpTarget: self Label.
	self MoveR: ClassReg R: ReceiverResultReg.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveIdentityHash [
	"AutoGenerated by Druid"

	| jump3 jump1 currentBlock jump4 jump2 |
	self MoveR: ReceiverResultReg R: ClassReg.
	self TstCq: 7 R: ClassReg.
	jump1 := self JumpNonZero: 0.
	self MoveM64: 0 r: ClassReg R: SendNumArgsReg.
	self AndCq: 16r3FFFF7 R: SendNumArgsReg.
	self CmpCq: 0 R: SendNumArgsReg.
	jump2 := self JumpZero: 0.
	self MoveM32: 4 r: ClassReg R: SendNumArgsReg.
	self AndCq: 16rFFFFFFFF R: SendNumArgsReg.
	self AndCq: 16r3FFFFF R: SendNumArgsReg.
	self CmpCq: 0 R: SendNumArgsReg.
	jump3 := self JumpNonZero: 0.
	self MoveR: ClassReg R: TempReg.
	backEnd saveAndRestoreLinkRegAround: [ self CallRT: ceNewHashTrampoline ].
	self MoveR: TempReg R: SendNumArgsReg.
	jump4 := self Jump: 0.
	currentBlock := self Label.
	jump3 jmpTarget: currentBlock.
	currentBlock := self Label.
	jump4 jmpTarget: currentBlock.
	self LogicalShiftLeftCq: 3 R: SendNumArgsReg.
	self AddCq: 1 R: SendNumArgsReg.
	self MoveR: SendNumArgsReg R: ReceiverResultReg.
	self genPrimReturn.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	jump2 jmpTarget: currentBlock.
	^ 0
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveIfFalseIfTrueReturningValue [
	"AutoGenerated by Druid"

	| jump1 s4 currentBlock s7 jump2 |
	self MoveR: ReceiverResultReg R: ClassReg.
	self CmpCq: 0 R: ClassReg.
	jump1 := self JumpNonZero: 0.
	s4 := 42.
	self MoveCq: s4 R: ClassReg.
	jump2 := self Jump: 0.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	s7 := 57.
	self MoveCq: s7 R: ClassReg.
	currentBlock := self Label.
	jump2 jmpTarget: currentBlock.
	self MoveR: ClassReg R: ReceiverResultReg.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveIfTrueIfFalseAssigningValue [
	"AutoGenerated by Druid"

	| jump1 s4 currentBlock s7 jump2 |
	self MoveR: ReceiverResultReg R: ClassReg.
	self CmpCq: 0 R: ClassReg.
	jump1 := self JumpNonZero: 0.
	s4 := 42.
	self MoveCq: s4 R: ClassReg.
	jump2 := self Jump: 0.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	s7 := 57.
	self MoveCq: s7 R: ClassReg.
	currentBlock := self Label.
	jump2 jmpTarget: currentBlock.
	self MoveR: ClassReg R: ReceiverResultReg.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveIfTrueIfFalseReturningValue [
	"AutoGenerated by Druid"

	| jump1 s4 currentBlock s7 jump2 |
	self MoveR: ReceiverResultReg R: ClassReg.
	self CmpCq: 0 R: ClassReg.
	jump1 := self JumpNonZero: 0.
	s4 := 42.
	self MoveCq: s4 R: ClassReg.
	jump2 := self Jump: 0.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	s7 := 57.
	self MoveCq: s7 R: ClassReg.
	currentBlock := self Label.
	jump2 jmpTarget: currentBlock.
	self MoveR: ClassReg R: ReceiverResultReg.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveIfTrueStatement [
	"AutoGenerated by Druid"

	| jump1 currentBlock jump2 s5 s3 |
	self MoveR: ReceiverResultReg R: ClassReg.
	s3 := 10.
	self CmpCq: 0 R: ClassReg.
	jump1 := self JumpNonZero: 0.
	s5 := 42.
	self MoveCq: s5 R: ClassReg.
	jump2 := self Jump: 0.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	self MoveCq: s3 R: ClassReg.
	currentBlock := self Label.
	jump2 jmpTarget: currentBlock.
	self MoveR: ClassReg R: ReceiverResultReg.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveImmediateAsInteger [
	"AutoGenerated by Druid"

	| s59 s21 s40 s2 s24 currentBlock s56 s41 s3 |
	s2 := self methodNumArgs.
	s2 = 0 ifTrue: [
		| jump5 jump3 jump1 jump4 jump2 |
		self MoveR: ReceiverResultReg R: ClassReg.
		self TstCq: 1 R: ClassReg.
		jump1 := self JumpZero: 0.
		self ArithmeticShiftRightCq: 3 R: ClassReg.
		self LogicalShiftLeftCq: 3 R: ClassReg.
		self AddCq: 1 R: ClassReg.
		jump2 := self Jump: 0.
		currentBlock := self Label.
		jump1 jmpTarget: currentBlock.
		self TstCq: 2 R: ClassReg.
		jump1 := self JumpZero: 0.
		self LogicalShiftRightCq: 3 R: ClassReg.
		jump3 := self Jump: 0.
		currentBlock := self Label.
		jump1 jmpTarget: currentBlock.
		self TstCq: 4 R: ClassReg.
		jump1 := self JumpZero: 0.
		self MoveR: ClassReg R: SendNumArgsReg.
		self LogicalShiftRightCq: 4 R: SendNumArgsReg.
		self TstCq: 8 R: ClassReg.
		jump4 := self JumpZero: 0.
		s21 :=  -1152921504606846976.
		self MoveCq: s21 R: ClassReg.
		jump5 := self Jump: 0.
		currentBlock := self Label.
		jump4 jmpTarget: currentBlock.
		s24 := 0.
		self MoveCq: s24 R: ClassReg.
		currentBlock := self Label.
		jump5 jmpTarget: currentBlock.
		self AddR: ClassReg R: SendNumArgsReg.
		self MoveR: SendNumArgsReg R: ClassReg.
		currentBlock := self Label.
		jump3 jmpTarget: currentBlock.
		self LogicalShiftLeftCq: 3 R: ClassReg.
		self AddCq: 1 R: ClassReg.
		currentBlock := self Label.
		jump2 jmpTarget: currentBlock.
		self MoveR: ClassReg R: ReceiverResultReg.
		self genPrimReturn.
		currentBlock := self Label.
		jump1 jmpTarget: currentBlock.
		^ 0 ].
	s40 := self methodNumArgs.
	s40 = 1 ifTrue: [
		| jump5 jump3 jump1 jump4 jump2 |
		self MoveR: Arg0Reg R: ClassReg.
		self TstCq: 1 R: ClassReg.
		jump1 := self JumpZero: 0.
		self ArithmeticShiftRightCq: 3 R: ClassReg.
		jump2 := self Jump: 0.
		currentBlock := self Label.
		jump1 jmpTarget: currentBlock.
		self TstCq: 2 R: ClassReg.
		jump1 := self JumpZero: 0.
		self LogicalShiftRightCq: 3 R: ClassReg.
		jump3 := self Jump: 0.
		currentBlock := self Label.
		jump1 jmpTarget: currentBlock.
		self TstCq: 4 R: ClassReg.
		jump1 := self JumpZero: 0.
		self MoveR: ClassReg R: SendNumArgsReg.
		self LogicalShiftRightCq: 4 R: SendNumArgsReg.
		self TstCq: 8 R: ClassReg.
		jump5 := self JumpZero: 0.
		s56 :=  -1152921504606846976.
		self MoveCq: s56 R: ClassReg.
		jump4 := self Jump: 0.
		currentBlock := self Label.
		jump5 jmpTarget: currentBlock.
		s59 := 0.
		self MoveCq: s59 R: ClassReg.
		currentBlock := self Label.
		jump4 jmpTarget: currentBlock.
		self AddR: ClassReg R: SendNumArgsReg.
		self MoveR: SendNumArgsReg R: ClassReg.
		currentBlock := self Label.
		jump3 jmpTarget: currentBlock.
		currentBlock := self Label.
		jump2 jmpTarget: currentBlock.
		self LogicalShiftLeftCq: 3 R: ClassReg.
		self AddCq: 1 R: ClassReg.
		self MoveR: ClassReg R: ReceiverResultReg.
		self genPrimReturn.
		currentBlock := self Label.
		jump1 jmpTarget: currentBlock.
		^ 0 ].
	^ 0
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveImplicitArgumentBitShiftLeft [
	"AutoGenerated by Druid"

	| jump1 s4 s10 currentBlock jump2 |
	self MoveR: ReceiverResultReg R: ClassReg.
	self CmpCq: 0 R: ClassReg.
	jump1 := self JumpLessOrEqual: 0.
	s4 := 1.
	self MoveCq: s4 R: SendNumArgsReg.
	self LogicalShiftLeftR: ClassReg R: SendNumArgsReg.
	jump2 := self Jump: 0.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	self MoveR: ClassReg R: SendNumArgsReg.
	self NegateR: SendNumArgsReg.
	s10 := 1.
	self MoveCq: s10 R: ClassReg.
	self LogicalShiftRightR: SendNumArgsReg R: ClassReg.
	self MoveR: ClassReg R: SendNumArgsReg.
	currentBlock := self Label.
	jump2 jmpTarget: currentBlock.
	self MoveR: SendNumArgsReg R: ReceiverResultReg.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveImplicitBitShiftLeft [
	"AutoGenerated by Druid"

	| currentBlock |
	self MoveR: ReceiverResultReg R: ClassReg.
	self LogicalShiftLeftCq: 1 R: ClassReg.
	self MoveR: ClassReg R: ReceiverResultReg.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveImplicitBitShiftRight [
	"AutoGenerated by Druid"

	| currentBlock |
	self MoveR: ReceiverResultReg R: ClassReg.
	self LogicalShiftRightCq: 1 R: ClassReg.
	self MoveR: ClassReg R: ReceiverResultReg.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveIncrement [

	| currentBlock |
	self MoveR: ReceiverResultReg R: TempReg.
	self AddCq: 1 R: TempReg.
	self MoveR: TempReg R: ReceiverResultReg.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveIncrementConstantArgument [
	"AutoGenerated by Druid"

	| currentBlock |
	self MoveR: ReceiverResultReg R: ClassReg.
	self AddCq: 1 R: ClassReg.
	self MoveR: ClassReg R: ReceiverResultReg.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveIncrementConstantReceiver [
	"AutoGenerated by Druid"

	| currentBlock |
	self MoveR: ReceiverResultReg R: ClassReg.
	self AddCq: 1 R: ClassReg.
	self MoveR: ClassReg R: ReceiverResultReg.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveIntegerAsFloat [
	"AutoGenerated by Druid"

	| currentBlock |
	self MoveR: ReceiverResultReg R: ClassReg.
	self ConvertR: ClassReg Rd: DPFPReg0.
	self MoveRd: DPFPReg0 R: ClassReg.
	self MoveR: ClassReg R: ReceiverResultReg.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveIntegerDivide [
	"AutoGenerated by Druid"

	| currentBlock |
	self MoveR: ReceiverResultReg R: ClassReg.
	self MoveR: Arg0Reg R: SendNumArgsReg.
	self
		DivR: SendNumArgsReg
		R: ClassReg
		Quo: ClassReg
		Rem: SendNumArgsReg.
	self MoveR: ClassReg R: ReceiverResultReg.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveIntegerDivideByConstant [
	"AutoGenerated by Druid"

	| currentBlock s3 |
	self MoveR: ReceiverResultReg R: ClassReg.
	s3 := 2.
	self MoveCq: s3 R: SendNumArgsReg.
	self
		DivR: SendNumArgsReg
		R: ClassReg
		Quo: ClassReg
		Rem: SendNumArgsReg.
	self MoveR: ClassReg R: ReceiverResultReg.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveIntegerRawBitsAsFloat [
	"AutoGenerated by Druid"

	| currentBlock |
	self MoveR: ReceiverResultReg R: ClassReg.
	self MoveR: ClassReg Rd: DPFPReg0.
	self ConvertRd: DPFPReg0 R: ClassReg.
	self MoveR: ClassReg R: ReceiverResultReg.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveIsIntegerObject [
	"AutoGenerated by Druid"

	| jump1 s4 currentBlock s7 jump2 |
	self MoveR: ReceiverResultReg R: ClassReg.
	self TstCq: 1 R: ClassReg.
	jump1 := self JumpZero: 0.
	s4 := objectMemory trueObject.
	self MoveCq: s4 R: ClassReg.
	jump2 := self Jump: 0.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	s7 := objectMemory falseObject.
	self MoveCq: s7 R: ClassReg.
	currentBlock := self Label.
	jump2 jmpTarget: currentBlock.
	self MoveR: ClassReg R: ReceiverResultReg.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveJITCompileTimeExpression [
	"AutoGenerated by Druid"

	| s3 currentBlock s2 |
	s2 := objectMemory trueObject.
	s3 := s2 + 5.
	self MoveCq: s3 R: ReceiverResultReg.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveLessOrEqualThanArgument [
	"AutoGenerated by Druid"

	| jumpNext currentBlock jumpTrue |
	self MoveR: Arg0Reg R: ClassReg.
	self CmpCq: 0 R: ClassReg.
	jumpTrue := self JumpLessOrEqual: 0.
	self MoveCq: 0 R: ClassReg.
	jumpNext := self Jump: 0.
	jumpTrue jmpTarget: self Label.
	self MoveCq: 1 R: ClassReg.
	jumpNext jmpTarget: self Label.
	self MoveR: ClassReg R: ReceiverResultReg.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveLessOrEqualThanValue [
	"AutoGenerated by Druid"

	| jumpNext currentBlock jumpTrue |
	self MoveR: ReceiverResultReg R: ClassReg.
	self CmpCq: 0 R: ClassReg.
	jumpTrue := self JumpLessOrEqual: 0.
	self MoveCq: 0 R: ClassReg.
	jumpNext := self Jump: 0.
	jumpTrue jmpTarget: self Label.
	self MoveCq: 1 R: ClassReg.
	jumpNext jmpTarget: self Label.
	self MoveR: ClassReg R: ReceiverResultReg.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveLessOrEqualsThan [
	"AutoGenerated by Druid"

	| jump1 s4 currentBlock s7 jump2 |
	self MoveR: ReceiverResultReg R: ClassReg.
	self CmpCq: 10 R: ClassReg.
	jump1 := self JumpGreater: 0.
	s4 := 5.
	self MoveCq: s4 R: ClassReg.
	jump2 := self Jump: 0.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	s7 := 11.
	self MoveCq: s7 R: ClassReg.
	currentBlock := self Label.
	jump2 jmpTarget: currentBlock.
	self MoveR: ClassReg R: ReceiverResultReg.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveLessOrEqualsThanFloats [
	"AutoGenerated by Druid"

	| jumpNext currentBlock jumpTrue |
	self MoveR: ReceiverResultReg R: ClassReg.
	self MoveR: Arg0Reg R: SendNumArgsReg.
	self ConvertR: SendNumArgsReg Rd: DPFPReg0.
	self ConvertR: ClassReg Rd: DPFPReg1.
	self CmpRd: DPFPReg1 Rd: DPFPReg0.
	jumpTrue := self JumpFPLessOrEqual: 0.
	self MoveCq: 0 R: ClassReg.
	jumpNext := self Jump: 0.
	jumpTrue jmpTarget: self Label.
	self MoveCq: 1 R: ClassReg.
	jumpNext jmpTarget: self Label.
	self MoveR: ClassReg R: ReceiverResultReg.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveLessOrEqualsThanInverted [
	"AutoGenerated by Druid"

	| jump1 s4 currentBlock s7 jump2 |
	self MoveR: ReceiverResultReg R: ClassReg.
	self CmpCq: 10 R: ClassReg.
	jump1 := self JumpLess: 0.
	s4 := 5.
	self MoveCq: s4 R: ClassReg.
	jump2 := self Jump: 0.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	s7 := 11.
	self MoveCq: s7 R: ClassReg.
	currentBlock := self Label.
	jump2 jmpTarget: currentBlock.
	self MoveR: ClassReg R: ReceiverResultReg.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveLessThan [
	"AutoGenerated by Druid"

	| jump1 s4 currentBlock s7 jump2 |
	self MoveR: ReceiverResultReg R: ClassReg.
	self CmpCq: 10 R: ClassReg.
	jump1 := self JumpGreaterOrEqual: 0.
	s4 := 5.
	self MoveCq: s4 R: ClassReg.
	jump2 := self Jump: 0.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	s7 := 11.
	self MoveCq: s7 R: ClassReg.
	currentBlock := self Label.
	jump2 jmpTarget: currentBlock.
	self MoveR: ClassReg R: ReceiverResultReg.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveLessThanArgument [
	"AutoGenerated by Druid"

	| jumpNext currentBlock jumpTrue |
	self MoveR: Arg0Reg R: ClassReg.
	self CmpCq: 0 R: ClassReg.
	jumpTrue := self JumpLess: 0.
	self MoveCq: 0 R: ClassReg.
	jumpNext := self Jump: 0.
	jumpTrue jmpTarget: self Label.
	self MoveCq: 1 R: ClassReg.
	jumpNext jmpTarget: self Label.
	self MoveR: ClassReg R: ReceiverResultReg.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveLessThanFloats [
	"AutoGenerated by Druid"

	| jumpNext currentBlock jumpTrue |
	self MoveR: ReceiverResultReg R: ClassReg.
	self MoveR: Arg0Reg R: SendNumArgsReg.
	self ConvertR: SendNumArgsReg Rd: DPFPReg0.
	self ConvertR: ClassReg Rd: DPFPReg1.
	self CmpRd: DPFPReg1 Rd: DPFPReg0.
	jumpTrue := self JumpFPLess: 0.
	self MoveCq: 0 R: ClassReg.
	jumpNext := self Jump: 0.
	jumpTrue jmpTarget: self Label.
	self MoveCq: 1 R: ClassReg.
	jumpNext jmpTarget: self Label.
	self MoveR: ClassReg R: ReceiverResultReg.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveLessThanInverted [
	"AutoGenerated by Druid"

	| jump1 s4 currentBlock s7 jump2 |
	self MoveR: ReceiverResultReg R: ClassReg.
	self CmpCq: 10 R: ClassReg.
	jump1 := self JumpLessOrEqual: 0.
	s4 := 5.
	self MoveCq: s4 R: ClassReg.
	jump2 := self Jump: 0.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	s7 := 11.
	self MoveCq: s7 R: ClassReg.
	currentBlock := self Label.
	jump2 jmpTarget: currentBlock.
	self MoveR: ClassReg R: ReceiverResultReg.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveLessThanThanInverted [

	| currentBlock jump0 jump1 |
	self MoveCq: true asBit R: TempReg.
	self MoveCq: 10 R: ClassReg.
	self CmpCq: 10 R: ReceiverResultReg.
	jump0 := self JumpLess: 0.
	self MoveCq: 5 R: Extra0Reg.
	self MoveCq: 5 R: Extra1Reg.
	self MoveR: Extra1Reg R: ClassReg.
	self MoveR: ReceiverResultReg R: SendNumArgsReg.
	jump1 := self Jump: 0.
	currentBlock := self Label.
	jump0 jmpTarget: currentBlock.
	self MoveCq: 11 R: Extra2Reg.
	self MoveCq: 11 R: TempReg.
	self MoveR: TempReg R: ClassReg.
	self MoveR: ReceiverResultReg R: SendNumArgsReg.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	self MoveCq: 1 R: Extra0Reg.
	self MoveR: ClassReg R: ReceiverResultReg.
	self RetN: 1 * objectMemory wordSize.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveLessThanValue [
	"AutoGenerated by Druid"

	| jumpNext currentBlock jumpTrue |
	self MoveR: ReceiverResultReg R: ClassReg.
	self CmpCq: 0 R: ClassReg.
	jumpTrue := self JumpLess: 0.
	self MoveCq: 0 R: ClassReg.
	jumpNext := self Jump: 0.
	jumpTrue jmpTarget: self Label.
	self MoveCq: 1 R: ClassReg.
	jumpNext jmpTarget: self Label.
	self MoveR: ClassReg R: ReceiverResultReg.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveLogicalBitShiftRight [
	"AutoGenerated by Druid"

	| currentBlock |
	self MoveR: ReceiverResultReg R: ClassReg.
	self MoveR: Arg0Reg R: SendNumArgsReg.
	self LogicalShiftRightR: SendNumArgsReg R: ClassReg.
	self MoveR: ClassReg R: ReceiverResultReg.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveLoopIncrementing [
	"AutoGenerated by Druid"

	| b17 s6 s2 currentBlock s7 s3 |
	s2 := 10.
	s3 := s2.
	b17 := self Label.
	s6 := s3 + 1.
	[ ((s6<15)) ] whileTrue: [ s3 := s6 ].
	self MoveCq: s6 R: ReceiverResultReg.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveLoopIncrementingGlobalState [
	"AutoGenerated by Druid"

	| s6 s2 currentBlock s7 b16 s3 |
	s2 := 10.
	s3 := s2.
	b16 := self Label.
	s6 := s3 + 1.
	[ ((s6<15)) ] whileTrue: [ s3 := s6 ].
	self MoveCq: s6 R: ReceiverResultReg.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveLoopWithInvariant [

	| jump1 currentBlock b14 |
	self MoveCq: 0 R: TempReg.
	self MoveR: ReceiverResultReg R: ClassReg.
	b14 := self Label.
	self MoveCq: 1 R: SendNumArgsReg.
	self MoveR: ClassReg R: Extra0Reg.
	self MulR: SendNumArgsReg R: Extra0Reg.
	self MoveR: TempReg R: SendNumArgsReg.
	self AddR: Extra0Reg R: SendNumArgsReg.
	self CmpCq: 15 R: SendNumArgsReg.
	jump1 := self JumpLess: 0.
	self MoveR: SendNumArgsReg R: ReceiverResultReg.
	self genPrimReturn.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	self MoveR: SendNumArgsReg R: TempReg.
	jump1 := self Jump: b14.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveMod [
	"AutoGenerated by Druid"

	| currentBlock |
	self MoveR: ReceiverResultReg R: ClassReg.
	self MoveR: Arg0Reg R: SendNumArgsReg.
	self
		DivR: SendNumArgsReg
		R: ClassReg
		Quo: SendNumArgsReg
		Rem: ClassReg.
	self MoveR: ClassReg R: ReceiverResultReg.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveModByConstant [
	"AutoGenerated by Druid"

	| currentBlock s3 |
	self MoveR: ReceiverResultReg R: ClassReg.
	s3 := 2.
	self MoveCq: s3 R: SendNumArgsReg.
	self
		DivR: SendNumArgsReg
		R: ClassReg
		Quo: SendNumArgsReg
		Rem: ClassReg.
	self MoveR: ClassReg R: ReceiverResultReg.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveMultiply [

	| currentBlock |
	self MoveR: ReceiverResultReg R: TempReg.
	self MoveR: TempReg R: ReceiverResultReg.
	self MulR: ReceiverResultReg R: TempReg.
	self MoveR: TempReg R: ReceiverResultReg.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveMultiplyConstantArgument [
	"AutoGenerated by Druid"

	| currentBlock |
	self MoveR: ReceiverResultReg R: ClassReg.
	self LogicalShiftLeftCq: 1 R: ClassReg.
	self MoveR: ClassReg R: ReceiverResultReg.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveMultiplyConstantReceiver [
	"AutoGenerated by Druid"

	| currentBlock s3 |
	self MoveR: ReceiverResultReg R: ClassReg.
	s3 := 2.
	self MoveCq: s3 R: SendNumArgsReg.
	self MulR: ClassReg R: SendNumArgsReg.
	self MoveR: SendNumArgsReg R: ReceiverResultReg.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveMultiplyInverted [

	| currentBlock |
	self MoveCq: 2 R: TempReg.
	self MoveR: TempReg Cq: 2.
	self MulCq: 2 R: TempReg.
	self MoveR: TempReg R: ReceiverResultReg.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveMultiplyWithOverflow [
	"AutoGenerated by Druid"

	| jump1 jump2 currentBlock s8 |
	self MoveR: ReceiverResultReg R: ClassReg.
	self MoveR: Arg0Reg R: SendNumArgsReg.
	self ArithmeticShiftRightCq: 3 R: ClassReg.
	self SubCq: 1 R: SendNumArgsReg.
	self MulR: ClassReg R: SendNumArgsReg.
	jump1 := self JumpMultiplyNoOverflow: 0.
	s8 := 99.
	self MoveCq: s8 R: SendNumArgsReg.
	jump2 := self Jump: 0.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	self AddCq: 1 R: SendNumArgsReg.
	currentBlock := self Label.
	jump2 jmpTarget: currentBlock.
	self MoveR: SendNumArgsReg R: ReceiverResultReg.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveNegated [
	"AutoGenerated by Druid"

	| currentBlock |
	self MoveR: ReceiverResultReg R: ClassReg.
	self MoveR: ClassReg R: ClassReg.
	self NegateR: ClassReg.
	self MoveR: ClassReg R: ReceiverResultReg.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveNew [
	"AutoGenerated by Druid"

	| jump1 s28 jump6 jump3 b349 currentBlock jump8 jump5 jump2 s17 jump7 jump4 |
	self SubCq: 16 R: SPReg.
	self MoveR: ReceiverResultReg R: Extra3Reg.
	self MoveR: Extra3Reg Mw: 0 r: SPReg.
	self MoveMw: 0 r: SPReg R: Extra3Reg.
	self MoveM64: 24 r: Extra3Reg R: Extra3Reg.
	self MoveR: Extra3Reg Mw: 8 r: SPReg.
	self MoveMw: 8 r: SPReg R: Extra3Reg.
	self ArithmeticShiftRightCq: 3 R: Extra3Reg.
	self MoveR: Extra3Reg Mw: 8 r: SPReg.
	self MoveMw: 8 r: SPReg R: Extra3Reg.
	self MoveR: Extra3Reg R: Extra0Reg.
	self LogicalShiftRightCq: 16 R: Extra0Reg.
	self AndCq: 31 R: Extra0Reg.
	self CmpCq: 1 R: Extra0Reg.
	jump1 := self JumpBelowOrEqual: 0.
	self CmpCq: 5 R: Extra0Reg.
	jump2 := self JumpNonZero: 0.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	self MoveMw: 0 r: SPReg R: Extra3Reg.
	self MoveM32: 4 r: Extra3Reg R: Extra1Reg.
	self AndCq: 16rFFFFFFFF R: Extra1Reg.
	self AndCq: 16r3FFFFF R: Extra1Reg.
	self CmpCq: 0 R: Extra1Reg.
	jump1 := self JumpZero: 0.
	self CmpCq: 0 R: Extra1Reg.
	jump3 := self JumpBelow: 0.
	self MoveMw: 8 r: SPReg R: Extra3Reg.
	self AndCq: 16rFFFF R: Extra3Reg.
	self MoveR: Extra3Reg Mw: 8 r: SPReg.
	self MoveMw: 8 r: SPReg R: Extra3Reg.
	self CmpCq: 255 R: Extra3Reg.
	jump4 := self JumpAboveOrEqual: 0.
	self MoveMw: 8 r: SPReg R: Extra3Reg.
	self CmpCq: 1 R: Extra3Reg.
	jump5 := self JumpAboveOrEqual: 0.
	s17 := 8.
	self MoveCq: s17 R: Extra2Reg.
	jump6 := self Jump: 0.
	currentBlock := self Label.
	jump5 jmpTarget: currentBlock.
	self MoveMw: 8 r: SPReg R: Extra3Reg.
	self MoveR: Extra3Reg R: Extra2Reg.
	self LogicalShiftLeftCq: 3 R: Extra2Reg.
	currentBlock := self Label.
	jump6 jmpTarget: currentBlock.
	self AddCq: 8 R: Extra2Reg.
	self MoveAw: objectMemory freeStartAddress R: ClassReg.
	self AddR: Extra2Reg R: ClassReg.
	s28 := objectMemory getScavengeThreshold.
	self CmpCq: s28 R: ClassReg.
	jump6 := self JumpBelowOrEqual: 0.
	self CmpCq: s28 R: ClassReg.
	jump5 := self JumpAbove: 0.
	self MoveAw: objectMemory freeStartAddress R: ClassReg.
	jump7 := self Jump: 0.
	currentBlock := self Label.
	jump6 jmpTarget: currentBlock.
	self MoveAw: objectMemory freeStartAddress R: ClassReg.
	currentBlock := self Label.
	jump7 jmpTarget: currentBlock.
	self MoveMw: 8 r: SPReg R: Extra3Reg.
	self MoveR: Extra3Reg R: SendNumArgsReg.
	self LogicalShiftLeftCq: 56 R: SendNumArgsReg.
	self LogicalShiftLeftCq: 24 R: Extra0Reg.
	self AddR: Extra0Reg R: SendNumArgsReg.
	self AddR: Extra1Reg R: SendNumArgsReg.
	self OrCq: 0 R: SendNumArgsReg.
	self MoveR: SendNumArgsReg M64: 0 r: ClassReg.
	self MoveAw: objectMemory freeStartAddress R: SendNumArgsReg.
	self AddR: Extra2Reg R: SendNumArgsReg.
	self MoveR: SendNumArgsReg Aw: objectMemory freeStartAddress.
	self CmpCq: 0 R: ClassReg.
	jump7 := self JumpNonZero: 0.
	self MoveMw: 0 r: SPReg R: Extra3Reg.
	self MoveR: Extra3Reg R: SendNumArgsReg.
	jump6 := self Jump: 0.
	currentBlock := self Label.
	jump7 jmpTarget: currentBlock.
	self genMoveConstant: objectMemory nilObject R: SendNumArgsReg.
	self MoveR: ClassReg R: Extra2Reg.
	self AddCq: 8 R: Extra2Reg.
	self MoveMw: 8 r: SPReg R: Extra3Reg.
	self LogicalShiftLeftCq: 3 R: Extra3Reg.
	self MoveR: Extra3Reg Mw: 8 r: SPReg.
	self MoveR: ClassReg R: Extra1Reg.
	self MoveMw: 8 r: SPReg R: Extra3Reg.
	self AddR: Extra3Reg R: Extra1Reg.
	self AddCq: 8 R: Extra1Reg.
	self SubCq: 1 R: Extra1Reg.
	b349 := self Label.
	self CmpR: Extra2Reg R: Extra1Reg.
	jump7 := self JumpLess: 0.
	self MoveR: SendNumArgsReg M64: 0 r: Extra2Reg.
	self MoveR: Extra2Reg R: Extra0Reg.
	self AddCq: 8 R: Extra0Reg.
	self MoveR: Extra0Reg R: Extra2Reg.
	jump8 := self Jump: b349.
	currentBlock := self Label.
	jump7 jmpTarget: currentBlock.
	self MoveR: ClassReg R: ReceiverResultReg.
	self AddCq: 16 R: SPReg.
	self genPrimReturn.
	currentBlock := self Label.
	jump2 jmpTarget: currentBlock.
	self MoveMw: 0 r: SPReg R: Extra3Reg.
	self MoveR: Extra3Reg R: SendNumArgsReg.
	currentBlock := self Label.
	jump6 jmpTarget: currentBlock.
	self MoveR: SendNumArgsReg R: ReceiverResultReg.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	jump3 jmpTarget: currentBlock.
	jump4 jmpTarget: currentBlock.
	jump5 jmpTarget: currentBlock.
	self AddCq: 16 R: SPReg.
	^ 0
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveNewWithArg [
	"AutoGenerated by Druid"

	| jump5 jump10 s94 s55 jump3 b690 jump8 jump1 s36 currentBlock s101 s58 jump13 jump6 s73 s82 s47 jump11 jump4 s78 s168 jump9 jump2 s85 s157 s98 jump7 jump12 |
	self SubCq: 32 R: SPReg.
	self MoveR: ReceiverResultReg R: Extra3Reg.
	self MoveR: Extra3Reg Mw: 0 r: SPReg.
	self MoveR: Arg0Reg R: SendNumArgsReg.
	self TstCq: 1 R: SendNumArgsReg.
	jump1 := self JumpZero: 0.
	self ArithmeticShiftRightCq: 3 R: SendNumArgsReg.
	self CmpCq: 0 R: SendNumArgsReg.
	jump2 := self JumpLess: 0.
	self MoveMw: 0 r: SPReg R: Extra3Reg.
	self MoveM64: 24 r: Extra3Reg R: Extra0Reg.
	self ArithmeticShiftRightCq: 3 R: Extra0Reg.
	self MoveR: Extra0Reg R: Extra1Reg.
	self LogicalShiftRightCq: 16 R: Extra1Reg.
	self AndCq: 31 R: Extra1Reg.
	self MoveMw: 0 r: SPReg R: Extra3Reg.
	self MoveM32: 4 r: Extra3Reg R: Extra3Reg.
	self AndCq: 16rFFFFFFFF R: Extra3Reg.
	self MoveR: Extra3Reg Mw: 8 r: SPReg.
	self MoveMw: 8 r: SPReg R: Extra3Reg.
	self AndCq: 16r3FFFFF R: Extra3Reg.
	self MoveR: Extra3Reg Mw: 8 r: SPReg.
	self CmpCq: 2 R: Extra1Reg.
	jump3 := self JumpNonZero: 0.
	self genMoveConstant: objectMemory nilObject R: Extra0Reg.
	self MoveR: Extra0Reg R: ClassReg.
	jump4 := self Jump: 0.
	currentBlock := self Label.
	jump3 jmpTarget: currentBlock.
	self CmpCq: 3 R: Extra1Reg.
	jump3 := self JumpNonZero: 0.
	self AndCq: 16rFFFF R: Extra0Reg.
	self AddR: SendNumArgsReg R: Extra0Reg.
	self genMoveConstant: objectMemory nilObject R: ClassReg.
	self MoveR: Extra0Reg R: SendNumArgsReg.
	jump5 := self Jump: 0.
	currentBlock := self Label.
	jump3 jmpTarget: currentBlock.
	self CmpCq: 4 R: Extra1Reg.
	jump3 := self JumpNonZero: 0.
	self AndCq: 16rFFFF R: Extra0Reg.
	self AddR: SendNumArgsReg R: Extra0Reg.
	self genMoveConstant: objectMemory nilObject R: ClassReg.
	self MoveR: Extra0Reg R: SendNumArgsReg.
	jump6 := self Jump: 0.
	currentBlock := self Label.
	jump3 jmpTarget: currentBlock.
	s36 := 0.
	self CmpCq: 9 R: Extra1Reg.
	jump3 := self JumpNonZero: 0.
	self MoveCq: s36 R: ClassReg.
	jump7 := self Jump: 0.
	currentBlock := self Label.
	jump3 jmpTarget: currentBlock.
	self CmpCq: 10 R: Extra1Reg.
	jump3 := self JumpNonZero: 0.
	self MoveMw: 8 r: SPReg R: Extra3Reg.
	self CmpCq: 34 R: Extra3Reg.
	jump8 := self JumpNonZero: 0.
	self CmpCq: 2 R: SendNumArgsReg.
	jump9 := self JumpNonZero: 0.
	self MoveR: SendNumArgsReg R: ClassReg.
	self AddCq: 1 R: ClassReg.
	s47 := 2.
	self MoveCq: s47 R: Extra0Reg.
	self
		DivR: Extra0Reg
		R: ClassReg
		Quo: Extra0Reg
		Rem: ClassReg.
	self AndCq: 1 R: SendNumArgsReg.
	self AddR: SendNumArgsReg R: Extra1Reg.
	self MoveR: Extra0Reg R: ClassReg.
	jump10 := self Jump: 0.
	currentBlock := self Label.
	jump8 jmpTarget: currentBlock.
	s55 := 0.
	self MoveR: SendNumArgsReg R: ClassReg.
	self AddCq: 1 R: ClassReg.
	s58 := 2.
	self MoveCq: s58 R: Extra0Reg.
	self
		DivR: Extra0Reg
		R: ClassReg
		Quo: ClassReg
		Rem: Extra0Reg.
	self AndCq: 1 R: SendNumArgsReg.
	self AddR: SendNumArgsReg R: Extra1Reg.
	self MoveMw: 8 r: SPReg R: Extra3Reg.
	self CmpCq: 0 R: Extra3Reg.
	jump8 := self JumpNonZero: 0.
	self MoveCq: s55 R: Extra0Reg.
	jump11 := self Jump: 0.
	currentBlock := self Label.
	jump8 jmpTarget: currentBlock.
	currentBlock := self Label.
	jump10 jmpTarget: currentBlock.
	s73 := 0.
	self MoveCq: s73 R: Extra0Reg.
	jump10 := self Jump: 0.
	currentBlock := self Label.
	jump3 jmpTarget: currentBlock.
	s78 := 0.
	self CmpCq: 12 R: Extra1Reg.
	jump3 := self JumpNonZero: 0.
	self MoveR: SendNumArgsReg R: ClassReg.
	self AddCq: 3 R: ClassReg.
	s82 := 4.
	self MoveCq: s82 R: Extra0Reg.
	self
		DivR: Extra0Reg
		R: ClassReg
		Quo: Extra2Reg
		Rem: Extra0Reg.
	s85 := 4.
	self MoveCq: s85 R: Extra0Reg.
	self SubR: SendNumArgsReg R: Extra0Reg.
	self AndCq: 3 R: Extra0Reg.
	self AddR: Extra0Reg R: Extra1Reg.
	self MoveCq: s78 R: ClassReg.
	self MoveR: Extra2Reg R: SendNumArgsReg.
	jump8 := self Jump: 0.
	currentBlock := self Label.
	jump3 jmpTarget: currentBlock.
	s94 := 0.
	self CmpCq: 16 R: Extra1Reg.
	jump3 := self JumpNonZero: 0.
	self MoveR: SendNumArgsReg R: Extra0Reg.
	self AddCq: 7 R: Extra0Reg.
	s98 := 8.
	self MoveCq: s98 R: Extra2Reg.
	self
		DivR: Extra2Reg
		R: Extra0Reg
		Quo: Extra0Reg
		Rem: Extra2Reg.
	s101 := 8.
	self MoveCq: s101 R: Extra2Reg.
	self SubR: SendNumArgsReg R: Extra2Reg.
	self AndCq: 7 R: Extra2Reg.
	self AddR: Extra2Reg R: Extra1Reg.
	self MoveCq: s94 R: ClassReg.
	self MoveR: Extra0Reg R: SendNumArgsReg.
	jump12 := self Jump: 0.
	currentBlock := self Label.
	jump3 jmpTarget: currentBlock.
	self CmpCq: 0 R: SendNumArgsReg.
	jump3 := self JumpNonZero: 0.
	self CmpCq: 5 R: Extra1Reg.
	jump13 := self JumpAbove: 0.
	self AndCq: 16rFFFF R: Extra0Reg.
	self genMoveConstant: objectMemory nilObject R: Extra2Reg.
	self MoveR: Extra2Reg R: ClassReg.
	self MoveR: Extra0Reg R: SendNumArgsReg.
	currentBlock := self Label.
	jump4 jmpTarget: currentBlock.
	jump5 jmpTarget: currentBlock.
	jump6 jmpTarget: currentBlock.
	jump7 jmpTarget: currentBlock.
	jump8 jmpTarget: currentBlock.
	jump12 jmpTarget: currentBlock.
	self MoveMw: 8 r: SPReg R: Extra3Reg.
	self CmpCq: 0 R: Extra3Reg.
	jump12 := self JumpNonZero: 0.
	self MoveR: ClassReg R: Extra0Reg.
	self MoveR: SendNumArgsReg R: ClassReg.
	currentBlock := self Label.
	jump11 jmpTarget: currentBlock.
	self MoveMw: 0 r: SPReg R: Extra3Reg.
	self MoveM32: 4 r: Extra3Reg R: Extra2Reg.
	self AndCq: 16rFFFFFFFF R: Extra2Reg.
	self AndCq: 16r3FFFFF R: Extra2Reg.
	self CmpCq: 0 R: Extra2Reg.
	jump11 := self JumpZero: 0.
	self CmpCq: 0 R: Extra2Reg.
	jump8 := self JumpBelow: 0.
	self MoveR: Extra0Reg R: Extra3Reg.
	self MoveR: Extra3Reg Mw: 16 r: SPReg.
	self MoveR: ClassReg R: Extra3Reg.
	self MoveR: Extra3Reg Mw: 24 r: SPReg.
	jump7 := self Jump: 0.
	currentBlock := self Label.
	jump12 jmpTarget: currentBlock.
	self MoveR: ClassReg R: Extra0Reg.
	self MoveR: SendNumArgsReg R: ClassReg.
	currentBlock := self Label.
	jump10 jmpTarget: currentBlock.
	self MoveR: Extra0Reg R: Extra3Reg.
	self MoveR: Extra3Reg Mw: 16 r: SPReg.
	self MoveR: ClassReg R: Extra3Reg.
	self MoveR: Extra3Reg Mw: 24 r: SPReg.
	self MoveMw: 8 r: SPReg R: Extra3Reg.
	self MoveR: Extra3Reg R: Extra2Reg.
	currentBlock := self Label.
	jump7 jmpTarget: currentBlock.
	self MoveMw: 24 r: SPReg R: Extra3Reg.
	self CmpCq: 16rFFFF R: Extra3Reg.
	jump7 := self JumpAbove: 0.
	self MoveMw: 24 r: SPReg R: Extra3Reg.
	self CmpCq: 255 R: Extra3Reg.
	jump10 := self JumpAboveOrEqual: 0.
	self MoveMw: 24 r: SPReg R: Extra3Reg.
	self CmpCq: 1 R: Extra3Reg.
	jump12 := self JumpAboveOrEqual: 0.
	s157 := 8.
	self MoveCq: s157 R: SendNumArgsReg.
	jump6 := self Jump: 0.
	currentBlock := self Label.
	jump12 jmpTarget: currentBlock.
	self MoveMw: 24 r: SPReg R: Extra3Reg.
	self MoveR: Extra3Reg R: SendNumArgsReg.
	self LogicalShiftLeftCq: 3 R: SendNumArgsReg.
	currentBlock := self Label.
	jump6 jmpTarget: currentBlock.
	self AddCq: 8 R: SendNumArgsReg.
	self MoveAw: objectMemory freeStartAddress R: Extra0Reg.
	self AddR: SendNumArgsReg R: Extra0Reg.
	s168 := objectMemory getScavengeThreshold.
	self CmpCq: s168 R: Extra0Reg.
	jump6 := self JumpBelowOrEqual: 0.
	self CmpCq: s168 R: Extra0Reg.
	jump12 := self JumpAbove: 0.
	currentBlock := self Label.
	jump6 jmpTarget: currentBlock.
	self MoveAw: objectMemory freeStartAddress R: Extra0Reg.
	self MoveMw: 24 r: SPReg R: Extra3Reg.
	self MoveR: Extra3Reg R: ClassReg.
	self LogicalShiftLeftCq: 56 R: ClassReg.
	self LogicalShiftLeftCq: 24 R: Extra1Reg.
	self AddR: Extra1Reg R: ClassReg.
	self AddR: Extra2Reg R: ClassReg.
	self OrCq: 0 R: ClassReg.
	self MoveR: ClassReg M64: 0 r: Extra0Reg.
	self MoveAw: objectMemory freeStartAddress R: ClassReg.
	self AddR: SendNumArgsReg R: ClassReg.
	self MoveR: ClassReg Aw: objectMemory freeStartAddress.
	self MoveR: Extra0Reg R: ClassReg.
	self AddCq: 8 R: ClassReg.
	self MoveMw: 24 r: SPReg R: Extra3Reg.
	self LogicalShiftLeftCq: 3 R: Extra3Reg.
	self MoveR: Extra3Reg Mw: 24 r: SPReg.
	self MoveR: Extra0Reg R: SendNumArgsReg.
	self MoveMw: 24 r: SPReg R: Extra3Reg.
	self AddR: Extra3Reg R: SendNumArgsReg.
	self AddCq: 8 R: SendNumArgsReg.
	self SubCq: 1 R: SendNumArgsReg.
	b690 := self Label.
	self CmpR: ClassReg R: SendNumArgsReg.
	jump6 := self JumpLess: 0.
	self MoveMw: 16 r: SPReg R: Extra3Reg.
	self MoveR: Extra3Reg M64: 0 r: ClassReg.
	self MoveR: ClassReg R: Extra2Reg.
	self AddCq: 8 R: Extra2Reg.
	self MoveR: Extra2Reg R: ClassReg.
	jump5 := self Jump: b690.
	currentBlock := self Label.
	jump6 jmpTarget: currentBlock.
	self MoveR: Extra0Reg R: ReceiverResultReg.
	self AddCq: 32 R: SPReg.
	self genPrimReturn.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	jump2 jmpTarget: currentBlock.
	jump9 jmpTarget: currentBlock.
	jump3 jmpTarget: currentBlock.
	jump13 jmpTarget: currentBlock.
	jump11 jmpTarget: currentBlock.
	jump8 jmpTarget: currentBlock.
	jump7 jmpTarget: currentBlock.
	jump10 jmpTarget: currentBlock.
	jump12 jmpTarget: currentBlock.
	self AddCq: 32 R: SPReg.
	^ 0
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveNextUint16At [
	"AutoGenerated by Druid"

	| currentBlock |
	self MoveM16: 1 r: ReceiverResultReg R: TempReg.
	self AndCq: 16rFFFF R: TempReg.
	self MoveR: TempReg R: ReceiverResultReg.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveNoopLoopWithInvariant [
	"AutoGenerated by Druid"

	| s8 jump1 jump3 currentBlock b18 jump2 s3 |
	self MoveR: ReceiverResultReg R: ClassReg.
	s3 := 3.
	self CmpCq: 10 R: ClassReg.
	jump1 := self JumpGreaterOrEqual: 0.
	b18 := self Label.
	s8 := 5.
	self MoveR: ClassReg R: SendNumArgsReg.
	self AddCq: 1 R: SendNumArgsReg.
	self CmpCq: 10 R: SendNumArgsReg.
	jump2 := self JumpGreaterOrEqual: 0.
	self MoveR: SendNumArgsReg R: ClassReg.
	jump3 := self Jump: b18.
	currentBlock := self Label.
	jump2 jmpTarget: currentBlock.
	self MoveCq: s8 R: SendNumArgsReg.
	jump2 := self Jump: 0.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	self MoveCq: s3 R: SendNumArgsReg.
	currentBlock := self Label.
	jump2 jmpTarget: currentBlock.
	self MoveR: SendNumArgsReg R: ReceiverResultReg.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveNotEqualsThan [
	"AutoGenerated by Druid"

	| jump1 s4 currentBlock s7 jump2 |
	self MoveR: ReceiverResultReg R: ClassReg.
	self CmpCq: 10 R: ClassReg.
	jump1 := self JumpZero: 0.
	s4 := 5.
	self MoveCq: s4 R: ClassReg.
	jump2 := self Jump: 0.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	s7 := 11.
	self MoveCq: s7 R: ClassReg.
	currentBlock := self Label.
	jump2 jmpTarget: currentBlock.
	self MoveR: ClassReg R: ReceiverResultReg.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveNotEqualsThanFloats [
	"AutoGenerated by Druid"

	| jumpNext currentBlock jumpTrue |
	self MoveR: ReceiverResultReg R: ClassReg.
	self MoveR: Arg0Reg R: SendNumArgsReg.
	self ConvertR: SendNumArgsReg Rd: DPFPReg0.
	self ConvertR: ClassReg Rd: DPFPReg1.
	self CmpRd: DPFPReg1 Rd: DPFPReg0.
	jumpTrue := self JumpFPNotEqual: 0.
	self MoveCq: 0 R: ClassReg.
	jumpNext := self Jump: 0.
	jumpTrue jmpTarget: self Label.
	self MoveCq: 1 R: ClassReg.
	jumpNext jmpTarget: self Label.
	self MoveR: ClassReg R: ReceiverResultReg.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveNotEqualsThanInverted [
	"AutoGenerated by Druid"

	| jump1 s4 currentBlock s7 jump2 |
	self MoveR: ReceiverResultReg R: ClassReg.
	self CmpCq: 10 R: ClassReg.
	jump1 := self JumpZero: 0.
	s4 := 5.
	self MoveCq: s4 R: ClassReg.
	jump2 := self Jump: 0.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	s7 := 11.
	self MoveCq: s7 R: ClassReg.
	currentBlock := self Label.
	jump2 jmpTarget: currentBlock.
	self MoveR: ClassReg R: ReceiverResultReg.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveOr [
	"AutoGenerated by Druid"

	| s8 jump1 currentBlock jump2 s5 |
	self MoveR: ReceiverResultReg R: ClassReg.
	self CmpCq: 5 R: ClassReg.
	jump1 := self JumpLess: 0.
	self CmpCq: 10 R: ClassReg.
	jump2 := self JumpLessOrEqual: 0.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	s5 := 42.
	self MoveCq: s5 R: ClassReg.
	jump1 := self Jump: 0.
	currentBlock := self Label.
	jump2 jmpTarget: currentBlock.
	s8 := 10.
	self MoveCq: s8 R: ClassReg.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	self MoveR: ClassReg R: ReceiverResultReg.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitivePlusFloatConstant [
	"AutoGenerated by Druid"

	| currentBlock |
	self MoveR: ReceiverResultReg R: ClassReg.
	self ConvertR: ClassReg Rd: DPFPReg0.
	self MoveCq: (objectMemory rawFloatBitsOf: 3.14) R: ClassReg.
	self MoveR: ClassReg Rd: DPFPReg1.
	self AddRd: DPFPReg1 Rd: DPFPReg0.
	self MoveRd: DPFPReg0 R: ClassReg.
	self MoveR: ClassReg R: ReceiverResultReg.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitivePushFirstArgument [
	"AutoGenerated by Druid"

	| currentBlock |
	self MoveR: Arg0Reg R: ClassReg.
	self MoveR: ClassReg R: ReceiverResultReg.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitivePushReceiverOf0ArgSelector [
	"AutoGenerated by Druid"

	| currentBlock |
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitivePushReceiverOf1ArgSelector [
	"AutoGenerated by Druid"

	| currentBlock |
	self MoveR: Arg0Reg R: ClassReg.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitivePushStackValue0 [
	"AutoGenerated by Druid"

	| currentBlock |
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitivePushStackValue0WithOneArgument [
	"AutoGenerated by Druid"

	| currentBlock |
	self MoveR: Arg0Reg R: ReceiverResultReg.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitivePushStackValue1 [
	"AutoGenerated by Druid"

	| currentBlock |
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveReturnFalse [
	"AutoGenerated by Druid"

	| currentBlock s2 |
	s2 := objectMemory falseObject.
	self MoveCq: s2 R: ReceiverResultReg.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveReturnOne [
	"AutoGenerated by Druid"

	| currentBlock |
	self MoveCq: 1 R: ReceiverResultReg.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveReturnOneWithArguments [
	"AutoGenerated by Druid"

	| currentBlock |
	self MoveR: Arg0Reg R: ClassReg.
	self MoveR: Arg1Reg R: ClassReg.
	self MoveCq: 1 R: ReceiverResultReg.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveReturnTrue [
	"AutoGenerated by Druid"

	| currentBlock s2 |
	s2 := objectMemory trueObject.
	self MoveCq: s2 R: ReceiverResultReg.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveRotateLeft [
	"AutoGenerated by Druid"

	| currentBlock |
	self MoveR: ReceiverResultReg R: ClassReg.
	self RotateLeftCq: 1 R: ClassReg.
	self MoveR: ClassReg R: ReceiverResultReg.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveRotateLeftDoesNotBehavesLikeShift [
	"AutoGenerated by Druid"

	| currentBlock |
	self MoveR: ReceiverResultReg R: ClassReg.
	self RotateLeftCq: 1 R: ClassReg.
	self MoveR: ClassReg R: ReceiverResultReg.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveSandclock [
	"AutoGenerated by Druid"

	| s16 s4 s12 currentBlock jump1 s7 jump2 |
	self MoveR: ReceiverResultReg R: ClassReg.
	self CmpCq: 10 R: ClassReg.
	jump1 := self JumpLessOrEqual: 0.
	s4 := 1.
	self MoveCq: s4 R: ClassReg.
	jump2 := self Jump: 0.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	s7 := 99.
	self CmpCq: 0 R: ClassReg.
	jump1 := self JumpLessOrEqual: 0.
	self MoveCq: s7 R: ClassReg.
	currentBlock := self Label.
	jump2 jmpTarget: currentBlock.
	s12 := 5.
	self MoveCq: s12 R: SendNumArgsReg.
	jump2 := self Jump: 0.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	s16 := 17.
	self MoveCq: s16 R: SendNumArgsReg.
	self MoveCq: s7 R: ClassReg.
	currentBlock := self Label.
	jump2 jmpTarget: currentBlock.
	self AddR: SendNumArgsReg R: ClassReg.
	self MoveR: ClassReg R: ReceiverResultReg.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveSize [
	"AutoGenerated by Druid"

	| jump1 jumpNext jump6 jump3 s131 currentBlock s113 jump8 jump5 jumpTrue s107 jump2 s14 jump7 jump4 |
	self MoveR: ReceiverResultReg R: ClassReg.
	self MoveR: ClassReg R: Extra1Reg.
	self CmpCq: 7 R: Extra1Reg.
	jumpTrue := self JumpNonZero: 0.
	self MoveCq: 0 R: Extra1Reg.
	jumpNext := self Jump: 0.
	jumpTrue jmpTarget: self Label.
	self MoveCq: 1 R: Extra1Reg.
	jumpNext jmpTarget: self Label.
	self TstCq: 7 R: ClassReg.
	jump1 := self JumpZero: 0.
	jump2 := self Jump: 0.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	self MoveM64: 0 r: ClassReg R: Extra1Reg.
	self AndCq: 16r3FFFF7 R: Extra1Reg.
	s14 := 0.
	self MoveR: Extra1Reg R: Extra2Reg.
	self CmpCq: s14 R: Extra2Reg.
	jumpTrue := self JumpZero: 0.
	self MoveCq: 0 R: Extra2Reg.
	jumpNext := self Jump: 0.
	jumpTrue jmpTarget: self Label.
	self MoveCq: 1 R: Extra2Reg.
	jumpNext jmpTarget: self Label.
	self CmpCq: 0 R: Extra1Reg.
	jump1 := self JumpNonZero: 0.
	jump3 := self Jump: 0.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	self MoveM64: 0 r: ClassReg R: SendNumArgsReg.
	self MoveR: SendNumArgsReg R: Extra0Reg.
	self LogicalShiftRightCq: 24 R: Extra0Reg.
	self AndCq: 31 R: Extra0Reg.
	self MoveR: Extra0Reg R: Extra2Reg.
	self CmpCq: 2 R: Extra2Reg.
	jumpTrue := self JumpBelow: 0.
	self MoveCq: 0 R: Extra2Reg.
	jumpNext := self Jump: 0.
	jumpTrue jmpTarget: self Label.
	self MoveCq: 1 R: Extra2Reg.
	jumpNext jmpTarget: self Label.
	currentBlock := self Label.
	jump3 jmpTarget: currentBlock.
	self MoveR: Extra2Reg R: Extra1Reg.
	currentBlock := self Label.
	jump2 jmpTarget: currentBlock.
	self CmpCq: 1 R: Extra1Reg.
	jump2 := self JumpZero: 0.
	self CmpCq: 3 R: Extra0Reg.
	jump3 := self JumpNonZero: 0.
	self AndCq: 16r3FFFFF R: SendNumArgsReg.
	self CmpCq: 36 R: SendNumArgsReg.
	jump1 := self JumpZero: 0.
	self MoveMb: 7 r: ClassReg R: Extra2Reg.
	self AndCq: 255 R: Extra2Reg.
	self CmpCq: 255 R: Extra2Reg.
	jump4 := self JumpNonZero: 0.
	self MoveM64: -8 r: ClassReg R: Extra2Reg.
	self LogicalShiftLeftCq: 8 R: Extra2Reg.
	self LogicalShiftRightCq: 8 R: Extra2Reg.
	jump5 := self Jump: 0.
	currentBlock := self Label.
	jump4 jmpTarget: currentBlock.
	jump4 := self Jump: 0.
	currentBlock := self Label.
	jump3 jmpTarget: currentBlock.
	self MoveMb: 7 r: ClassReg R: Extra2Reg.
	self AndCq: 255 R: Extra2Reg.
	self CmpCq: 255 R: Extra2Reg.
	jump3 := self JumpNonZero: 0.
	self MoveM64: -8 r: ClassReg R: Extra2Reg.
	self LogicalShiftLeftCq: 8 R: Extra2Reg.
	self LogicalShiftRightCq: 8 R: Extra2Reg.
	self CmpCq: 5 R: Extra0Reg.
	jump6 := self JumpAbove: 0.
	currentBlock := self Label.
	jump5 jmpTarget: currentBlock.
	jump5 := self Jump: 0.
	currentBlock := self Label.
	jump6 jmpTarget: currentBlock.
	jump6 := self Jump: 0.
	currentBlock := self Label.
	jump3 jmpTarget: currentBlock.
	self CmpCq: 5 R: Extra0Reg.
	jump3 := self JumpAbove: 0.
	currentBlock := self Label.
	jump4 jmpTarget: currentBlock.
	currentBlock := self Label.
	jump5 jmpTarget: currentBlock.
	jump5 := self Jump: 0.
	currentBlock := self Label.
	jump3 jmpTarget: currentBlock.
	currentBlock := self Label.
	jump6 jmpTarget: currentBlock.
	self CmpCq: 16 R: Extra0Reg.
	jump6 := self JumpBelow: 0.
	self LogicalShiftLeftCq: 3 R: Extra2Reg.
	self MoveR: Extra0Reg R: SendNumArgsReg.
	self AndCq: 7 R: SendNumArgsReg.
	self SubR: SendNumArgsReg R: Extra2Reg.
	jump3 := self Jump: 0.
	currentBlock := self Label.
	jump6 jmpTarget: currentBlock.
	self CmpCq: 12 R: Extra0Reg.
	jump6 := self JumpBelow: 0.
	self LogicalShiftLeftCq: 2 R: Extra2Reg.
	self MoveR: Extra0Reg R: SendNumArgsReg.
	self AndCq: 3 R: SendNumArgsReg.
	self SubR: SendNumArgsReg R: Extra2Reg.
	jump4 := self Jump: 0.
	currentBlock := self Label.
	jump6 jmpTarget: currentBlock.
	self CmpCq: 10 R: Extra0Reg.
	jump6 := self JumpBelow: 0.
	self LogicalShiftLeftCq: 1 R: Extra2Reg.
	self MoveR: Extra0Reg R: SendNumArgsReg.
	self AndCq: 1 R: SendNumArgsReg.
	self SubR: SendNumArgsReg R: Extra2Reg.
	jump7 := self Jump: 0.
	currentBlock := self Label.
	jump6 jmpTarget: currentBlock.
	self CmpCq: 9 R: Extra0Reg.
	jump6 := self JumpNonZero: 0.
	jump8 := self Jump: 0.
	currentBlock := self Label.
	jump6 jmpTarget: currentBlock.
	s107 := 0.
	self MoveCq: s107 R: Extra2Reg.
	currentBlock := self Label.
	jump5 jmpTarget: currentBlock.
	jump3 jmpTarget: currentBlock.
	jump4 jmpTarget: currentBlock.
	jump7 jmpTarget: currentBlock.
	jump8 jmpTarget: currentBlock.
	self CmpCq: 9 R: Extra0Reg.
	jump8 := self JumpAboveOrEqual: 0.
	self CmpCq: 2 R: Extra0Reg.
	jump7 := self JumpNonZero: 0.
	currentBlock := self Label.
	jump8 jmpTarget: currentBlock.
	s113 := 0.
	self MoveCq: s113 R: SendNumArgsReg.
	jump8 := self Jump: 0.
	currentBlock := self Label.
	jump7 jmpTarget: currentBlock.
	self CmpCq: 2 R: Extra0Reg.
	jump7 := self JumpAboveOrEqual: 0.
	self MoveR: Extra2Reg R: SendNumArgsReg.
	jump4 := self Jump: 0.
	currentBlock := self Label.
	jump7 jmpTarget: currentBlock.
	self MoveM64: 0 r: ClassReg R: SendNumArgsReg.
	self AndCq: 16r3FFFFF R: SendNumArgsReg.
	self CmpCq: 31 R: SendNumArgsReg.
	jump7 := self JumpAbove: 0.
	self CmpCq: 31 R: SendNumArgsReg.
	jump3 := self JumpNonZero: 0.
	self MoveR: ClassReg R: SendNumArgsReg.
	jump5 := self Jump: 0.
	currentBlock := self Label.
	jump3 jmpTarget: currentBlock.
	self CmpCq: 8 R: SendNumArgsReg.
	jump3 := self JumpNonZero: 0.
	self genMoveConstant: objectMemory nilObject R: SendNumArgsReg.
	jump6 := self Jump: 0.
	currentBlock := self Label.
	jump7 jmpTarget: currentBlock.
	jump3 jmpTarget: currentBlock.
	self MoveR: SendNumArgsReg R: ClassReg.
	self LogicalShiftRightCq: 10 R: ClassReg.
	s131 := objectMemory hiddenRootsObject.
	self LogicalShiftLeftCq: 3 R: ClassReg.
	self AddCq: s131 R: ClassReg.
	self MoveM64: 8 r: ClassReg R: ClassReg.
	self genMoveConstant: objectMemory nilObject R: Extra0Reg.
	self CmpR: Extra0Reg R: ClassReg.
	jump3 := self JumpNonZero: 0.
	self genMoveConstant: objectMemory nilObject R: Extra0Reg.
	jump7 := self Jump: 0.
	currentBlock := self Label.
	jump3 jmpTarget: currentBlock.
	self AndCq: 1023 R: SendNumArgsReg.
	self LogicalShiftLeftCq: 3 R: SendNumArgsReg.
	self AddR: SendNumArgsReg R: ClassReg.
	self MoveM64: 8 r: ClassReg R: Extra0Reg.
	currentBlock := self Label.
	jump7 jmpTarget: currentBlock.
	self MoveR: Extra0Reg R: SendNumArgsReg.
	currentBlock := self Label.
	jump5 jmpTarget: currentBlock.
	jump6 jmpTarget: currentBlock.
	self MoveM64: 24 r: SendNumArgsReg R: Extra0Reg.
	self ArithmeticShiftRightCq: 3 R: Extra0Reg.
	self AndCq: 16rFFFF R: Extra0Reg.
	self MoveR: Extra0Reg R: SendNumArgsReg.
	currentBlock := self Label.
	jump8 jmpTarget: currentBlock.
	jump4 jmpTarget: currentBlock.
	self SubR: SendNumArgsReg R: Extra2Reg.
	self MoveR: Extra2Reg R: Extra0Reg.
	self LogicalShiftLeftCq: 3 R: Extra0Reg.
	self AddCq: 1 R: Extra0Reg.
	self MoveR: Extra0Reg R: ReceiverResultReg.
	self genPrimReturn.
	currentBlock := self Label.
	jump2 jmpTarget: currentBlock.
	jump1 jmpTarget: currentBlock.
	^ 0
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveSizeofusqInt [
	"AutoGenerated by Druid"

	| currentBlock |
	self MoveCq: 8 R: ReceiverResultReg.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveSmallFloatDivide [
	"AutoGenerated by Druid"

	| jump1 jump7 jumpNext jump10 jump9 jump6 jump3 s122 s119 currentBlock s94 jump8 jump5 jump2 jumpTrue s90 jump4 |
	self mclassIsSmallFloat ifFalse: [ ^ UnimplementedPrimitive ].
	self MoveR: ReceiverResultReg R: ClassReg.
	self MoveR: Arg0Reg R: SendNumArgsReg.
	self MoveR: ClassReg R: Extra0Reg.
	self AndCq: 7 R: Extra0Reg.
	self CmpCq: 0 R: Extra0Reg.
	jump1 := self JumpZero: 0.
	self CmpCq: 4 R: Extra0Reg.
	jump2 := self JumpNonZero: 0.
	self MoveR: ClassReg R: Extra0Reg.
	self LogicalShiftRightCq: 3 R: Extra0Reg.
	self CmpCq: 1 R: Extra0Reg.
	jump3 := self JumpBelowOrEqual: 0.
	self AddCq: 16r7000000000000000 R: Extra0Reg.
	jump4 := self Jump: 0.
	currentBlock := self Label.
	jump3 jmpTarget: currentBlock.
	currentBlock := self Label.
	jump4 jmpTarget: currentBlock.
	self MoveR: Extra0Reg R: ClassReg.
	self LogicalShiftLeftCq: 63 R: ClassReg.
	self LogicalShiftRightCq: 1 R: Extra0Reg.
	self AddR: Extra0Reg R: ClassReg.
	self MoveR: ClassReg Rd: DPFPReg0.
	jump4 := self Jump: 0.
	currentBlock := self Label.
	jump2 jmpTarget: currentBlock.
	self CmpCq: 1 R: Extra0Reg.
	jump2 := self JumpNonZero: 0.
	self MoveR: ClassReg R: Extra0Reg.
	self LogicalShiftLeftCq: 9 R: Extra0Reg.
	self ArithmeticShiftRightCq: 9 R: Extra0Reg.
	self CmpR: ClassReg R: Extra0Reg.
	jump3 := self JumpNonZero: 0.
	self ArithmeticShiftRightCq: 3 R: ClassReg.
	self ConvertR: ClassReg Rd: DPFPReg0.
	jump5 := self Jump: 0.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	self MoveM64: 0 r: ClassReg R: Extra0Reg.
	self AndCq: 16r3FFFFF R: Extra0Reg.
	self CmpCq: 34 R: Extra0Reg.
	jump1 := self JumpNonZero: 0.
	self MoveM64: 8 r: ClassReg Rd: DPFPReg0.
	currentBlock := self Label.
	jump4 jmpTarget: currentBlock.
	jump5 jmpTarget: currentBlock.
	self MoveR: SendNumArgsReg R: Extra0Reg.
	self AndCq: 7 R: Extra0Reg.
	self CmpCq: 0 R: Extra0Reg.
	jump5 := self JumpZero: 0.
	self CmpCq: 4 R: Extra0Reg.
	jump4 := self JumpNonZero: 0.
	self MoveR: SendNumArgsReg R: Extra0Reg.
	self LogicalShiftRightCq: 3 R: Extra0Reg.
	self CmpCq: 1 R: Extra0Reg.
	jump6 := self JumpBelowOrEqual: 0.
	self AddCq: 16r7000000000000000 R: Extra0Reg.
	jump7 := self Jump: 0.
	currentBlock := self Label.
	jump6 jmpTarget: currentBlock.
	currentBlock := self Label.
	jump7 jmpTarget: currentBlock.
	self MoveR: Extra0Reg R: SendNumArgsReg.
	self LogicalShiftLeftCq: 63 R: SendNumArgsReg.
	self LogicalShiftRightCq: 1 R: Extra0Reg.
	self AddR: Extra0Reg R: SendNumArgsReg.
	self MoveR: SendNumArgsReg Rd: DPFPReg1.
	jump7 := self Jump: 0.
	currentBlock := self Label.
	jump4 jmpTarget: currentBlock.
	self CmpCq: 1 R: Extra0Reg.
	jump4 := self JumpNonZero: 0.
	self MoveR: SendNumArgsReg R: Extra0Reg.
	self LogicalShiftLeftCq: 9 R: Extra0Reg.
	self ArithmeticShiftRightCq: 9 R: Extra0Reg.
	self CmpR: SendNumArgsReg R: Extra0Reg.
	jump6 := self JumpNonZero: 0.
	self ArithmeticShiftRightCq: 3 R: SendNumArgsReg.
	self ConvertR: SendNumArgsReg Rd: DPFPReg1.
	jump8 := self Jump: 0.
	currentBlock := self Label.
	jump5 jmpTarget: currentBlock.
	self MoveM64: 0 r: SendNumArgsReg R: Extra0Reg.
	self AndCq: 16r3FFFFF R: Extra0Reg.
	self CmpCq: 34 R: Extra0Reg.
	jump5 := self JumpNonZero: 0.
	self MoveM64: 8 r: SendNumArgsReg Rd: DPFPReg1.
	currentBlock := self Label.
	jump7 jmpTarget: currentBlock.
	jump8 jmpTarget: currentBlock.
	self CmpCq: 0.0 Rd: DPFPReg1.
	jump8 := self JumpFPEqual: 0.
	self DivRd: DPFPReg1 Rd: DPFPReg0.
	self MoveRd: DPFPReg0 R: Extra0Reg.
	self MoveR: Extra0Reg R: SendNumArgsReg.
	self LogicalShiftRightCq: 52 R: SendNumArgsReg.
	self AndCq: 2047 R: SendNumArgsReg.
	self CmpCq: 896 R: SendNumArgsReg.
	jump7 := self JumpBelowOrEqual: 0.
	self CmpCq: 1151 R: SendNumArgsReg.
	jumpTrue := self JumpBelowOrEqual: 0.
	self MoveCq: 0 R: SendNumArgsReg.
	jumpNext := self Jump: 0.
	jumpTrue jmpTarget: self Label.
	self MoveCq: 1 R: SendNumArgsReg.
	jumpNext jmpTarget: self Label.
	jump9 := self Jump: 0.
	currentBlock := self Label.
	jump7 jmpTarget: currentBlock.
	self AndCq: 16rFFFFFFFFFFFFF R: Extra0Reg.
	self CmpCq: 0 R: Extra0Reg.
	jump7 := self JumpNonZero: 0.
	s90 := 0.
	self CmpCq: s90 R: SendNumArgsReg.
	jumpTrue := self JumpZero: 0.
	self MoveCq: 0 R: SendNumArgsReg.
	jumpNext := self Jump: 0.
	jumpTrue jmpTarget: self Label.
	self MoveCq: 1 R: SendNumArgsReg.
	jumpNext jmpTarget: self Label.
	jump10 := self Jump: 0.
	currentBlock := self Label.
	jump7 jmpTarget: currentBlock.
	s94 := 896.
	self CmpCq: s94 R: SendNumArgsReg.
	jumpTrue := self JumpZero: 0.
	self MoveCq: 0 R: SendNumArgsReg.
	jumpNext := self Jump: 0.
	jumpTrue jmpTarget: self Label.
	self MoveCq: 1 R: SendNumArgsReg.
	jumpNext jmpTarget: self Label.
	currentBlock := self Label.
	jump10 jmpTarget: currentBlock.
	currentBlock := self Label.
	jump9 jmpTarget: currentBlock.
	self CmpCq: 1 R: SendNumArgsReg.
	jump9 := self JumpNonZero: 0.
	self MoveRd: DPFPReg0 R: SendNumArgsReg.
	self RotateLeftCq: 1 R: SendNumArgsReg.
	self CmpCq: 1 R: SendNumArgsReg.
	jump10 := self JumpBelowOrEqual: 0.
	self SubCq: 16r7000000000000000 R: SendNumArgsReg.
	jump7 := self Jump: 0.
	currentBlock := self Label.
	jump10 jmpTarget: currentBlock.
	currentBlock := self Label.
	jump7 jmpTarget: currentBlock.
	self LogicalShiftLeftCq: 3 R: SendNumArgsReg.
	self AddCq: 4 R: SendNumArgsReg.
	self MoveR: SendNumArgsReg R: ReceiverResultReg.
	jump7 := self Jump: 0.
	currentBlock := self Label.
	jump9 jmpTarget: currentBlock.
	self MoveAw: objectMemory freeStartAddress R: SendNumArgsReg.
	self MoveAw: objectMemory freeStartAddress R: Extra0Reg.
	self AddCq: 16 R: Extra0Reg.
	s119 := objectMemory getScavengeThreshold.
	self CmpCq: s119 R: Extra0Reg.
	jump9 := self JumpAbove: 0.
	s122 := 72057594205700130.
	self MoveCq: s122 R: Extra0Reg.
	self MoveR: Extra0Reg M64: 0 r: SendNumArgsReg.
	self MoveAw: objectMemory freeStartAddress R: Extra0Reg.
	self AddCq: 16 R: Extra0Reg.
	self MoveR: Extra0Reg Aw: objectMemory freeStartAddress.
	self MoveRd: DPFPReg0 M64: 8 r: SendNumArgsReg.
	self MoveR: SendNumArgsReg R: ReceiverResultReg.
	currentBlock := self Label.
	jump7 jmpTarget: currentBlock.
	self genPrimReturn.
	currentBlock := self Label.
	jump2 jmpTarget: currentBlock.
	jump3 jmpTarget: currentBlock.
	jump1 jmpTarget: currentBlock.
	jump4 jmpTarget: currentBlock.
	jump6 jmpTarget: currentBlock.
	jump5 jmpTarget: currentBlock.
	jump8 jmpTarget: currentBlock.
	jump9 jmpTarget: currentBlock.
	^ 0
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveSmallOrEqualsThan [

	| currentBlock jump0 jump1 |
	self MoveCq: true asBit R: TempReg.
	self MoveCq: 10 R: ClassReg.
	self CmpCq: 10 R: ReceiverResultReg.
	jump0 := self JumpGreater: 0.
	self MoveCq: 5 R: Extra0Reg.
	self MoveCq: 5 R: Extra1Reg.
	self MoveR: Extra1Reg R: ClassReg.
	self MoveR: ReceiverResultReg R: SendNumArgsReg.
	jump1 := self Jump: 0.
	currentBlock := self Label.
	jump0 jmpTarget: currentBlock.
	self MoveCq: 11 R: Extra2Reg.
	self MoveCq: 11 R: TempReg.
	self MoveR: TempReg R: ClassReg.
	self MoveR: ReceiverResultReg R: SendNumArgsReg.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	self MoveCq: 1 R: Extra0Reg.
	self MoveR: ClassReg R: ReceiverResultReg.
	self RetN: 1 * objectMemory wordSize.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveSmallThan [

	| currentBlock jump0 jump1 |
	self MoveCq: true asBit R: TempReg.
	self MoveCq: 10 R: ClassReg.
	self CmpCq: 10 R: ReceiverResultReg.
	jump0 := self JumpGreaterOrEqual: 0.
	self MoveCq: 5 R: Extra0Reg.
	self MoveCq: 5 R: Extra1Reg.
	self MoveR: Extra1Reg R: ClassReg.
	self MoveR: ReceiverResultReg R: SendNumArgsReg.
	jump1 := self Jump: 0.
	currentBlock := self Label.
	jump0 jmpTarget: currentBlock.
	self MoveCq: 11 R: Extra2Reg.
	self MoveCq: 11 R: TempReg.
	self MoveR: TempReg R: ClassReg.
	self MoveR: ReceiverResultReg R: SendNumArgsReg.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	self MoveCq: 1 R: Extra0Reg.
	self MoveR: ClassReg R: ReceiverResultReg.
	self RetN: 1 * objectMemory wordSize.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveSubWithOverflow [
	"AutoGenerated by Druid"

	| jump1 jump2 currentBlock s7 |
	self MoveR: ReceiverResultReg R: ClassReg.
	self MoveR: Arg0Reg R: SendNumArgsReg.
	self AddCq:  -1 R: SendNumArgsReg.
	self SubR: SendNumArgsReg R: ClassReg.
	jump1 := self JumpNoOverflow: 0.
	s7 := 99.
	self MoveCq: s7 R: SendNumArgsReg.
	jump2 := self Jump: 0.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	self MoveR: ClassReg R: SendNumArgsReg.
	currentBlock := self Label.
	jump2 jmpTarget: currentBlock.
	self MoveR: SendNumArgsReg R: ReceiverResultReg.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveSumWithOverflow [
	"AutoGenerated by Druid"

	| jump1 jump2 currentBlock s7 |
	self MoveR: ReceiverResultReg R: ClassReg.
	self MoveR: Arg0Reg R: SendNumArgsReg.
	self AddCq:  -1 R: ClassReg.
	self AddR: SendNumArgsReg R: ClassReg.
	jump1 := self JumpNoOverflow: 0.
	s7 := 99.
	self MoveCq: s7 R: SendNumArgsReg.
	jump2 := self Jump: 0.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	self MoveR: ClassReg R: SendNumArgsReg.
	currentBlock := self Label.
	jump2 jmpTarget: currentBlock.
	self MoveR: SendNumArgsReg R: ReceiverResultReg.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveTrueAssignmentAsInteger [
	"AutoGenerated by Druid"

	| currentBlock |
	self MoveCq: 1 R: ReceiverResultReg.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveTrueAssignmentAsIntegerShifted [
	"AutoGenerated by Druid"

	| currentBlock |
	self MoveCq: 2 R: ReceiverResultReg.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveTrueNot [
	"AutoGenerated by Druid"

	| currentBlock |
	self MoveCq: 0 R: ReceiverResultReg.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveUint16At [
	"AutoGenerated by Druid"

	| currentBlock |
	self MoveR: ReceiverResultReg R: ClassReg.
	self MoveM64: 0 r: ClassReg R: ClassReg.
	self AndCq: 16rFFFF R: ClassReg.
	self MoveR: ClassReg R: ReceiverResultReg.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveUint16AtPut [
	"AutoGenerated by Druid"

	| currentBlock |
	self MoveR: ReceiverResultReg R: ClassReg.
	self MoveR: Arg0Reg R: SendNumArgsReg.
	self MoveR: SendNumArgsReg M64: 0 r: ClassReg.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveUint32At [
	"AutoGenerated by Druid"

	| currentBlock |
	self MoveR: ReceiverResultReg R: ClassReg.
	self MoveM64: 0 r: ClassReg R: ClassReg.
	self AndCq: 16rFFFFFFFF R: ClassReg.
	self MoveR: ClassReg R: ReceiverResultReg.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveUint32AtPut [
	"AutoGenerated by Druid"

	| currentBlock |
	self MoveR: ReceiverResultReg R: ClassReg.
	self MoveR: Arg0Reg R: SendNumArgsReg.
	self MoveR: SendNumArgsReg M64: 0 r: ClassReg.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveUint64At [
	"AutoGenerated by Druid"

	| currentBlock |
	self MoveR: ReceiverResultReg R: ClassReg.
	self MoveM64: 0 r: ClassReg R: ClassReg.
	self MoveR: ClassReg R: ReceiverResultReg.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveUint64AtPut [
	"AutoGenerated by Druid"

	| currentBlock |
	self MoveR: ReceiverResultReg R: ClassReg.
	self MoveR: Arg0Reg R: SendNumArgsReg.
	self MoveR: SendNumArgsReg M64: 0 r: ClassReg.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveUint8At [
	"AutoGenerated by Druid"

	| currentBlock |
	self MoveR: ReceiverResultReg R: ClassReg.
	self MoveM64: 0 r: ClassReg R: ClassReg.
	self AndCq: 255 R: ClassReg.
	self MoveR: ClassReg R: ReceiverResultReg.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveUint8AtPut [
	"AutoGenerated by Druid"

	| currentBlock |
	self MoveR: ReceiverResultReg R: ClassReg.
	self MoveR: Arg0Reg R: SendNumArgsReg.
	self MoveR: SendNumArgsReg M64: 0 r: ClassReg.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveWithConditionalCompilation [
	"AutoGenerated by Druid"

	| currentBlock |
	self MoveCq: 17 R: ReceiverResultReg.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveWithDeadCode [
	"AutoGenerated by Druid"

	| jump1 s4 currentBlock s7 jump2 |
	self MoveR: ReceiverResultReg R: ClassReg.
	self CmpCq: 0 R: ClassReg.
	jump1 := self JumpNonZero: 0.
	s4 := 42.
	self MoveCq: s4 R: ClassReg.
	jump2 := self Jump: 0.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	s7 := 55.
	self MoveCq: s7 R: ClassReg.
	currentBlock := self Label.
	jump2 jmpTarget: currentBlock.
	self MoveR: ClassReg R: ReceiverResultReg.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveWithIfAssigningValue [

	| currentBlock jump0 jump1 |
	self CmpCq: 0 R: ReceiverResultReg.
	jump0 := self JumpZero: 0.
	self MoveCq: 57 R: ReceiverResultReg.
	jump1 := self Jump: 0.
	
	currentBlock := self Label.
	jump0 jmpTarget: currentBlock.
	self MoveCq: 42 R: ReceiverResultReg.
	
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	self RetN: 1 * objectMemory wordSize.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveWithIfNilIfNotNilStatement [
	"AutoGenerated by Druid"

	| jump1 s4 currentBlock s7 jump2 |
	self MoveR: ReceiverResultReg R: ClassReg.
	self CmpCq: 0 R: ClassReg.
	jump1 := self JumpLessOrEqual: 0.
	s4 := 17.
	self MoveCq: s4 R: ClassReg.
	jump2 := self Jump: 0.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	s7 := 42.
	self MoveCq: s7 R: ClassReg.
	currentBlock := self Label.
	jump2 jmpTarget: currentBlock.
	self MoveR: ClassReg R: ReceiverResultReg.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveWithIfNotNilIfNilStatement [
	"AutoGenerated by Druid"

	| jump1 s4 currentBlock s7 jump2 |
	self MoveR: ReceiverResultReg R: ClassReg.
	self CmpCq: 0 R: ClassReg.
	jump1 := self JumpLessOrEqual: 0.
	s4 := 17.
	self MoveCq: s4 R: ClassReg.
	jump2 := self Jump: 0.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	s7 := 42.
	self MoveCq: s7 R: ClassReg.
	currentBlock := self Label.
	jump2 jmpTarget: currentBlock.
	self MoveR: ClassReg R: ReceiverResultReg.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveWithIfNotNilIfNilStatementWithArgument [
	"AutoGenerated by Druid"

	| jump1 s4 currentBlock s7 jump2 |
	self MoveR: ReceiverResultReg R: ClassReg.
	self CmpCq: 0 R: ClassReg.
	jump1 := self JumpLessOrEqual: 0.
	s4 := 17.
	self MoveCq: s4 R: ClassReg.
	jump2 := self Jump: 0.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	s7 := 42.
	self MoveCq: s7 R: ClassReg.
	currentBlock := self Label.
	jump2 jmpTarget: currentBlock.
	self MoveR: ClassReg R: ReceiverResultReg.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveWithIfNotNilStatement [
	"AutoGenerated by Druid"

	| jump1 s4 currentBlock s7 jump2 |
	self MoveR: ReceiverResultReg R: ClassReg.
	self CmpCq: 0 R: ClassReg.
	jump1 := self JumpLessOrEqual: 0.
	s4 := 17.
	self MoveCq: s4 R: ClassReg.
	jump2 := self Jump: 0.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	s7 := 42.
	self MoveCq: s7 R: ClassReg.
	currentBlock := self Label.
	jump2 jmpTarget: currentBlock.
	self MoveR: ClassReg R: ReceiverResultReg.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveWithIfReturningValue [

	| currentBlock jump0 jump1 |
	self CmpCq: 0 R: ReceiverResultReg.
	jump0 := self JumpZero: 0.
	self MoveCq: 57 R: ReceiverResultReg.
	jump1 := self Jump: 0.
	
	currentBlock := self Label.
	jump0 jmpTarget: currentBlock.
	self MoveCq: 42 R: ReceiverResultReg.
	
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveWithNonCompilableBranch [
	"AutoGenerated by Druid"

	| jump1 currentBlock |
	self MoveR: ReceiverResultReg R: ClassReg.
	self CmpCq: 0 R: ClassReg.
	jump1 := self JumpLessOrEqual: 0.
	self MoveCq: 11 R: ReceiverResultReg.
	self genPrimReturn.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	^ 0
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveWithSequentialExitPoint [
	"AutoGenerated by Druid"

	| currentBlock |
	^ 0
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveWithTwoArgs [
	"AutoGenerated by Druid"

	| jump1 jump2 currentBlock |
	self MoveR: ReceiverResultReg R: ClassReg.
	self MoveR: Arg0Reg R: SendNumArgsReg.
	self MoveR: Arg1Reg R: Extra0Reg.
	self CmpCq: 0 R: ClassReg.
	jump1 := self JumpLessOrEqual: 0.
	jump2 := self Jump: 0.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	self MoveR: SendNumArgsReg R: Extra0Reg.
	currentBlock := self Label.
	jump2 jmpTarget: currentBlock.
	self MoveR: Extra0Reg R: ReceiverResultReg.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_pushConstantOneBytecode [
	"AutoGenerated by Druid"

	| live currentBlock s2 |
	live := 0.
	s2 := ConstOne.
	self ssPushConstant: s2.
	^ 0
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_pushConstantTrueBytecode [
	"AutoGenerated by Druid"

	| live currentBlock s2 |
	live := 0.
	s2 := objectMemory trueObject.
	self ssPushConstant: s2.
	^ 0
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_pushConstantTrueBytecode_returnTopFromMethod [
	"AutoGenerated by Druid"

	| live currentBlock s2 |
	live := 0.
	s2 := objectMemory trueObject.
	self MoveCq: s2 R: ReceiverResultReg.
	self genUpArrowReturn.
	^ 0
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_pushConstantTrueBytecode_returnTopFromMethod_1 [
	"AutoGenerated by Druid"

	| live currentBlock s2 |
	live := 0.
	s2 := objectMemory trueObject.
	self MoveCq: s2 R: ReceiverResultReg.
	self genUpArrowReturn.
	^ 0
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_pushConstantTrueBytecode_shortConditionalJumpFalse [
	"AutoGenerated by Druid"

	| live currentBlock |
	live := 0.
	^ 0
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_pushConstantTrueBytecode_shortConditionalJumpTrue [
	"AutoGenerated by Druid"

	| s3 s4 currentBlock live s5 |
	live := 0.
	self ssFlushStackExceptTop: 0.
	s3 := bytecodePC.
	s4 := s3 + 2.
	self Jump: (self ensureFixupAt: s4).
	deadCode := true.
	^ 0
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_pushConstantZeroBytecode [
	"AutoGenerated by Druid"

	| live currentBlock s2 |
	live := 0.
	s2 := ConstZero.
	self ssPushConstant: s2.
	^ 0
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_pushLiteralConstantBytecode [
	"AutoGenerated by Druid"

	| s3 t0 s4 currentBlock live s5 |
	live := 0.
	t0 := self allocateRegNotConflictingWith: live ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t0).
	self genMoveConstant: methodObj R: t0.
	s3 := LiteralStart.
	s4 := s3 + 1.
	s5 := s4 << 3.
	self AddCq: s5 R: t0.
	self ssPushBase: t0 offset: 8.
	^ 0
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_pushLiteralVariable16CasesBytecode [
	"AutoGenerated by Druid"

	| jump1 s3 s28 t1 jump3 currentBlock t0 jump2 s4 s29 b233 live jump4 |
	live := 0.
	t0 := self allocateRegNotConflictingWith: live ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t0).
	t1 := self allocateRegNotConflictingWith: live ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t1).
	self genMoveConstant: methodObj R: t0.
	s3 := LiteralStart.
	s4 := s3 << 3.
	self AddCq: s4 R: t0.
	self MoveM64: 8 r: t0 R: t0.
	self MoveM64: 0 r: t0 R: t1.
	self AndCq: 16r3FFFF7 R: t1.
	self CmpCq: 0 R: t1.
	jump1 := self JumpNonZero: 0.
	self MoveM64: 8 r: t0 R: t1.
	b233 := self Label.
	self MoveR: t1 R: t0.
	self AndCq: 7 R: t0.
	self CmpCq: 0 R: t0.
	jump2 := self JumpNonZero: 0.
	self MoveM64: 0 r: t1 R: t0.
	self AndCq: 16r3FFFF7 R: t0.
	self CmpCq: 0 R: t0.
	jump3 := self JumpNonZero: 0.
	self MoveM64: 8 r: t1 R: t0.
	self MoveR: t0 R: t1.
	jump4 := self Jump: b233.
	currentBlock := self Label.
	jump2 jmpTarget: currentBlock.
	jump3 jmpTarget: currentBlock.
	self MoveR: t1 R: t0.
	jump3 := self Jump: 0.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	currentBlock := self Label.
	jump3 jmpTarget: currentBlock.
	s28 := ValueIndex.
	s29 := s28 << 3.
	self AddCq: s29 R: t0.
	self ssPushBase: t0 offset: 8.
	^ 0
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_pushNewArrayBytecode [
	"AutoGenerated by Druid"

	| s6 s24 s33 b115 s55 s4 s38 s14 s2 t1 currentBlock jump1 s51 s7 s25 s34 s47 s17 s10 live s39 s32 s40 s3 t2 s43 s52 s8 s26 s35 s61 t0 s57 s50 |
	live := 0.
	t0 := self allocateRegNotConflictingWith: live ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t0).
	t1 := self allocateRegNotConflictingWith: live ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t1).
	t2 := self allocateRegNotConflictingWith: live ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t2).
	s2 := byte1.
	s3 := s2 bitAnd: 127.
	s4 := ClassArrayCompactIndex.
	self MoveAw: objectMemory freeStartAddress R: t0.
	s3 < 1 ifTrue: [
		| jump1 b115 |
		s7 := 8.
		s8 := s7.
		s14 := s8 + 8.
		self MoveAw: objectMemory freeStartAddress R: t1.
		self AddCq: s14 R: t1.
		s17 := objectMemory getScavengeThreshold.
		self ssFlushStackExceptTop: 0.
		self CmpCq: s17 R: t1.
		jump1 := self JumpBelowOrEqual: 0.
		self deoptimize.
		self deoptimize.
		self deoptimize.
		deadCode := false.
		currentBlock := self Label.
		jump1 jmpTarget: currentBlock.
		s24 := s3 << 56.
		s25 := s24 + s4.
		s26 := s25 + 33554432.
		self MoveCq: s26 R: t1.
		self MoveR: t1 M64: 0 r: t0.
		self MoveAw: objectMemory freeStartAddress R: t1.
		self AddCq: s14 R: t1.
		self MoveR: t1 Aw: objectMemory freeStartAddress.
		s2 > 127 ifTrue: [
			| b87 |
			s33 := 0.
			s34 := s3 - 1.
			s35 := s33.
			b87 := self Label.
			[ ((s35<=s34)) ] whileTrue: [
				s39 := s3 - s35.
				s40 := s39 - 1.
				(self ssValue: 0) copyToReg: t1.
				self ssPop: 1 popSpilled: true.
				s43 := s40 << 3.
				self MoveR: t0 R: t2.
				self AddCq: s43 R: t2.
				self MoveR: t1 M64: 8 r: t2.
				s47 := s35 + 1.
				s35 := s47 ].
			self ssPushRegister: t0.
			^ 0 ].
		s50 := 0.
		s51 := s3 - 1.
		s52 := s50.
		b115 := self Label.
		[ ((s52<=s51)) ] whileTrue: [
			self genMoveConstant: objectMemory nilObject R: t2.
			s57 := s52 << 3.
			self MoveR: t0 R: t1.
			self AddCq: s57 R: t1.
			self MoveR: t2 M64: 8 r: t1.
			s61 := s52 + 1.
			s52 := s61 ].
		self ssPushRegister: t0.
		^ 0 ].
	s10 := s3 << 3.
	s8 := s10.
	s14 := s8 + 8.
	self MoveAw: objectMemory freeStartAddress R: t1.
	self AddCq: s14 R: t1.
	s17 := objectMemory getScavengeThreshold.
	self ssFlushStackExceptTop: 0.
	self CmpCq: s17 R: t1.
	jump1 := self JumpBelowOrEqual: 0.
	self deoptimize.
	self deoptimize.
	self deoptimize.
	deadCode := false.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	s24 := s3 << 56.
	s25 := s24 + s4.
	s26 := s25 + 33554432.
	self MoveCq: s26 R: t1.
	self MoveR: t1 M64: 0 r: t0.
	self MoveAw: objectMemory freeStartAddress R: t1.
	self AddCq: s14 R: t1.
	self MoveR: t1 Aw: objectMemory freeStartAddress.
	s2 > 127 ifTrue: [
		| b87 |
		s33 := 0.
		s34 := s3 - 1.
		s35 := s33.
		b87 := self Label.
		[ ((s35<=s34)) ] whileTrue: [
			s39 := s3 - s35.
			s40 := s39 - 1.
			(self ssValue: 0) copyToReg: t1.
			self ssPop: 1 popSpilled: true.
			s43 := s40 << 3.
			self MoveR: t0 R: t2.
			self AddCq: s43 R: t2.
			self MoveR: t1 M64: 8 r: t2.
			s47 := s35 + 1.
			s35 := s47 ].
		self ssPushRegister: t0.
		^ 0 ].
	s50 := 0.
	s51 := s3 - 1.
	s52 := s50.
	b115 := self Label.
	[ ((s52<=s51)) ] whileTrue: [
		self genMoveConstant: objectMemory nilObject R: t2.
		s57 := s52 << 3.
		self MoveR: t0 R: t1.
		self AddCq: s57 R: t1.
		self MoveR: t2 M64: 8 r: t1.
		s61 := s52 + 1.
		s52 := s61 ].
	self ssPushRegister: t0.
	^ 0
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_pushReceiverBytecode [
	"AutoGenerated by Druid"

	| live currentBlock t0 |
	live := 0.
	t0 := self allocateRegNotConflictingWith: live ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t0).
	self ensureReceiverResultRegContainsSelf.
	self MoveR: ReceiverResultReg R: t0.
	self ssPushRegister: t0.
	^ 0
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_pushReceiverVariableBytecode [
	"AutoGenerated by Druid"

	| live currentBlock t0 |
	live := 0.
	t0 := self allocateRegNotConflictingWith: live ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t0).
	self ensureReceiverResultRegContainsSelf.
	self MoveR: ReceiverResultReg R: t0.
	self ssPushBase: t0 offset: 16.
	^ 0
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_pushTemporaryVariableBytecode [
	"AutoGenerated by Druid"

	| live currentBlock t0 |
	live := 0.
	t0 := self allocateRegNotConflictingWith: live ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t0).
	(self simStackTempAt: 2) copyToReg: t0.
	self ssPushRegister: t0.
	^ 0
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_returnFalse [
	"AutoGenerated by Druid"

	| live currentBlock s2 |
	live := 0.
	s2 := objectMemory falseObject.
	self MoveCq: s2 R: ReceiverResultReg.
	self genUpArrowReturn.
	^ 0
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_returnNil [
	"AutoGenerated by Druid"

	| live currentBlock t0 |
	live := 0.
	t0 := self allocateRegNotConflictingWith: live ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t0).
	self genMoveConstant: objectMemory nilObject R: t0.
	self MoveR: t0 R: ReceiverResultReg.
	self genUpArrowReturn.
	^ 0
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_returnReceiver [
	"AutoGenerated by Druid"

	| live currentBlock t0 |
	live := 0.
	t0 := self allocateRegNotConflictingWith: live ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t0).
	self ensureReceiverResultRegContainsSelf.
	self MoveR: ReceiverResultReg R: t0.
	self MoveR: t0 R: ReceiverResultReg.
	self genUpArrowReturn.
	^ 0
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_returnTopFromMethod [
	"AutoGenerated by Druid"

	| live currentBlock t0 |
	live := 0.
	t0 := self allocateRegNotConflictingWith: live ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t0).
	(self ssValue: 0) copyToReg: t0.
	self ssPop: 1 popSpilled: true.
	self MoveR: t0 R: ReceiverResultReg.
	self genUpArrowReturn.
	^ 0
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_returnTrue [
	"AutoGenerated by Druid"

	| live currentBlock s2 |
	live := 0.
	s2 := objectMemory trueObject.
	self MoveCq: s2 R: ReceiverResultReg.
	self genUpArrowReturn.
	^ 0
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_sendLiteralSelector0ArgsBytecode [
	"AutoGenerated by Druid"

	| live currentBlock |
	live := 0.
	self ssFlushStackExceptTop: 1.
	self marshallSendArgumentsNoPush: 0.
	self genMarshalledSendNoPush: 1 numArgs: 0 sendTable: ordinarySendTrampolines.
	self ssPop: 1 popSpilled: false.
	self ssPushRegister: ReceiverResultReg.
	^ 0
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_shortConditionalJumpFalse [
	"AutoGenerated by Druid"

	| jump1 s8 currentBlock t0 s7 s4 jump2 s11 live s9 |
	live := 0.
	t0 := self allocateRegNotConflictingWith: live ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t0).
	(self ssValue: 0) copyToReg: t0.
	self ssPop: 1 popSpilled: true.
	s4 := objectMemory falseObject.
	self ssFlushStackExceptTop: 0.
	self CmpCq: s4 R: t0.
	jump1 := self JumpNonZero: 0.
	s7 := bytecodePC.
	s8 := s7 + 2.
	self Jump: (self ensureFixupAt: s8).
	deadCode := true.
	jump2 := self Jump: 0.
	deadCode := false.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	s11 := objectMemory trueObject.
	self CmpCq: s11 R: t0.
	jump1 := self JumpZero: 0.
	self MoveR: t0 R: TempReg.
	self CallRT: ceSendMustBeBooleanTrampoline.
	self annotateBytecode: self Label.
	currentBlock := self Label.
	jump2 jmpTarget: currentBlock.
	jump1 jmpTarget: currentBlock.
	^ 0
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_shortConditionalJumpTrue [
	"AutoGenerated by Druid"

	| jump1 s8 currentBlock t0 s7 s4 jump2 s11 live s9 |
	live := 0.
	t0 := self allocateRegNotConflictingWith: live ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t0).
	(self ssValue: 0) copyToReg: t0.
	self ssPop: 1 popSpilled: true.
	s4 := objectMemory trueObject.
	self ssFlushStackExceptTop: 0.
	self CmpCq: s4 R: t0.
	jump1 := self JumpNonZero: 0.
	s7 := bytecodePC.
	s8 := s7 + 2.
	self Jump: (self ensureFixupAt: s8).
	deadCode := true.
	jump2 := self Jump: 0.
	deadCode := false.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	s11 := objectMemory falseObject.
	self CmpCq: s11 R: t0.
	jump1 := self JumpZero: 0.
	self MoveR: t0 R: TempReg.
	self CallRT: ceSendMustBeBooleanTrampoline.
	self annotateBytecode: self Label.
	currentBlock := self Label.
	jump2 jmpTarget: currentBlock.
	jump1 jmpTarget: currentBlock.
	^ 0
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_shortUnconditionalJump [
	"AutoGenerated by Druid"

	| s3 s4 currentBlock live s5 |
	live := 0.
	self ssFlushStackExceptTop: 0.
	s3 := bytecodePC.
	s4 := s3 + 2.
	self Jump: (self ensureFixupAt: s4).
	deadCode := true.
	^ 0
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_storeAndPopReceiverVariableBytecode [
	"AutoGenerated by Druid"

	| jump1 jump7 s19 s16 t1 jump6 jump3 currentBlock s24 t0 s27 jump2 jump5 s29 t2 live jump4 |
	live := 0.
	t0 := self allocateRegNotConflictingWith: live ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t0).
	t1 := self allocateRegNotConflictingWith: live ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t1).
	t2 := self allocateRegNotConflictingWith: live ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t2).
	self ensureReceiverResultRegContainsSelf.
	self MoveR: ReceiverResultReg R: t0.
	(self ssValue: 0) copyToReg: t1.
	self MoveM64: 0 r: t0 R: t2.
	self LogicalShiftRightCq: 23 R: t2.
	self AndCq: 1 R: t2.
	self ssFlushStackExceptTop: 0.
	self CmpCq: 0 R: t2.
	jump1 := self JumpZero: 0.
	self deoptimize.
	jump2 := self Jump: 0.
	deadCode := false.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	self ssPop: 1 popSpilled: true.
	self MoveR: t1 M64: 8 r: t0.
	self MoveR: t0 R: t2.
	self AndCq: 7 R: t2.
	self CmpCq: 0 R: t2.
	jump1 := self JumpNonZero: 0.
	s16 := objectMemory getMemoryMap getSpaceMaskToUse.
	self MoveR: t0 R: t2.
	self AndCq: s16 R: t2.
	s19 := objectMemory getMemoryMap getOldSpaceMask.
	self CmpCq: s19 R: t2.
	jump3 := self JumpNonZero: 0.
	self MoveR: t1 R: t2.
	self AndCq: 7 R: t2.
	self CmpCq: 0 R: t2.
	jump4 := self JumpNonZero: 0.
	s24 := objectMemory getMemoryMap getSpaceMaskToUse.
	self MoveR: t1 R: t2.
	self AndCq: s24 R: t2.
	s27 := objectMemory getMemoryMap getNewSpaceMask.
	self CmpCq: s27 R: t2.
	jump5 := self JumpNonZero: 0.
	s29 := objectMemory getMemoryMap getNewSpaceStart.
	self CmpCq: s29 R: t1.
	jump6 := self JumpBelow: 0.
	self MoveM64: 0 r: t0 R: t2.
	self LogicalShiftRightCq: 29 R: t2.
	self AndCq: 1 R: t2.
	self CmpCq: 0 R: t2.
	jump7 := self JumpNonZero: 0.
	self MoveR: t0 R: TempReg.
	backEnd saveAndRestoreLinkRegAround: [ self CallRT: ceStoreCheckTrampoline ].
	self annotateBytecode: self Label.
	currentBlock := self Label.
	jump2 jmpTarget: currentBlock.
	jump1 jmpTarget: currentBlock.
	jump3 jmpTarget: currentBlock.
	jump4 jmpTarget: currentBlock.
	jump5 jmpTarget: currentBlock.
	jump6 jmpTarget: currentBlock.
	jump7 jmpTarget: currentBlock.
	^ 0
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_storeAndPopRemoteTempLongBytecode [
	"AutoGenerated by Druid"

	| jump5 s33 s4 jump3 s44 jump8 s2 t1 currentBlock s49 jump1 jumpNext jump6 live s5 jumpTrue s54 jump2 t2 s52 jump7 t0 s41 |
	live := 0.
	t0 := self allocateRegNotConflictingWith: live ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t0).
	t1 := self allocateRegNotConflictingWith: live ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t1).
	t2 := self allocateRegNotConflictingWith: live ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t2).
	s2 := byte1.
	(self simStackTempAt: byte2) copyToReg: t0.
	s4 := TempVectReadBarrier.
	s4 ifTrue: [
		| b371 jump1 jumpNext jump6 jump3 jump8 jump5 jumpTrue jump2 jump7 jump4 |
		self MoveM64: 0 r: t0 R: t1.
		self AndCq: 16r3FFFF7 R: t1.
		self CmpCq: 0 R: t1.
		jump1 := self JumpNonZero: 0.
		self MoveM64: 8 r: t0 R: t1.
		b371 := self Label.
		self MoveR: t1 R: t0.
		self AndCq: 7 R: t0.
		self CmpCq: 0 R: t0.
		jump2 := self JumpNonZero: 0.
		self MoveM64: 0 r: t1 R: t0.
		self AndCq: 16r3FFFF7 R: t0.
		self CmpCq: 0 R: t0.
		jump3 := self JumpNonZero: 0.
		self MoveM64: 8 r: t1 R: t0.
		self MoveR: t0 R: t1.
		jump4 := self Jump: b371.
		currentBlock := self Label.
		jump2 jmpTarget: currentBlock.
		jump3 jmpTarget: currentBlock.
		self MoveR: t1 R: t0.
		jump3 := self Jump: 0.
		currentBlock := self Label.
		jump1 jmpTarget: currentBlock.
		currentBlock := self Label.
		jump3 jmpTarget: currentBlock.
		(self ssValue: 0) copyToReg: t1.
		s33 := s2 << 3.
		self MoveR: t0 R: t2.
		self AddCq: s33 R: t2.
		self MoveR: t1 M64: 8 r: t2.
		self MoveR: t0 R: t2.
		self AndCq: 7 R: t2.
		self ssFlushStackExceptTop: 0.
		self CmpCq: 0 R: t2.
		jump3 := self JumpNonZero: 0.
		s41 := objectMemory getMemoryMap getSpaceMaskToUse.
		self MoveR: t0 R: t2.
		self AndCq: s41 R: t2.
		s44 := objectMemory getMemoryMap getOldSpaceMask.
		self CmpCq: s44 R: t2.
		jump1 := self JumpNonZero: 0.
		self MoveR: t1 R: t2.
		self AndCq: 7 R: t2.
		self CmpCq: 0 R: t2.
		jump2 := self JumpNonZero: 0.
		s49 := objectMemory getMemoryMap getSpaceMaskToUse.
		self MoveR: t1 R: t2.
		self AndCq: s49 R: t2.
		s52 := objectMemory getMemoryMap getNewSpaceMask.
		self CmpCq: s52 R: t2.
		jump5 := self JumpNonZero: 0.
		s54 := objectMemory getMemoryMap getNewSpaceStart.
		self MoveR: t1 R: t2.
		self CmpCq: s54 R: t2.
		jumpTrue := self JumpAboveOrEqual: 0.
		self MoveCq: 0 R: t2.
		jumpNext := self Jump: 0.
		jumpTrue jmpTarget: self Label.
		self MoveCq: 1 R: t2.
		jumpNext jmpTarget: self Label.
		self CmpCq: 1 R: t2.
		jump6 := self JumpNonZero: 0.
		self MoveM64: 0 r: t0 R: t2.
		self LogicalShiftRightCq: 29 R: t2.
		self AndCq: 1 R: t2.
		self CmpCq: 0 R: t2.
		jump7 := self JumpNonZero: 0.
		self MoveR: t0 R: TempReg.
		backEnd saveAndRestoreLinkRegAround: [ self CallRT: ceStoreCheckTrampoline ].
		self annotateBytecode: self Label.
		jump8 := self Jump: 0.
		currentBlock := self Label.
		jump5 jmpTarget: currentBlock.
		currentBlock := self Label.
		jump3 jmpTarget: currentBlock.
		jump1 jmpTarget: currentBlock.
		jump2 jmpTarget: currentBlock.
		jump6 jmpTarget: currentBlock.
		jump7 jmpTarget: currentBlock.
		jump8 jmpTarget: currentBlock.
		self ssPop: 1 popSpilled: true.
		^ 0 ].
	(self ssValue: 0) copyToReg: t1.
	s33 := s2 << 3.
	self MoveR: t0 R: t2.
	self AddCq: s33 R: t2.
	self MoveR: t1 M64: 8 r: t2.
	self MoveR: t0 R: t2.
	self AndCq: 7 R: t2.
	self ssFlushStackExceptTop: 0.
	self CmpCq: 0 R: t2.
	jump8 := self JumpNonZero: 0.
	s41 := objectMemory getMemoryMap getSpaceMaskToUse.
	self MoveR: t0 R: t2.
	self AndCq: s41 R: t2.
	s44 := objectMemory getMemoryMap getOldSpaceMask.
	self CmpCq: s44 R: t2.
	jump7 := self JumpNonZero: 0.
	self MoveR: t1 R: t2.
	self AndCq: 7 R: t2.
	self CmpCq: 0 R: t2.
	jump6 := self JumpNonZero: 0.
	s49 := objectMemory getMemoryMap getSpaceMaskToUse.
	self MoveR: t1 R: t2.
	self AndCq: s49 R: t2.
	s52 := objectMemory getMemoryMap getNewSpaceMask.
	self CmpCq: s52 R: t2.
	jump2 := self JumpNonZero: 0.
	s54 := objectMemory getMemoryMap getNewSpaceStart.
	self MoveR: t1 R: t2.
	self CmpCq: s54 R: t2.
	jumpTrue := self JumpAboveOrEqual: 0.
	self MoveCq: 0 R: t2.
	jumpNext := self Jump: 0.
	jumpTrue jmpTarget: self Label.
	self MoveCq: 1 R: t2.
	jumpNext jmpTarget: self Label.
	self CmpCq: 1 R: t2.
	jump1 := self JumpNonZero: 0.
	self MoveM64: 0 r: t0 R: t2.
	self LogicalShiftRightCq: 29 R: t2.
	self AndCq: 1 R: t2.
	self CmpCq: 0 R: t2.
	jump3 := self JumpNonZero: 0.
	self MoveR: t0 R: TempReg.
	backEnd saveAndRestoreLinkRegAround: [ self CallRT: ceStoreCheckTrampoline ].
	self annotateBytecode: self Label.
	jump5 := self Jump: 0.
	currentBlock := self Label.
	jump2 jmpTarget: currentBlock.
	currentBlock := self Label.
	jump8 jmpTarget: currentBlock.
	jump7 jmpTarget: currentBlock.
	jump6 jmpTarget: currentBlock.
	jump1 jmpTarget: currentBlock.
	jump3 jmpTarget: currentBlock.
	jump5 jmpTarget: currentBlock.
	self ssPop: 1 popSpilled: true.
	^ 0
]

{ #category : #query }
DruidTestRTLCompiler >> hasAnnotatedAbstractInstructions: annotation [

	0 to: opcodeIndex - 1 do: [ :i |
		| instruction |
		instruction := self abstractInstructionAt: i.
		instruction annotation = annotation ifTrue: [ ^ true ] ].
	^ false
]

{ #category : #'trait candidates' }
DruidTestRTLCompiler >> initialize [

	super initialize.
	deadCode := false
]

{ #category : #generated }
DruidTestRTLCompiler >> numRegArgs [

	^ 2 "Hardcoded?"
]

{ #category : #compatibility }
DruidTestRTLCompiler >> shouldAnnotateObjectReference: anOop [
	"Objects in newSpace or oldSpace except nil, true, false & classTableRootObj need to be annotated."
	^(objectMemory isNonImmediate: anOop)
	  and: [(self oop: anOop isGreaterThan: objectMemory classTableRootObj)
		or: [self oop: anOop isLessThan: objectMemory nilObject]]
]

{ #category : #generated }
DruidTestRTLCompiler >> smallFloatSpecialisedPreamble [ 

	self mclassIsSmallFloat ifFalse:
		[^UnimplementedPrimitive].
]

{ #category : #generated }
DruidTestRTLCompiler >> smallIntegerSpecialisedPreamble [ 

	self mclassIsSmallInteger ifFalse:
		[^UnimplementedPrimitive].
]
