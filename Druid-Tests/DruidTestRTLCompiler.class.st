Class {
	#name : #DruidTestRTLCompiler,
	#superclass : #DruidJIT,
	#category : #'Druid-Tests'
}

{ #category : #'class initialization' }
DruidTestRTLCompiler class >> bytecodeTable [

	<generated>
	^ { { 1. 0. 0. #gen_BytecodeWithNoFrameInstVarRefAnnotation.
	  #isInstVarRef. #needsFrameNever:. 1 } }
]

{ #category : #'class initialization' }
DruidTestRTLCompiler class >> initializeBytecodeTableForSistaV1 [

	<generated>
	numPushNilsFunction := #sistaV1:Num:Push:Nils:.
	pushNilSizeFunction := #sistaV1PushNilSize:numInitialNils:.
	BytecodeSetHasDirectedSuperSend := true.
	BytecodeSetHasExtensions := true.
	FirstSpecialSelector := 96.
	NumSpecialSelectors := 32.
	self generatorTableFrom: self bytecodeTable
]

{ #category : #'class initialization' }
DruidTestRTLCompiler class >> initializePrimitiveTable [

	<generated>
	MaxCompiledPrimitiveIndex := 0.
	primitiveTable := CArrayAccessor on: (Array new: MaxCompiledPrimitiveIndex + 1).
	self table: primitiveTable from: self primitiveTableArray.
	^ primitiveTable
]

{ #category : #'class initialization' }
DruidTestRTLCompiler class >> primitiveTableArray [

	<generated>
	^ {  }
]

{ #category : #deployment }
DruidTestRTLCompiler class >> replaceMethodOnJIT: selector [

| druidMethod cogMethod |
druidMethod := DruidTestRTLCompiler lookupSelector: (#gen_, selector).
cogMethod := druidMethod ast copy.

"Change selector"
cogMethod selector: (#gen, selector capitalized).

"Replace self by cogit variable"
cogMethod nodesDo: [ :n | n isSelfVariable ifTrue: [ n replaceWith: (RBVariableNode named: 'cogit') ] ].

"Add type anotations"
cogMethod pragmas: { }.
cogMethod temporaries do: [ :temp | |args|	
	args := {temp name. #'AbstractInstruction *'} collect: [ :arg | RBLiteralNode value: arg ].
	cogMethod addPragma: (RBPragmaNode selector: #var:type: arguments: args).	
].


CogObjectRepresentation compile: cogMethod formattedCode classified: 'primitive generators'
]

{ #category : #compiling }
DruidTestRTLCompiler >> compileAbort [
	"Fake method"

	stackOverflowCall := self Nop
]

{ #category : #compiling }
DruidTestRTLCompiler >> compileEntry [
	"Fake method"

	
]

{ #category : #accessing }
DruidTestRTLCompiler >> deadCode [

	^ deadCode
]

{ #category : #accessing }
DruidTestRTLCompiler >> extA [

	<doNotGenerate>
	^ extA
]

{ #category : #accessing }
DruidTestRTLCompiler >> extA: anObject [

	<doNotGenerate>
	^ extA := anObject
]

{ #category : #accessing }
DruidTestRTLCompiler >> extB [

	<doNotGenerate>
	^ extB
]

{ #category : #accessing }
DruidTestRTLCompiler >> extB: anObject [

	<doNotGenerate>
	^ extB := anObject
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_BytecodeWithNoFrameInstVarRefAnnotation [
	"AutoGenerated by Druid"

	| live currentBlock |
	live := 0.
	^ 0
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_BytecodeWithNoFrameInstVarRefAnnotation0 [
	"AutoGenerated by Druid"

	| live currentBlock |
	live := 0.
	^ 0
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_BytecodeWithNoFrameInstVarRefAnnotation1 [
	"AutoGenerated by Druid"

	| live currentBlock |
	live := 0.
	^ 0
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_BytecodeWithNoFrameInstVarRefAnnotation2 [
	"AutoGenerated by Druid"

	| live currentBlock |
	live := 0.
	^ 0
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_BytecodeWithNoFrameInstVarRefAnnotation3 [
	"AutoGenerated by Druid"

	| live currentBlock |
	live := 0.
	^ 0
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_PrimitiveAdd [
	"AutoGenerated by Druid"

	| jump1 jump2 currentBlock |
	self mclassIsSmallInteger ifFalse: [ ^ UnimplementedPrimitive ].
	self MoveR: ReceiverResultReg R: TempReg.
	self MoveR: Arg0Reg R: ClassReg.
	self TstCq: 1 R: ClassReg.
	jump1 := self JumpZero: 0.
	self AddCq:  -1 R: ClassReg.
	self AddR: TempReg R: ClassReg.
	jump2 := self JumpOverflow: 0.
	self MoveR: ClassReg R: ReceiverResultReg.
	self genPrimReturn.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	jump2 jmpTarget: currentBlock.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_PushReceiverVariableBytecode [
	"AutoGenerated by Druid"

	| live currentBlock t0 |
	live := 0.
	self ensureReceiverResultRegContainsSelf.
	t0 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t0).
	self MoveR: ReceiverResultReg R: t0.
	self ssPushBase: t0 offset: 8.
	^ 0
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_ReturnTopFromMethod [
	"AutoGenerated by Druid"

	| live currentBlock t0 |
	live := 0.
	t0 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t0).
	(self ssValue: 0) copyToReg: t0.
	self ssPop: 1.
	self MoveR: t0 R: ReceiverResultReg.
	self genUpArrowReturn.
	^ 0
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_StoreAndPopReceiverVariableBytecode0 [
	"AutoGenerated by Druid"

	| jump1 jump7 jumpNext t1 jump6 jump3 jump9 currentBlock t0 jump5 jump2 jumpTrue jump8 live t2 jump4 |
	live := 0.
	self annotateBytecode: self Label.
	self ensureReceiverResultRegContainsSelf.
	t0 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t0).
	self MoveR: ReceiverResultReg R: t0.
	t1 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t1).
	(self ssValue: 0) copyToReg: t1.
	t2 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t2).
	self MoveM64: 0 r: t0 R: t2.
	self ArithmeticShiftRightCq: 23 R: t2.
	self AndCq: 1 R: t2.
	self ssFlushStack.
	self CmpCq: 0 R: t2.
	jump1 := self JumpZero: 0.
	self deoptimize.
	jump2 := self Jump: 0.
	deadCode := false.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	self ssPop: 1.
	self MoveR: t0 R: t2.
	self AndCq: 7 R: t2.
	self CmpCq: 0 R: t2.
	jump1 := self JumpNonZero: 0.
	self MoveR: t0 R: t2.
	self AndCq: objectMemory getMemoryMap getSpaceMaskToUse R: t2.
	self CmpCq: objectMemory getMemoryMap getOldSpaceMask R: t2.
	jump3 := self JumpNonZero: 0.
	self MoveR: t1 R: t2.
	self AndCq: 7 R: t2.
	self CmpCq: 0 R: t2.
	jump4 := self JumpNonZero: 0.
	self MoveR: t1 R: t2.
	self AndCq: objectMemory getMemoryMap getSpaceMaskToUse R: t2.
	self CmpCq: objectMemory getMemoryMap getNewSpaceMask R: t2.
	jump5 := self JumpNonZero: 0.
	self MoveR: t1 R: t2.
	self CmpCq: objectMemory getMemoryMap getNewSpaceStart R: t2.
	jumpTrue := self JumpAboveOrEqual: 0.
	self MoveCq: 0 R: t2.
	jumpNext := self Jump: 0.
	jumpTrue jmpTarget: self Label.
	self MoveCq: 1 R: t2.
	jumpNext jmpTarget: self Label.
	self CmpCq: 1 R: t2.
	jump6 := self JumpNonZero: 0.
	self MoveM64: 0 r: t0 R: t2.
	self ArithmeticShiftRightCq: 29 R: t2.
	self AndCq: 1 R: t2.
	self CmpCq: 0 R: t2.
	jump7 := self JumpNonZero: 0.
	self MoveR: t0 R: TempReg.
	backEnd saveAndRestoreLinkRegAround: [
		self CallRT: ceStoreCheckTrampoline ].
	self TstCq: 7 R: t1.
	jump8 := self JumpNonZero: 0.
	jump9 := self JumpZero: 0.
	currentBlock := self Label.
	jump5 jmpTarget: currentBlock.
	self MoveCq: 0 R: t2.
	currentBlock := self Label.
	jump6 jmpTarget: currentBlock.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	jump3 jmpTarget: currentBlock.
	jump4 jmpTarget: currentBlock.
	jump7 jmpTarget: currentBlock.
	self TstCq: 7 R: t1.
	jump7 := self JumpNonZero: 0.
	currentBlock := self Label.
	jump9 jmpTarget: currentBlock.
	self CmpCq: objectMemory nilObject R: t1.
	jump9 := self JumpBelow: 0.
	self MoveR: t1 R: t2.
	self CmpCq: objectMemory trueObject R: t2.
	jumpTrue := self JumpBelowOrEqual: 0.
	self MoveCq: 0 R: t2.
	jumpNext := self Jump: 0.
	jumpTrue jmpTarget: self Label.
	self MoveCq: 1 R: t2.
	jumpNext jmpTarget: self Label.
	jump4 := self Jump: 0.
	currentBlock := self Label.
	jump9 jmpTarget: currentBlock.
	self MoveCq: 0 R: t2.
	currentBlock := self Label.
	jump4 jmpTarget: currentBlock.
	self CmpCq: 1 R: t2.
	jump4 := self JumpZero: 0.
	self CmpCq: objectMemory getMemoryMap getNewSpaceStart R: t1.
	jump9 := self JumpBelow: 0.
	self MoveM64: 0 r: t0 R: t2.
	self ArithmeticShiftRightCq: 29 R: t2.
	self AndCq: 1 R: t2.
	self CmpCq: 0 R: t2.
	jump3 := self JumpNonZero: 0.
	self MoveR: t0 R: t2.
	self AndCq: 7 R: t2.
	self CmpCq: 0 R: t2.
	jump1 := self JumpNonZero: 0.
	self MoveR: t0 R: t2.
	self AndCq: objectMemory getMemoryMap getSpaceMaskToUse R: t2.
	self CmpCq: objectMemory getMemoryMap getPermSpaceMask R: t2.
	jumpTrue := self JumpZero: 0.
	self MoveCq: 0 R: t2.
	jumpNext := self Jump: 0.
	jumpTrue jmpTarget: self Label.
	self MoveCq: 1 R: t2.
	jumpNext jmpTarget: self Label.
	jump6 := self Jump: 0.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	self MoveCq: 0 R: t2.
	currentBlock := self Label.
	jump6 jmpTarget: currentBlock.
	self CmpCq: 1 R: t2.
	jump6 := self JumpNonZero: 0.
	self MoveR: t1 R: t2.
	self AndCq: objectMemory getMemoryMap getSpaceMaskToUse R: t2.
	self CmpCq: objectMemory getMemoryMap getPermSpaceMask R: t2.
	jump1 := self JumpZero: 0.
	self MoveR: t0 R: TempReg.
	backEnd saveAndRestoreLinkRegAround: [
		self CallRT: ceStoreCheckTrampoline ].
	currentBlock := self Label.
	jump8 jmpTarget: currentBlock.
	jump7 jmpTarget: currentBlock.
	jump4 jmpTarget: currentBlock.
	jump9 jmpTarget: currentBlock.
	jump3 jmpTarget: currentBlock.
	jump6 jmpTarget: currentBlock.
	jump1 jmpTarget: currentBlock.
	self MoveR: t1 M64: 8 r: t0.
	currentBlock := self Label.
	jump2 jmpTarget: currentBlock.
	^ 0
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_StoreAndPopReceiverVariableBytecode1 [
	"AutoGenerated by Druid"

	| jump1 jump7 jumpNext t1 jump6 jump3 jump9 currentBlock t0 jump5 jump2 jumpTrue jump8 live t2 jump4 |
	live := 0.
	self annotateBytecode: self Label.
	self ensureReceiverResultRegContainsSelf.
	t0 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t0).
	self MoveR: ReceiverResultReg R: t0.
	t1 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t1).
	(self ssValue: 0) copyToReg: t1.
	t2 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t2).
	self MoveM64: 0 r: t0 R: t2.
	self ArithmeticShiftRightCq: 23 R: t2.
	self AndCq: 1 R: t2.
	self ssFlushStack.
	self CmpCq: 0 R: t2.
	jump1 := self JumpZero: 0.
	self deoptimize.
	jump2 := self Jump: 0.
	deadCode := false.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	self ssPop: 1.
	self MoveR: t0 R: t2.
	self AndCq: 7 R: t2.
	self CmpCq: 0 R: t2.
	jump1 := self JumpNonZero: 0.
	self MoveR: t0 R: t2.
	self AndCq: objectMemory getMemoryMap getSpaceMaskToUse R: t2.
	self CmpCq: objectMemory getMemoryMap getOldSpaceMask R: t2.
	jump3 := self JumpNonZero: 0.
	self MoveR: t1 R: t2.
	self AndCq: 7 R: t2.
	self CmpCq: 0 R: t2.
	jump4 := self JumpNonZero: 0.
	self MoveR: t1 R: t2.
	self AndCq: objectMemory getMemoryMap getSpaceMaskToUse R: t2.
	self CmpCq: objectMemory getMemoryMap getNewSpaceMask R: t2.
	jump5 := self JumpNonZero: 0.
	self MoveR: t1 R: t2.
	self CmpCq: objectMemory getMemoryMap getNewSpaceStart R: t2.
	jumpTrue := self JumpAboveOrEqual: 0.
	self MoveCq: 0 R: t2.
	jumpNext := self Jump: 0.
	jumpTrue jmpTarget: self Label.
	self MoveCq: 1 R: t2.
	jumpNext jmpTarget: self Label.
	self CmpCq: 1 R: t2.
	jump6 := self JumpNonZero: 0.
	self MoveM64: 0 r: t0 R: t2.
	self ArithmeticShiftRightCq: 29 R: t2.
	self AndCq: 1 R: t2.
	self CmpCq: 0 R: t2.
	jump7 := self JumpNonZero: 0.
	self MoveR: t0 R: TempReg.
	backEnd saveAndRestoreLinkRegAround: [
		self CallRT: ceStoreCheckTrampoline ].
	self TstCq: 7 R: t1.
	jump8 := self JumpNonZero: 0.
	jump9 := self JumpZero: 0.
	currentBlock := self Label.
	jump5 jmpTarget: currentBlock.
	self MoveCq: 0 R: t2.
	currentBlock := self Label.
	jump6 jmpTarget: currentBlock.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	jump3 jmpTarget: currentBlock.
	jump4 jmpTarget: currentBlock.
	jump7 jmpTarget: currentBlock.
	self TstCq: 7 R: t1.
	jump7 := self JumpNonZero: 0.
	currentBlock := self Label.
	jump9 jmpTarget: currentBlock.
	self CmpCq: objectMemory nilObject R: t1.
	jump9 := self JumpBelow: 0.
	self MoveR: t1 R: t2.
	self CmpCq: objectMemory trueObject R: t2.
	jumpTrue := self JumpBelowOrEqual: 0.
	self MoveCq: 0 R: t2.
	jumpNext := self Jump: 0.
	jumpTrue jmpTarget: self Label.
	self MoveCq: 1 R: t2.
	jumpNext jmpTarget: self Label.
	jump4 := self Jump: 0.
	currentBlock := self Label.
	jump9 jmpTarget: currentBlock.
	self MoveCq: 0 R: t2.
	currentBlock := self Label.
	jump4 jmpTarget: currentBlock.
	self CmpCq: 1 R: t2.
	jump4 := self JumpZero: 0.
	self CmpCq: objectMemory getMemoryMap getNewSpaceStart R: t1.
	jump9 := self JumpBelow: 0.
	self MoveM64: 0 r: t0 R: t2.
	self ArithmeticShiftRightCq: 29 R: t2.
	self AndCq: 1 R: t2.
	self CmpCq: 0 R: t2.
	jump3 := self JumpNonZero: 0.
	self MoveR: t0 R: t2.
	self AndCq: 7 R: t2.
	self CmpCq: 0 R: t2.
	jump1 := self JumpNonZero: 0.
	self MoveR: t0 R: t2.
	self AndCq: objectMemory getMemoryMap getSpaceMaskToUse R: t2.
	self CmpCq: objectMemory getMemoryMap getPermSpaceMask R: t2.
	jumpTrue := self JumpZero: 0.
	self MoveCq: 0 R: t2.
	jumpNext := self Jump: 0.
	jumpTrue jmpTarget: self Label.
	self MoveCq: 1 R: t2.
	jumpNext jmpTarget: self Label.
	jump6 := self Jump: 0.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	self MoveCq: 0 R: t2.
	currentBlock := self Label.
	jump6 jmpTarget: currentBlock.
	self CmpCq: 1 R: t2.
	jump6 := self JumpNonZero: 0.
	self MoveR: t1 R: t2.
	self AndCq: objectMemory getMemoryMap getSpaceMaskToUse R: t2.
	self CmpCq: objectMemory getMemoryMap getPermSpaceMask R: t2.
	jump1 := self JumpZero: 0.
	self MoveR: t0 R: TempReg.
	backEnd saveAndRestoreLinkRegAround: [
		self CallRT: ceStoreCheckTrampoline ].
	currentBlock := self Label.
	jump8 jmpTarget: currentBlock.
	jump7 jmpTarget: currentBlock.
	jump4 jmpTarget: currentBlock.
	jump9 jmpTarget: currentBlock.
	jump3 jmpTarget: currentBlock.
	jump6 jmpTarget: currentBlock.
	jump1 jmpTarget: currentBlock.
	self MoveR: t1 M64: 16 r: t0.
	currentBlock := self Label.
	jump2 jmpTarget: currentBlock.
	^ 0
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_StoreAndPopReceiverVariableBytecode2 [
	"AutoGenerated by Druid"

	| jump1 jump7 jumpNext t1 jump6 jump3 jump9 currentBlock t0 jump5 jump2 jumpTrue jump8 live t2 jump4 |
	live := 0.
	self annotateBytecode: self Label.
	self ensureReceiverResultRegContainsSelf.
	t0 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t0).
	self MoveR: ReceiverResultReg R: t0.
	t1 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t1).
	(self ssValue: 0) copyToReg: t1.
	t2 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t2).
	self MoveM64: 0 r: t0 R: t2.
	self ArithmeticShiftRightCq: 23 R: t2.
	self AndCq: 1 R: t2.
	self ssFlushStack.
	self CmpCq: 0 R: t2.
	jump1 := self JumpZero: 0.
	self deoptimize.
	jump2 := self Jump: 0.
	deadCode := false.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	self ssPop: 1.
	self MoveR: t0 R: t2.
	self AndCq: 7 R: t2.
	self CmpCq: 0 R: t2.
	jump1 := self JumpNonZero: 0.
	self MoveR: t0 R: t2.
	self AndCq: objectMemory getMemoryMap getSpaceMaskToUse R: t2.
	self CmpCq: objectMemory getMemoryMap getOldSpaceMask R: t2.
	jump3 := self JumpNonZero: 0.
	self MoveR: t1 R: t2.
	self AndCq: 7 R: t2.
	self CmpCq: 0 R: t2.
	jump4 := self JumpNonZero: 0.
	self MoveR: t1 R: t2.
	self AndCq: objectMemory getMemoryMap getSpaceMaskToUse R: t2.
	self CmpCq: objectMemory getMemoryMap getNewSpaceMask R: t2.
	jump5 := self JumpNonZero: 0.
	self MoveR: t1 R: t2.
	self CmpCq: objectMemory getMemoryMap getNewSpaceStart R: t2.
	jumpTrue := self JumpAboveOrEqual: 0.
	self MoveCq: 0 R: t2.
	jumpNext := self Jump: 0.
	jumpTrue jmpTarget: self Label.
	self MoveCq: 1 R: t2.
	jumpNext jmpTarget: self Label.
	self CmpCq: 1 R: t2.
	jump6 := self JumpNonZero: 0.
	self MoveM64: 0 r: t0 R: t2.
	self ArithmeticShiftRightCq: 29 R: t2.
	self AndCq: 1 R: t2.
	self CmpCq: 0 R: t2.
	jump7 := self JumpNonZero: 0.
	self MoveR: t0 R: TempReg.
	backEnd saveAndRestoreLinkRegAround: [
		self CallRT: ceStoreCheckTrampoline ].
	self TstCq: 7 R: t1.
	jump8 := self JumpNonZero: 0.
	jump9 := self JumpZero: 0.
	currentBlock := self Label.
	jump5 jmpTarget: currentBlock.
	self MoveCq: 0 R: t2.
	currentBlock := self Label.
	jump6 jmpTarget: currentBlock.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	jump3 jmpTarget: currentBlock.
	jump4 jmpTarget: currentBlock.
	jump7 jmpTarget: currentBlock.
	self TstCq: 7 R: t1.
	jump7 := self JumpNonZero: 0.
	currentBlock := self Label.
	jump9 jmpTarget: currentBlock.
	self CmpCq: objectMemory nilObject R: t1.
	jump9 := self JumpBelow: 0.
	self MoveR: t1 R: t2.
	self CmpCq: objectMemory trueObject R: t2.
	jumpTrue := self JumpBelowOrEqual: 0.
	self MoveCq: 0 R: t2.
	jumpNext := self Jump: 0.
	jumpTrue jmpTarget: self Label.
	self MoveCq: 1 R: t2.
	jumpNext jmpTarget: self Label.
	jump4 := self Jump: 0.
	currentBlock := self Label.
	jump9 jmpTarget: currentBlock.
	self MoveCq: 0 R: t2.
	currentBlock := self Label.
	jump4 jmpTarget: currentBlock.
	self CmpCq: 1 R: t2.
	jump4 := self JumpZero: 0.
	self CmpCq: objectMemory getMemoryMap getNewSpaceStart R: t1.
	jump9 := self JumpBelow: 0.
	self MoveM64: 0 r: t0 R: t2.
	self ArithmeticShiftRightCq: 29 R: t2.
	self AndCq: 1 R: t2.
	self CmpCq: 0 R: t2.
	jump3 := self JumpNonZero: 0.
	self MoveR: t0 R: t2.
	self AndCq: 7 R: t2.
	self CmpCq: 0 R: t2.
	jump1 := self JumpNonZero: 0.
	self MoveR: t0 R: t2.
	self AndCq: objectMemory getMemoryMap getSpaceMaskToUse R: t2.
	self CmpCq: objectMemory getMemoryMap getPermSpaceMask R: t2.
	jumpTrue := self JumpZero: 0.
	self MoveCq: 0 R: t2.
	jumpNext := self Jump: 0.
	jumpTrue jmpTarget: self Label.
	self MoveCq: 1 R: t2.
	jumpNext jmpTarget: self Label.
	jump6 := self Jump: 0.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	self MoveCq: 0 R: t2.
	currentBlock := self Label.
	jump6 jmpTarget: currentBlock.
	self CmpCq: 1 R: t2.
	jump6 := self JumpNonZero: 0.
	self MoveR: t1 R: t2.
	self AndCq: objectMemory getMemoryMap getSpaceMaskToUse R: t2.
	self CmpCq: objectMemory getMemoryMap getPermSpaceMask R: t2.
	jump1 := self JumpZero: 0.
	self MoveR: t0 R: TempReg.
	backEnd saveAndRestoreLinkRegAround: [
		self CallRT: ceStoreCheckTrampoline ].
	currentBlock := self Label.
	jump8 jmpTarget: currentBlock.
	jump7 jmpTarget: currentBlock.
	jump4 jmpTarget: currentBlock.
	jump9 jmpTarget: currentBlock.
	jump3 jmpTarget: currentBlock.
	jump6 jmpTarget: currentBlock.
	jump1 jmpTarget: currentBlock.
	self MoveR: t1 M64: 24 r: t0.
	currentBlock := self Label.
	jump2 jmpTarget: currentBlock.
	^ 0
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_StoreAndPopReceiverVariableBytecode3 [
	"AutoGenerated by Druid"

	| jump1 jump7 jumpNext t1 jump6 jump3 jump9 currentBlock t0 jump5 jump2 jumpTrue jump8 live t2 jump4 |
	live := 0.
	self annotateBytecode: self Label.
	self ensureReceiverResultRegContainsSelf.
	t0 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t0).
	self MoveR: ReceiverResultReg R: t0.
	t1 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t1).
	(self ssValue: 0) copyToReg: t1.
	t2 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t2).
	self MoveM64: 0 r: t0 R: t2.
	self ArithmeticShiftRightCq: 23 R: t2.
	self AndCq: 1 R: t2.
	self ssFlushStack.
	self CmpCq: 0 R: t2.
	jump1 := self JumpZero: 0.
	self deoptimize.
	jump2 := self Jump: 0.
	deadCode := false.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	self ssPop: 1.
	self MoveR: t0 R: t2.
	self AndCq: 7 R: t2.
	self CmpCq: 0 R: t2.
	jump1 := self JumpNonZero: 0.
	self MoveR: t0 R: t2.
	self AndCq: objectMemory getMemoryMap getSpaceMaskToUse R: t2.
	self CmpCq: objectMemory getMemoryMap getOldSpaceMask R: t2.
	jump3 := self JumpNonZero: 0.
	self MoveR: t1 R: t2.
	self AndCq: 7 R: t2.
	self CmpCq: 0 R: t2.
	jump4 := self JumpNonZero: 0.
	self MoveR: t1 R: t2.
	self AndCq: objectMemory getMemoryMap getSpaceMaskToUse R: t2.
	self CmpCq: objectMemory getMemoryMap getNewSpaceMask R: t2.
	jump5 := self JumpNonZero: 0.
	self MoveR: t1 R: t2.
	self CmpCq: objectMemory getMemoryMap getNewSpaceStart R: t2.
	jumpTrue := self JumpAboveOrEqual: 0.
	self MoveCq: 0 R: t2.
	jumpNext := self Jump: 0.
	jumpTrue jmpTarget: self Label.
	self MoveCq: 1 R: t2.
	jumpNext jmpTarget: self Label.
	self CmpCq: 1 R: t2.
	jump6 := self JumpNonZero: 0.
	self MoveM64: 0 r: t0 R: t2.
	self ArithmeticShiftRightCq: 29 R: t2.
	self AndCq: 1 R: t2.
	self CmpCq: 0 R: t2.
	jump7 := self JumpNonZero: 0.
	self MoveR: t0 R: TempReg.
	backEnd saveAndRestoreLinkRegAround: [
		self CallRT: ceStoreCheckTrampoline ].
	self TstCq: 7 R: t1.
	jump8 := self JumpNonZero: 0.
	jump9 := self JumpZero: 0.
	currentBlock := self Label.
	jump5 jmpTarget: currentBlock.
	self MoveCq: 0 R: t2.
	currentBlock := self Label.
	jump6 jmpTarget: currentBlock.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	jump3 jmpTarget: currentBlock.
	jump4 jmpTarget: currentBlock.
	jump7 jmpTarget: currentBlock.
	self TstCq: 7 R: t1.
	jump7 := self JumpNonZero: 0.
	currentBlock := self Label.
	jump9 jmpTarget: currentBlock.
	self CmpCq: objectMemory nilObject R: t1.
	jump9 := self JumpBelow: 0.
	self MoveR: t1 R: t2.
	self CmpCq: objectMemory trueObject R: t2.
	jumpTrue := self JumpBelowOrEqual: 0.
	self MoveCq: 0 R: t2.
	jumpNext := self Jump: 0.
	jumpTrue jmpTarget: self Label.
	self MoveCq: 1 R: t2.
	jumpNext jmpTarget: self Label.
	jump4 := self Jump: 0.
	currentBlock := self Label.
	jump9 jmpTarget: currentBlock.
	self MoveCq: 0 R: t2.
	currentBlock := self Label.
	jump4 jmpTarget: currentBlock.
	self CmpCq: 1 R: t2.
	jump4 := self JumpZero: 0.
	self CmpCq: objectMemory getMemoryMap getNewSpaceStart R: t1.
	jump9 := self JumpBelow: 0.
	self MoveM64: 0 r: t0 R: t2.
	self ArithmeticShiftRightCq: 29 R: t2.
	self AndCq: 1 R: t2.
	self CmpCq: 0 R: t2.
	jump3 := self JumpNonZero: 0.
	self MoveR: t0 R: t2.
	self AndCq: 7 R: t2.
	self CmpCq: 0 R: t2.
	jump1 := self JumpNonZero: 0.
	self MoveR: t0 R: t2.
	self AndCq: objectMemory getMemoryMap getSpaceMaskToUse R: t2.
	self CmpCq: objectMemory getMemoryMap getPermSpaceMask R: t2.
	jumpTrue := self JumpZero: 0.
	self MoveCq: 0 R: t2.
	jumpNext := self Jump: 0.
	jumpTrue jmpTarget: self Label.
	self MoveCq: 1 R: t2.
	jumpNext jmpTarget: self Label.
	jump6 := self Jump: 0.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	self MoveCq: 0 R: t2.
	currentBlock := self Label.
	jump6 jmpTarget: currentBlock.
	self CmpCq: 1 R: t2.
	jump6 := self JumpNonZero: 0.
	self MoveR: t1 R: t2.
	self AndCq: objectMemory getMemoryMap getSpaceMaskToUse R: t2.
	self CmpCq: objectMemory getMemoryMap getPermSpaceMask R: t2.
	jump1 := self JumpZero: 0.
	self MoveR: t0 R: TempReg.
	backEnd saveAndRestoreLinkRegAround: [
		self CallRT: ceStoreCheckTrampoline ].
	currentBlock := self Label.
	jump8 jmpTarget: currentBlock.
	jump7 jmpTarget: currentBlock.
	jump4 jmpTarget: currentBlock.
	jump9 jmpTarget: currentBlock.
	jump3 jmpTarget: currentBlock.
	jump6 jmpTarget: currentBlock.
	jump1 jmpTarget: currentBlock.
	self MoveR: t1 M64: 32 r: t0.
	currentBlock := self Label.
	jump2 jmpTarget: currentBlock.
	^ 0
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_assertIsIgnored [

	| currentBlock |
	self MoveCq: 17 R: ReceiverResultReg.
	self RetN: 1 * objectMemory wordSize.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_branchingWithAssigments [

	| currentBlock jump0 jump1 |
	self CmpCq: 0 R: ReceiverResultReg.
	jump0 := self JumpLessOrEqual: 0.
	self MoveCq: 17 R: ReceiverResultReg.
	jump1 := self Jump: 0.
	currentBlock := self Label.
	jump0 jmpTarget: currentBlock.
	self MoveCq: 42 R: ReceiverResultReg.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	self RetN: 1 * objectMemory wordSize.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_bytecodePrimAdd [
	"AutoGenerated by Druid"

	| live currentBlock |
	live := 0.
	self marshallSendArguments: 1.
	self
		genMarshalledSend: -1
		numArgs: 1
		sendTable: ordinarySendTrampolines.
	^ 0
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_bytecodeWithDeoptimisation [
	"AutoGenerated by Druid"

	| live currentBlock |
	live := 0.
	self ssFlushStack.
	self deoptimize.
	^ 0
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_bytecodeWithFlushStackOnDominator [
	"AutoGenerated by Druid"

	| t0 jump1 currentBlock jump2 live |
	live := 0.
	self annotateBytecode: self Label.
	t0 := self allocateRegNotConflictingWith: live ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t0).
	(self ssValue: 0) copyToReg: t0.
	self ssFlushStack.
	self CmpCq: 0 R: t0.
	jump1 := self JumpLessOrEqual: 0.
	self deoptimize.
	jump2 := self Jump: 0.
	deadCode := false.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	(self ssValue: 0) copyToReg: t0.
	self MoveR: t0 R: TempReg.
	self CallRT: ceSendMustBeBooleanTrampoline.
	currentBlock := self Label.
	jump2 jmpTarget: currentBlock.
	^ 0
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_bytecodeWithPop [
	"AutoGenerated by Druid"

	| live currentBlock |
	live := 0.
	self ssPop: 1.
	^ 0
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_bytecodeWithUnknownBytecodeSend [
	"AutoGenerated by Druid"

	| live currentBlock |
	live := 0.
	self deoptimize.
	^ 0
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_duplicateTopBytecode [
	"AutoGenerated by Druid"

	| live currentBlock t0 |
	live := 0.
	t0 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t0).
	(self ssValue: 0) copyToReg: t0.
	self ssPushRegister: t0.
	^ 0
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_emptyPrimitive [
	"AutoGenerated by Druid"

	| currentBlock |
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_emptyPrimitiveWithArguments [
	"AutoGenerated by Druid"

	| currentBlock |
	self MoveR: Arg0Reg R: TempReg.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_extBBytecode [
	"AutoGenerated by Druid"

	| s6 s3 s16 s10 s2 currentBlock s7 s4 s17 s11 live s9 |
	live := 0.
	s2 := byte1.
	s3 := numExtB.
	0 = s3 ifTrue: [
		127 < s2 ifTrue: [
			s6 := s2 - 256.
			s7 := s6.
			extB := s7.
			s16 := numExtB.
			s17 := s16 + 1.
			numExtB := s17.
			^ 0 ].
		s9 := extB.
		s10 := s9 << 8.
		s11 := s10 + s2.
		s7 := s11.
		extB := s7.
		s16 := numExtB.
		s17 := s16 + 1.
		numExtB := s17.
		^ 0 ].
	s9 := extB.
	s10 := s9 << 8.
	s11 := s10 + s2.
	s7 := s11.
	extB := s7.
	s16 := numExtB.
	s17 := s16 + 1.
	numExtB := s17.
	^ 0
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_extPushFullClosureBytecode [
	"AutoGenerated by Druid"

	| s4 s38 t3 s9 s2 s20 currentBlock t1 s19 s12 s7 b10 live s5 s39 s15 s3 s21 t2 s8 s26 t0 s18 s11 |
	live := 0.
	s2 := byte1.
	s3 := extA.
	s4 := s3 << 8.
	s5 := s2 + s4.
	extA := 0.
	s7 := byte2.
	s8 := s7 bitAnd: 63.
	s9 := s7 anyMask: 64.
	live := live bitOr: (self registerMaskFor: ReceiverResultReg).
	live := live bitOr: (self registerMaskFor: SendNumArgsReg).
	live := live bitOr: (self registerMaskFor: ClassReg).
	self voidReceiverResultRegContainsSelf.
	self
		ssAllocateCallReg: ReceiverResultReg
		and: SendNumArgsReg
		and: ClassReg.
	self
		genCreateFullClosureInIndex: s5
		numCopied: s8
		ignoreContext: s9
		contextNumArgs: methodOrBlockNumArgs
		large: (coInterpreter methodNeedsLargeContext: methodObj)
		inBlock: inBlock
		intoRegister: ReceiverResultReg.
	t0 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t0).
	self MoveR: ReceiverResultReg R: t0.
	s11 := 1.
	s12 := s11.
	b10 := self Label.
	t1 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t1).
	t2 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t2).
	t3 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t3).
	[ ((s12<=s8)) ] whileTrue: [
		(self ssValue: 0) copyToReg: t1.
		self ssPop: 1.
		s18 := FullClosureFirstCopiedValueIndex.
		s19 := s18 + s8.
		s20 := s19 - s12.
		s21 := s20 << 3.
		self MoveCq: s21 R: t2.
		self MoveR: t0 R: t3.
		self AddR: t2 R: t3.
		self MoveR: t1 M64: 8 r: t3.
		s26 := s12 + 1.
		s12 := s26 ].
	(s7 anyMask: 128) ifTrue: [
		(self ssValue: 0) copyToReg: t3.
		self ssPop: 1.
		self MoveR: t3 R: t2.
		s38 := FullClosureReceiverIndex.
		s39 := s38 << 3.
		self MoveCq: s39 R: t3.
		self MoveR: t0 R: t1.
		self AddR: t3 R: t1.
		self MoveR: t2 M64: 8 r: t1.
		self ssPushRegister: t0.
		^ 0 ].
	self ensureReceiverResultRegContainsSelf.
	self MoveR: ReceiverResultReg R: t2.
	s38 := FullClosureReceiverIndex.
	s39 := s38 << 3.
	self MoveCq: s39 R: t3.
	self MoveR: t0 R: t1.
	self AddR: t3 R: t1.
	self MoveR: t2 M64: 8 r: t1.
	self ssPushRegister: t0.
	^ 0
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_extPushIntegerBytecode [
	"AutoGenerated by Druid"

	| s5 s8 s4 s2 currentBlock s9 s10 live s3 |
	live := 0.
	s2 := byte1.
	s3 := extB.
	s4 := s3 << 8.
	s5 := s2 + s4.
	extB := 0.
	numExtB := 0.
	s8 := s2 + s4.
	s9 := s8 << 3.
	s10 := s9 + 1.
	self ssPushConstant: s10.
	^ 0
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_extSendSuperBytecode [
	"AutoGenerated by Druid"

	| s6 s3 s16 s10 s8 s5 s2 s18 currentBlock s15 s4 s17 live s9 |
	live := 0.
	s2 := byte1.
	s3 := s2 >> 3.
	s4 := extA.
	s5 := s4 << 5.
	s6 := s3 + s5.
	extA := 0.
	s8 := BytecodeSetHasDirectedSuperSend.
	s8 ifTrue: [
		s10 := extB.
		s10 >= 64 ifTrue: [
			self ssFlushStack.
			self deoptimize.
			deadCode := false.
			^ 0 ].
		s15 := s2 bitAnd: 7.
		s16 := extB.
		s17 := s16 << 3.
		s18 := s15 + s17.
		extB := 0.
		numExtB := 0.
		self marshallSendArguments: s18.
		self
			genMarshalledSend: s6
			numArgs: s18
			sendTable: superSendTrampolines.
		^ 0 ].
	s15 := s2 bitAnd: 7.
	s16 := extB.
	s17 := s16 << 3.
	s18 := s15 + s17.
	extB := 0.
	numExtB := 0.
	self marshallSendArguments: s18.
	self
		genMarshalledSend: s6
		numArgs: s18
		sendTable: superSendTrampolines.
	^ 0
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_extStoreReceiverVariableBytecode [
	"AutoGenerated by Druid"

	| t2 jump6 jump10 s18 t3 jump7 jump8 s83 s96 jump9 s44 s106 s2 jumpTrue s3 s72 s4 s35 s48 live s5 s6 s64 s110 s39 s9 s78 s50 s66 jump1 s13 jump2 s114 jump3 t0 jump4 s92 currentBlock t1 jump5 jumpNext s101 |
	live := 0.
	self annotateBytecode: self Label.
	s3 := byte1.
	s4 := extA.
	s5 := s4 << 8.
	s6 := s3 + s5.
	t0 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t0).
	(self ssValue: 0) copyToReg: t0.
	self ensureReceiverResultRegContainsSelf.
	t1 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t1).
	self MoveR: ReceiverResultReg R: t1.
	s9 := ReceiverIndex.
	t2 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t2).
	t3 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t3).
	s6 <= s9 ifTrue: [
		| jump1 jump10 jumpNext jump9 jump6 jump3 jump8 jump5 jumpTrue jump2 jump7 jump4 |
		self MoveM64: 0 r: t1 R: t2.
		self AndCq: 16r3FFFFF R: t2.
		s13 := ClassMethodContextCompactIndex.
		self MoveCq: s13 R: t3.
		self CmpR: t3 R: t2.
		jumpTrue := self JumpZero: 0.
		self MoveCq: 0 R: t2.
		jumpNext := self Jump: 0.
		jumpTrue jmpTarget: self Label.
		self MoveCq: 1 R: t2.
		jumpNext jmpTarget: self Label.
		self MoveR: t2 R: t3.
		self ssFlushStack.
		self CmpCq: 1 R: t3.
		jump1 := self JumpNonZero: 0.
		self deoptimize.
		jump2 := self Jump: 0.
		deadCode := false.
		currentBlock := self Label.
		jump1 jmpTarget: currentBlock.
		self MoveM64: 0 r: t1 R: t3.
		self ArithmeticShiftRightCq: 23 R: t3.
		self AndCq: 1 R: t3.
		self CmpCq: 0 R: t3.
		jump1 := self JumpZero: 0.
		self deoptimize.
		jump3 := self Jump: 0.
		deadCode := false.
		currentBlock := self Label.
		jump1 jmpTarget: currentBlock.
		self MoveR: t1 R: t3.
		self AndCq: 7 R: t3.
		self CmpCq: 0 R: t3.
		jump1 := self JumpNonZero: 0.
		s35 := objectMemory getMemoryMap getSpaceMaskToUse.
		self MoveCq: s35 R: t3.
		self MoveR: t1 R: t2.
		self AndR: t3 R: t2.
		s39 := objectMemory getMemoryMap getOldSpaceMask.
		self CmpCq: s39 R: t2.
		jump4 := self JumpNonZero: 0.
		self MoveR: t0 R: t2.
		self AndCq: 7 R: t2.
		self CmpCq: 0 R: t2.
		jump5 := self JumpNonZero: 0.
		s44 := objectMemory getMemoryMap getSpaceMaskToUse.
		self MoveCq: s44 R: t2.
		self MoveR: t0 R: t3.
		self AndR: t2 R: t3.
		s48 := objectMemory getMemoryMap getNewSpaceMask.
		self CmpCq: s48 R: t3.
		jump6 := self JumpNonZero: 0.
		s50 := objectMemory getMemoryMap getNewSpaceStart.
		self MoveCq: s50 R: t3.
		self MoveR: t0 R: t2.
		self CmpR: t3 R: t2.
		jumpTrue := self JumpAboveOrEqual: 0.
		self MoveCq: 0 R: t2.
		jumpNext := self Jump: 0.
		jumpTrue jmpTarget: self Label.
		self MoveCq: 1 R: t2.
		jumpNext jmpTarget: self Label.
		self CmpCq: 1 R: t2.
		jump7 := self JumpNonZero: 0.
		self MoveM64: 0 r: t1 R: t2.
		self ArithmeticShiftRightCq: 29 R: t2.
		self AndCq: 1 R: t2.
		self CmpCq: 0 R: t2.
		jump8 := self JumpNonZero: 0.
		self MoveR: t1 R: TempReg.
		backEnd saveAndRestoreLinkRegAround: [
			self CallRT: ceStoreCheckTrampoline ].
		self TstCq: 7 R: t0.
		jump9 := self JumpNonZero: 0.
		jump10 := self JumpZero: 0.
		currentBlock := self Label.
		jump6 jmpTarget: currentBlock.
		s64 := 0.
		s66 := s64.
		currentBlock := self Label.
		jump7 jmpTarget: currentBlock.
		currentBlock := self Label.
		jump1 jmpTarget: currentBlock.
		jump4 jmpTarget: currentBlock.
		jump5 jmpTarget: currentBlock.
		jump8 jmpTarget: currentBlock.
		self TstCq: 7 R: t0.
		jump8 := self JumpNonZero: 0.
		currentBlock := self Label.
		jump10 jmpTarget: currentBlock.
		self genMoveConstant: objectMemory nilObject R: t2.
		self CmpR: t2 R: t0.
		jump10 := self JumpBelow: 0.
		s72 := objectMemory trueObject.
		self MoveCq: s72 R: t2.
		self MoveR: t0 R: t3.
		self CmpR: t2 R: t3.
		jumpTrue := self JumpBelowOrEqual: 0.
		self MoveCq: 0 R: t3.
		jumpNext := self Jump: 0.
		jumpTrue jmpTarget: self Label.
		self MoveCq: 1 R: t3.
		jumpNext jmpTarget: self Label.
		jump5 := self Jump: 0.
		currentBlock := self Label.
		jump10 jmpTarget: currentBlock.
		s78 := 0.
		self MoveCq: s78 R: t3.
		currentBlock := self Label.
		jump5 jmpTarget: currentBlock.
		self CmpCq: 1 R: t3.
		jump5 := self JumpZero: 0.
		s83 := objectMemory getMemoryMap getNewSpaceStart.
		self CmpCq: s83 R: t0.
		jump10 := self JumpBelow: 0.
		self MoveM64: 0 r: t1 R: t3.
		self ArithmeticShiftRightCq: 29 R: t3.
		self AndCq: 1 R: t3.
		self CmpCq: 0 R: t3.
		jump4 := self JumpNonZero: 0.
		self MoveR: t1 R: t3.
		self AndCq: 7 R: t3.
		self CmpCq: 0 R: t3.
		jump1 := self JumpNonZero: 0.
		s92 := objectMemory getMemoryMap getSpaceMaskToUse.
		self MoveCq: s92 R: t3.
		self MoveR: t1 R: t2.
		self AndR: t3 R: t2.
		s96 := objectMemory getMemoryMap getPermSpaceMask.
		self MoveCq: s96 R: t3.
		self CmpR: t3 R: t2.
		jumpTrue := self JumpZero: 0.
		self MoveCq: 0 R: t2.
		jumpNext := self Jump: 0.
		jumpTrue jmpTarget: self Label.
		self MoveCq: 1 R: t2.
		jumpNext jmpTarget: self Label.
		self MoveR: t2 R: t3.
		jump7 := self Jump: 0.
		currentBlock := self Label.
		jump1 jmpTarget: currentBlock.
		s101 := 0.
		self MoveCq: s101 R: t3.
		currentBlock := self Label.
		jump7 jmpTarget: currentBlock.
		self CmpCq: 1 R: t3.
		jump7 := self JumpNonZero: 0.
		s106 := objectMemory getMemoryMap getSpaceMaskToUse.
		self MoveCq: s106 R: t3.
		self MoveR: t0 R: t2.
		self AndR: t3 R: t2.
		s110 := objectMemory getMemoryMap getPermSpaceMask.
		self CmpCq: s110 R: t2.
		jump1 := self JumpZero: 0.
		self MoveR: t1 R: TempReg.
		backEnd saveAndRestoreLinkRegAround: [
			self CallRT: ceStoreCheckTrampoline ].
		currentBlock := self Label.
		jump9 jmpTarget: currentBlock.
		jump8 jmpTarget: currentBlock.
		jump5 jmpTarget: currentBlock.
		jump10 jmpTarget: currentBlock.
		jump4 jmpTarget: currentBlock.
		jump7 jmpTarget: currentBlock.
		jump1 jmpTarget: currentBlock.
		s114 := s6 << 3.
		self MoveCq: s114 R: t2.
		self AddR: t2 R: t1.
		self MoveR: t0 M64: 8 r: t1.
		currentBlock := self Label.
		jump2 jmpTarget: currentBlock.
		jump3 jmpTarget: currentBlock.
		extA := 0.
		^ 0 ].
	s18 := 0.
	self MoveCq: s18 R: t3.
	self ssFlushStack.
	self CmpCq: 1 R: t3.
	jump3 := self JumpNonZero: 0.
	self deoptimize.
	jump2 := self Jump: 0.
	deadCode := false.
	currentBlock := self Label.
	jump3 jmpTarget: currentBlock.
	self MoveM64: 0 r: t1 R: t3.
	self ArithmeticShiftRightCq: 23 R: t3.
	self AndCq: 1 R: t3.
	self CmpCq: 0 R: t3.
	jump3 := self JumpZero: 0.
	self deoptimize.
	jump1 := self Jump: 0.
	deadCode := false.
	currentBlock := self Label.
	jump3 jmpTarget: currentBlock.
	self MoveR: t1 R: t3.
	self AndCq: 7 R: t3.
	self CmpCq: 0 R: t3.
	jump3 := self JumpNonZero: 0.
	s35 := objectMemory getMemoryMap getSpaceMaskToUse.
	self MoveCq: s35 R: t3.
	self MoveR: t1 R: t2.
	self AndR: t3 R: t2.
	s39 := objectMemory getMemoryMap getOldSpaceMask.
	self CmpCq: s39 R: t2.
	jump7 := self JumpNonZero: 0.
	self MoveR: t0 R: t2.
	self AndCq: 7 R: t2.
	self CmpCq: 0 R: t2.
	jump4 := self JumpNonZero: 0.
	s44 := objectMemory getMemoryMap getSpaceMaskToUse.
	self MoveCq: s44 R: t2.
	self MoveR: t0 R: t3.
	self AndR: t2 R: t3.
	s48 := objectMemory getMemoryMap getNewSpaceMask.
	self CmpCq: s48 R: t3.
	jump10 := self JumpNonZero: 0.
	s50 := objectMemory getMemoryMap getNewSpaceStart.
	self MoveCq: s50 R: t3.
	self MoveR: t0 R: t2.
	self CmpR: t3 R: t2.
	jumpTrue := self JumpAboveOrEqual: 0.
	self MoveCq: 0 R: t2.
	jumpNext := self Jump: 0.
	jumpTrue jmpTarget: self Label.
	self MoveCq: 1 R: t2.
	jumpNext jmpTarget: self Label.
	self CmpCq: 1 R: t2.
	jump5 := self JumpNonZero: 0.
	self MoveM64: 0 r: t1 R: t2.
	self ArithmeticShiftRightCq: 29 R: t2.
	self AndCq: 1 R: t2.
	self CmpCq: 0 R: t2.
	jump8 := self JumpNonZero: 0.
	self MoveR: t1 R: TempReg.
	backEnd saveAndRestoreLinkRegAround: [
		self CallRT: ceStoreCheckTrampoline ].
	self TstCq: 7 R: t0.
	jump9 := self JumpNonZero: 0.
	jump6 := self JumpZero: 0.
	currentBlock := self Label.
	jump10 jmpTarget: currentBlock.
	s64 := 0.
	s66 := s64.
	currentBlock := self Label.
	jump5 jmpTarget: currentBlock.
	currentBlock := self Label.
	jump3 jmpTarget: currentBlock.
	jump7 jmpTarget: currentBlock.
	jump4 jmpTarget: currentBlock.
	jump8 jmpTarget: currentBlock.
	self TstCq: 7 R: t0.
	jump8 := self JumpNonZero: 0.
	currentBlock := self Label.
	jump6 jmpTarget: currentBlock.
	self genMoveConstant: objectMemory nilObject R: t2.
	self CmpR: t2 R: t0.
	jump6 := self JumpBelow: 0.
	s72 := objectMemory trueObject.
	self MoveCq: s72 R: t2.
	self MoveR: t0 R: t3.
	self CmpR: t2 R: t3.
	jumpTrue := self JumpBelowOrEqual: 0.
	self MoveCq: 0 R: t3.
	jumpNext := self Jump: 0.
	jumpTrue jmpTarget: self Label.
	self MoveCq: 1 R: t3.
	jumpNext jmpTarget: self Label.
	jump4 := self Jump: 0.
	currentBlock := self Label.
	jump6 jmpTarget: currentBlock.
	s78 := 0.
	self MoveCq: s78 R: t3.
	currentBlock := self Label.
	jump4 jmpTarget: currentBlock.
	self CmpCq: 1 R: t3.
	jump4 := self JumpZero: 0.
	s83 := objectMemory getMemoryMap getNewSpaceStart.
	self CmpCq: s83 R: t0.
	jump6 := self JumpBelow: 0.
	self MoveM64: 0 r: t1 R: t3.
	self ArithmeticShiftRightCq: 29 R: t3.
	self AndCq: 1 R: t3.
	self CmpCq: 0 R: t3.
	jump7 := self JumpNonZero: 0.
	self MoveR: t1 R: t3.
	self AndCq: 7 R: t3.
	self CmpCq: 0 R: t3.
	jump3 := self JumpNonZero: 0.
	s92 := objectMemory getMemoryMap getSpaceMaskToUse.
	self MoveCq: s92 R: t3.
	self MoveR: t1 R: t2.
	self AndR: t3 R: t2.
	s96 := objectMemory getMemoryMap getPermSpaceMask.
	self MoveCq: s96 R: t3.
	self CmpR: t3 R: t2.
	jumpTrue := self JumpZero: 0.
	self MoveCq: 0 R: t2.
	jumpNext := self Jump: 0.
	jumpTrue jmpTarget: self Label.
	self MoveCq: 1 R: t2.
	jumpNext jmpTarget: self Label.
	self MoveR: t2 R: t3.
	jump5 := self Jump: 0.
	currentBlock := self Label.
	jump3 jmpTarget: currentBlock.
	s101 := 0.
	self MoveCq: s101 R: t3.
	currentBlock := self Label.
	jump5 jmpTarget: currentBlock.
	self CmpCq: 1 R: t3.
	jump5 := self JumpNonZero: 0.
	s106 := objectMemory getMemoryMap getSpaceMaskToUse.
	self MoveCq: s106 R: t3.
	self MoveR: t0 R: t2.
	self AndR: t3 R: t2.
	s110 := objectMemory getMemoryMap getPermSpaceMask.
	self CmpCq: s110 R: t2.
	jump3 := self JumpZero: 0.
	self MoveR: t1 R: TempReg.
	backEnd saveAndRestoreLinkRegAround: [
		self CallRT: ceStoreCheckTrampoline ].
	currentBlock := self Label.
	jump9 jmpTarget: currentBlock.
	jump8 jmpTarget: currentBlock.
	jump4 jmpTarget: currentBlock.
	jump6 jmpTarget: currentBlock.
	jump7 jmpTarget: currentBlock.
	jump5 jmpTarget: currentBlock.
	jump3 jmpTarget: currentBlock.
	s114 := s6 << 3.
	self MoveCq: s114 R: t2.
	self AddR: t2 R: t1.
	self MoveR: t0 M64: 8 r: t1.
	currentBlock := self Label.
	jump2 jmpTarget: currentBlock.
	jump1 jmpTarget: currentBlock.
	extA := 0.
	^ 0
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_extUnconditionalJump [
	"AutoGenerated by Druid"

	| s6 s3 s19 s28 s13 s10 t1 s8 s5 s2 jump1 currentBlock s27 t0 s4 live s11 s9 |
	live := 0.
	self annotateBytecode: self Label.
	s3 := byte1.
	s4 := extB.
	s5 := s4 << 8.
	s6 := s3 + s5.
	t0 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t0).
	t1 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t1).
	s6 < 0 ifTrue: [
		| jump1 |
		s8 := numExtB.
		s9 := 2.
		s10 := s9 * s8.
		s11 := s10.
		extB := 0.
		numExtB := 0.
		s19 := s6 + s11.
		self ssFlushStack.
		s19 >= 0 ifTrue: [
			s27 := s6 + bytecodePC.
			s28 := s27 + 2.
			self Jump: (self ensureFixupAt: s28).
			deadCode := true.
			^ 0 ].
		self MoveR: SPReg R: t0.
		self MoveAw: coInterpreter stackLimitAddress R: t1.
		self CmpR: t1 R: t0.
		jump1 := self JumpAboveOrEqual: 0.
		self CallRT: ceCheckForInterruptTrampoline.
		currentBlock := self Label.
		jump1 jmpTarget: currentBlock.
		s27 := s6 + bytecodePC.
		s28 := s27 + 2.
		self Jump: (self ensureFixupAt: s28).
		deadCode := true.
		^ 0 ].
	s13 := 0.
	s11 := s13.
	extB := 0.
	numExtB := 0.
	s19 := s6 + s11.
	self ssFlushStack.
	s19 >= 0 ifTrue: [
		s27 := s6 + bytecodePC.
		s28 := s27 + 2.
		self Jump: (self ensureFixupAt: s28).
		deadCode := true.
		^ 0 ].
	self MoveR: SPReg R: t0.
	self MoveAw: coInterpreter stackLimitAddress R: t1.
	self CmpR: t1 R: t0.
	jump1 := self JumpAboveOrEqual: 0.
	self CallRT: ceCheckForInterruptTrampoline.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	s27 := s6 + bytecodePC.
	s28 := s27 + 2.
	self Jump: (self ensureFixupAt: s28).
	deadCode := true.
	^ 0
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_extendedPushBytecode [
	"AutoGenerated by Druid"

	| s6 s4 s29 s2 t1 currentBlock s20 s19 s58 live s5 s3 s28 s30 s21 t2 s8 t0 s57 |
	live := 0.
	s2 := byte1.
	s3 := s2 >> 6.
	s4 := s3 bitAnd: 3.
	s5 := s2 bitAnd: 63.
	t0 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t0).
	t1 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t1).
	s4 = 0 ifTrue: [
		self ensureReceiverResultRegContainsSelf.
		self MoveR: ReceiverResultReg R: t0.
		s8 := s5 << 3.
		self MoveCq: s8 R: t1.
		self AddR: t1 R: t0.
		self ssPushBase: t0 offset: 8.
		^ 0 ].
	s4 = 1 ifTrue: [
		(self simStackTempAt: s5) copyToReg: t1.
		self ssPushRegister: t1.
		^ 0 ].
	s4 = 2 ifTrue: [
		self genMoveConstant: methodObj R: t1.
		s19 := LiteralStart.
		s20 := s5 + s19.
		s21 := s20 << 3.
		self MoveCq: s21 R: t0.
		self AddR: t0 R: t1.
		self ssPushBase: t1 offset: 8.
		^ 0 ].
	t2 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t2).
	s4 = 3 ifTrue: [
		| jumpNext jumpTrue jump1 jump3 b323 jump4 jump2 |
		self genMoveConstant: methodObj R: t0.
		s28 := LiteralStart.
		s29 := s5 + s28.
		s30 := s29 << 3.
		self MoveCq: s30 R: t1.
		self AddR: t1 R: t0.
		self MoveM64: 8 r: t0 R: t1.
		self MoveM64: 0 r: t1 R: t0.
		self AndCq: 16r3FFFF7 R: t0.
		self CmpCq: 0 R: t0.
		jump1 := self JumpNonZero: 0.
		self MoveM64: 8 r: t1 R: t0.
		b323 := self Label.
		self MoveR: t0 R: t1.
		self AndCq: 7 R: t1.
		self CmpCq: 0 R: t1.
		jump2 := self JumpNonZero: 0.
		self MoveM64: 0 r: t0 R: t1.
		self AndCq: 16r3FFFF7 R: t1.
		self MoveR: t1 R: t2.
		self CmpCq: 0 R: t2.
		jumpTrue := self JumpZero: 0.
		self MoveCq: 0 R: t2.
		jumpNext := self Jump: 0.
		jumpTrue jmpTarget: self Label.
		self MoveCq: 1 R: t2.
		jumpNext jmpTarget: self Label.
		self CmpCq: 0 R: t1.
		jump3 := self JumpNonZero: 0.
		self MoveM64: 8 r: t0 R: t2.
		self MoveR: t2 R: t0.
		jump4 := self Jump: b323.
		currentBlock := self Label.
		jump2 jmpTarget: currentBlock.
		jump3 jmpTarget: currentBlock.
		self MoveR: t0 R: t2.
		jump3 := self Jump: 0.
		currentBlock := self Label.
		jump1 jmpTarget: currentBlock.
		self MoveR: t1 R: t2.
		currentBlock := self Label.
		jump3 jmpTarget: currentBlock.
		s57 := ValueIndex.
		s58 := s57 << 3.
		self MoveCq: s58 R: t0.
		self AddR: t0 R: t2.
		self ssPushBase: t2 offset: 8.
		^ 0 ].
	^ 0
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_failingPrimitive [
	"AutoGenerated by Druid"

	| currentBlock |
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_failingPrimitive2 [

	| currentBlock |
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_failingPrimitiveWithArg [
	"AutoGenerated by Druid"

	| currentBlock |
	self MoveR: Arg0Reg R: TempReg.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_failingSuccess [
	"AutoGenerated by Druid"

	| currentBlock |
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_ifZeroFailPrimitive [
	"AutoGenerated by Druid"

	| jump1 currentBlock |
	self MoveR: ReceiverResultReg R: TempReg.
	self MoveR: Arg0Reg R: ClassReg.
	self CmpCq: 0 R: TempReg.
	jump1 := self JumpZero: 0.
	self MoveCq: 42 R: ReceiverResultReg.
	self genPrimReturn.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_passingSuccess [
	"AutoGenerated by Druid"

	| currentBlock |
	self MoveCq: 1 R: ReceiverResultReg.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveAccessTempAfterCall [
	"AutoGenerated by Druid"

	| currentBlock |
	self MoveCq: 17 R: ReceiverResultReg.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveAdd [
	"AutoGenerated by Druid"

	| jump1 jump2 currentBlock |
	self mclassIsSmallInteger ifFalse: [ ^ UnimplementedPrimitive ].
	self MoveR: ReceiverResultReg R: TempReg.
	self MoveR: Arg0Reg R: ClassReg.
	self TstCq: 1 R: ClassReg.
	jump1 := self JumpZero: 0.
	self AddCq:  -1 R: ClassReg.
	self AddR: TempReg R: ClassReg.
	jump2 := self JumpOverflow: 0.
	self MoveR: ClassReg R: ReceiverResultReg.
	self genPrimReturn.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	jump2 jmpTarget: currentBlock.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveAnd [
	"AutoGenerated by Druid"

	| jump1 jump2 jump3 currentBlock |
	self MoveR: ReceiverResultReg R: TempReg.
	self CmpCq: 0 R: TempReg.
	jump1 := self JumpLessOrEqual: 0.
	self CmpCq: 10 R: TempReg.
	jump2 := self JumpLessOrEqual: 0.
	self MoveCq: 42 R: ReceiverResultReg.
	jump3 := self Jump: 0.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	jump2 jmpTarget: currentBlock.
	self MoveCq: 10 R: ReceiverResultReg.
	currentBlock := self Label.
	jump3 jmpTarget: currentBlock.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveAndIfTrue [
	"AutoGenerated by Druid"

	| jump1 jump2 jump3 currentBlock |
	self MoveR: ReceiverResultReg R: TempReg.
	self CmpCq: 1 R: TempReg.
	jump1 := self JumpLessOrEqual: 0.
	self AndCq: 1 R: TempReg.
	self CmpCq: 1 R: TempReg.
	jump2 := self JumpNonZero: 0.
	self MoveCq: 1 R: ReceiverResultReg.
	jump3 := self Jump: 0.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	jump2 jmpTarget: currentBlock.
	self MoveCq: 2 R: ReceiverResultReg.
	currentBlock := self Label.
	jump3 jmpTarget: currentBlock.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveArithmeticBitShiftRight [
	"AutoGenerated by Druid"

	| currentBlock |
	self MoveR: ReceiverResultReg R: TempReg.
	self MoveR: Arg0Reg R: ClassReg.
	self ArithmeticShiftRightR: ClassReg R: TempReg.
	self MoveR: TempReg R: ReceiverResultReg.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveAsInteger [
	"AutoGenerated by Druid"

	| currentBlock |
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveAssertDeferredInline [
	"AutoGenerated by Druid"

	| jump1 jump2 jump3 currentBlock |
	self MoveCq: 0 R: TempReg.
	self MoveR: TempReg Aw: coInterpreter primitiveFailureCodeAddress.
	self MoveAw: coInterpreter primitiveFailureCodeAddress R: TempReg.
	self MoveR: ReceiverResultReg R: ClassReg.
	self CmpCq: 0 R: ClassReg.
	jump1 := self JumpNonZero: 0.
	self MoveR: TempReg Aw: coInterpreter primitiveFailureCodeAddress.
	self MoveCq: 1 R: ClassReg.
	self MoveR: ClassReg Aw: coInterpreter primitiveFailureCodeAddress.
	self MoveAw: coInterpreter primitiveFailureCodeAddress R: ClassReg.
	self MoveR: ClassReg Aw: coInterpreter primitiveFailureCodeAddress.
	self MoveAw: coInterpreter primitiveFailureCodeAddress R: ClassReg.
	self MoveCq: 42 R: ReceiverResultReg.
	self CmpCq: 0 R: ClassReg.
	jump2 := self JumpZero: 0.
	jump3 := self JumpNonZero: 0.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	self MoveR: TempReg Aw: coInterpreter primitiveFailureCodeAddress.
	self MoveAw: coInterpreter primitiveFailureCodeAddress R: ClassReg.
	self MoveCq: 42 R: ReceiverResultReg.
	self CmpCq: 0 R: ClassReg.
	jump1 := self JumpNonZero: 0.
	currentBlock := self Label.
	jump2 jmpTarget: currentBlock.
	self genPrimReturn.
	currentBlock := self Label.
	jump3 jmpTarget: currentBlock.
	jump1 jmpTarget: currentBlock.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveAssertIsIgnored [
	"AutoGenerated by Druid"

	| currentBlock |
	self MoveCq: 17 R: ReceiverResultReg.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveAt [
	"AutoGenerated by Druid"

	| jump1 jump7 jumpNext jump9 s68 jump3 jump6 s119 currentBlock s12 jump8 jump5 jumpTrue s162 s101 jump2 s150 jump4 |
	self SubCq: 16 R: SPReg.
	self MoveR: ReceiverResultReg R: Extra3Reg.
	self MoveR: Extra3Reg Mw: 0 r: SPReg.
	self MoveR: Arg0Reg R: Extra3Reg.
	self MoveR: Extra3Reg Mw: 8 r: SPReg.
	self MoveMw: 0 r: SPReg R: Extra3Reg.
	self TstCq: 7 R: Extra3Reg.
	jump1 := self JumpNonZero: 0.
	self MoveMw: 8 r: SPReg R: Extra3Reg.
	self MoveR: Extra3Reg R: SendNumArgsReg.
	self AndCq: 1 R: SendNumArgsReg.
	self MoveR: SendNumArgsReg R: Extra0Reg.
	self CmpCq: 0 R: Extra0Reg.
	jumpTrue := self JumpZero: 0.
	self MoveCq: 0 R: Extra0Reg.
	jumpNext := self Jump: 0.
	jumpTrue jmpTarget: self Label.
	self MoveCq: 1 R: Extra0Reg.
	jumpNext jmpTarget: self Label.
	self CmpCq: 0 R: SendNumArgsReg.
	jump2 := self JumpNonZero: 0.
	jump3 := self Jump: 0.
	currentBlock := self Label.
	jump2 jmpTarget: currentBlock.
	s12 := 0.
	self MoveCq: s12 R: Extra0Reg.
	currentBlock := self Label.
	jump3 jmpTarget: currentBlock.
	self CmpCq: 1 R: Extra0Reg.
	jump3 := self JumpZero: 0.
	self MoveMw: 8 r: SPReg R: Extra3Reg.
	self ArithmeticShiftRightCq: 3 R: Extra3Reg.
	self MoveR: Extra3Reg Mw: 8 r: SPReg.
	self MoveMw: 0 r: SPReg R: Extra3Reg.
	self MoveM64: 0 r: Extra3Reg R: Extra0Reg.
	self MoveR: Extra0Reg R: SendNumArgsReg.
	self ArithmeticShiftRightCq: 24 R: SendNumArgsReg.
	self AndCq: 31 R: SendNumArgsReg.
	self MoveMw: 0 r: SPReg R: Extra3Reg.
	self MoveMb: 7 r: Extra3Reg R: Extra1Reg.
	self AndCq: 255 R: Extra1Reg.
	self CmpCq: 255 R: Extra1Reg.
	jump2 := self JumpNonZero: 0.
	self MoveMw: 0 r: SPReg R: Extra3Reg.
	self MoveM64: -8 r: Extra3Reg R: Extra1Reg.
	self LogicalShiftLeftCq: 8 R: Extra1Reg.
	self ArithmeticShiftRightCq: 8 R: Extra1Reg.
	jump4 := self Jump: 0.
	currentBlock := self Label.
	jump2 jmpTarget: currentBlock.
	currentBlock := self Label.
	jump4 jmpTarget: currentBlock.
	self CmpCq: 5 R: SendNumArgsReg.
	jump4 := self JumpAbove: 0.
	jump2 := self Jump: 0.
	currentBlock := self Label.
	jump4 jmpTarget: currentBlock.
	self CmpCq: 16 R: SendNumArgsReg.
	jump4 := self JumpBelow: 0.
	self LogicalShiftLeftCq: 3 R: Extra1Reg.
	self MoveR: SendNumArgsReg R: Extra2Reg.
	self AndCq: 7 R: Extra2Reg.
	self SubR: Extra2Reg R: Extra1Reg.
	self MoveR: SendNumArgsReg R: Extra2Reg.
	self CmpCq: 9 R: Extra2Reg.
	jumpTrue := self JumpAboveOrEqual: 0.
	self MoveCq: 0 R: Extra2Reg.
	jumpNext := self Jump: 0.
	jumpTrue jmpTarget: self Label.
	self MoveCq: 1 R: Extra2Reg.
	jumpNext jmpTarget: self Label.
	jump5 := self Jump: 0.
	currentBlock := self Label.
	jump4 jmpTarget: currentBlock.
	self CmpCq: 12 R: SendNumArgsReg.
	jump4 := self JumpBelow: 0.
	self LogicalShiftLeftCq: 2 R: Extra1Reg.
	self MoveR: SendNumArgsReg R: Extra2Reg.
	self AndCq: 3 R: Extra2Reg.
	self SubR: Extra2Reg R: Extra1Reg.
	self MoveR: Extra1Reg R: Extra2Reg.
	self MoveR: SendNumArgsReg R: Extra1Reg.
	self CmpCq: 9 R: Extra1Reg.
	jumpTrue := self JumpAboveOrEqual: 0.
	self MoveCq: 0 R: Extra1Reg.
	jumpNext := self Jump: 0.
	jumpTrue jmpTarget: self Label.
	self MoveCq: 1 R: Extra1Reg.
	jumpNext jmpTarget: self Label.
	self MoveR: Extra1Reg R: TempReg.
	jump6 := self Jump: 0.
	currentBlock := self Label.
	jump4 jmpTarget: currentBlock.
	self CmpCq: 10 R: SendNumArgsReg.
	jump4 := self JumpBelow: 0.
	self LogicalShiftLeftCq: 1 R: Extra1Reg.
	self MoveR: SendNumArgsReg R: TempReg.
	self AndCq: 1 R: TempReg.
	self SubR: TempReg R: Extra1Reg.
	self MoveR: Extra1Reg R: TempReg.
	jump7 := self Jump: 0.
	currentBlock := self Label.
	jump4 jmpTarget: currentBlock.
	self CmpCq: 9 R: SendNumArgsReg.
	jump4 := self JumpNonZero: 0.
	self MoveR: Extra1Reg R: TempReg.
	jump8 := self Jump: 0.
	currentBlock := self Label.
	jump4 jmpTarget: currentBlock.
	s68 := 0.
	self MoveCq: s68 R: TempReg.
	currentBlock := self Label.
	jump7 jmpTarget: currentBlock.
	jump8 jmpTarget: currentBlock.
	self MoveR: SendNumArgsReg R: Extra1Reg.
	self CmpCq: 9 R: Extra1Reg.
	jumpTrue := self JumpAboveOrEqual: 0.
	self MoveCq: 0 R: Extra1Reg.
	jumpNext := self Jump: 0.
	jumpTrue jmpTarget: self Label.
	self MoveCq: 1 R: Extra1Reg.
	jumpNext jmpTarget: self Label.
	self CmpCq: 9 R: SendNumArgsReg.
	jump8 := self JumpBelow: 0.
	self MoveR: TempReg R: Extra2Reg.
	self MoveR: Extra1Reg R: TempReg.
	currentBlock := self Label.
	jump6 jmpTarget: currentBlock.
	self MoveR: Extra2Reg R: Extra1Reg.
	self MoveR: TempReg R: Extra2Reg.
	currentBlock := self Label.
	jump5 jmpTarget: currentBlock.
	self MoveR: Extra2Reg R: TempReg.
	jump5 := self Jump: 0.
	currentBlock := self Label.
	jump8 jmpTarget: currentBlock.
	self MoveR: TempReg R: Extra1Reg.
	currentBlock := self Label.
	jump2 jmpTarget: currentBlock.
	self MoveR: SendNumArgsReg R: TempReg.
	self CmpCq: 2 R: TempReg.
	jumpTrue := self JumpZero: 0.
	self MoveCq: 0 R: TempReg.
	jumpNext := self Jump: 0.
	jumpTrue jmpTarget: self Label.
	self MoveCq: 1 R: TempReg.
	jumpNext jmpTarget: self Label.
	currentBlock := self Label.
	jump5 jmpTarget: currentBlock.
	self CmpCq: 1 R: TempReg.
	jump5 := self JumpNonZero: 0.
	s101 := 0.
	self MoveCq: s101 R: TempReg.
	jump2 := self Jump: 0.
	currentBlock := self Label.
	jump5 jmpTarget: currentBlock.
	self CmpCq: 2 R: SendNumArgsReg.
	jump5 := self JumpAboveOrEqual: 0.
	self MoveR: Extra1Reg R: TempReg.
	jump8 := self Jump: 0.
	currentBlock := self Label.
	jump5 jmpTarget: currentBlock.
	self MoveMw: 0 r: SPReg R: Extra3Reg.
	self MoveM64: 0 r: Extra3Reg R: TempReg.
	self AndCq: 16r3FFFFF R: TempReg.
	self CmpCq: 31 R: TempReg.
	jump5 := self JumpAbove: 0.
	self CmpCq: 31 R: TempReg.
	jump6 := self JumpNonZero: 0.
	self MoveMw: 0 r: SPReg R: Extra3Reg.
	self MoveR: Extra3Reg R: TempReg.
	jump7 := self Jump: 0.
	currentBlock := self Label.
	jump6 jmpTarget: currentBlock.
	self CmpCq: 8 R: TempReg.
	jump6 := self JumpNonZero: 0.
	self genMoveConstant: objectMemory nilObject R: TempReg.
	jump4 := self Jump: 0.
	currentBlock := self Label.
	jump5 jmpTarget: currentBlock.
	jump6 jmpTarget: currentBlock.
	self MoveR: TempReg R: Extra2Reg.
	self ArithmeticShiftRightCq: 10 R: Extra2Reg.
	s119 := objectMemory hiddenRootsObject.
	self LogicalShiftLeftCq: 3 R: Extra2Reg.
	self MoveCq: s119 R: ClassReg.
	self AddR: Extra2Reg R: ClassReg.
	self MoveM64: 8 r: ClassReg R: ClassReg.
	self genMoveConstant: objectMemory nilObject R: Extra2Reg.
	self CmpR: Extra2Reg R: ClassReg.
	jump6 := self JumpNonZero: 0.
	self genMoveConstant: objectMemory nilObject R: Extra2Reg.
	jump5 := self Jump: 0.
	currentBlock := self Label.
	jump6 jmpTarget: currentBlock.
	self AndCq: 1023 R: TempReg.
	self LogicalShiftLeftCq: 3 R: TempReg.
	self AddR: TempReg R: ClassReg.
	self MoveM64: 8 r: ClassReg R: Extra2Reg.
	currentBlock := self Label.
	jump5 jmpTarget: currentBlock.
	self MoveR: Extra2Reg R: TempReg.
	currentBlock := self Label.
	jump7 jmpTarget: currentBlock.
	jump4 jmpTarget: currentBlock.
	self MoveM64: 24 r: TempReg R: Extra2Reg.
	self ArithmeticShiftRightCq: 3 R: Extra2Reg.
	self AndCq: 16rFFFF R: Extra2Reg.
	self MoveR: Extra2Reg R: TempReg.
	currentBlock := self Label.
	jump2 jmpTarget: currentBlock.
	jump8 jmpTarget: currentBlock.
	self CmpCq: 3 R: SendNumArgsReg.
	jump8 := self JumpNonZero: 0.
	self AndCq: 16r3FFFFF R: Extra0Reg.
	self CmpCq: 36 R: Extra0Reg.
	jumpTrue := self JumpZero: 0.
	self MoveCq: 0 R: Extra0Reg.
	jumpNext := self Jump: 0.
	jumpTrue jmpTarget: self Label.
	self MoveCq: 1 R: Extra0Reg.
	jumpNext jmpTarget: self Label.
	self MoveR: Extra0Reg R: Extra2Reg.
	jump2 := self Jump: 0.
	currentBlock := self Label.
	jump8 jmpTarget: currentBlock.
	s150 := 0.
	self MoveCq: s150 R: Extra2Reg.
	currentBlock := self Label.
	jump2 jmpTarget: currentBlock.
	self CmpCq: 1 R: Extra2Reg.
	jump2 := self JumpZero: 0.
	self SubR: TempReg R: Extra1Reg.
	self CmpCq: 24 R: SendNumArgsReg.
	jump8 := self JumpAboveOrEqual: 0.
	self MoveMw: 8 r: SPReg R: Extra3Reg.
	self CmpCq: 1 R: Extra3Reg.
	jump4 := self JumpBelow: 0.
	self MoveMw: 8 r: SPReg R: Extra3Reg.
	self MoveR: Extra3Reg R: Extra2Reg.
	self CmpR: Extra1Reg R: Extra2Reg.
	jumpTrue := self JumpBelowOrEqual: 0.
	self MoveCq: 0 R: Extra2Reg.
	jumpNext := self Jump: 0.
	jumpTrue jmpTarget: self Label.
	self MoveCq: 1 R: Extra2Reg.
	jumpNext jmpTarget: self Label.
	jump7 := self Jump: 0.
	currentBlock := self Label.
	jump4 jmpTarget: currentBlock.
	s162 := 0.
	self MoveCq: s162 R: Extra2Reg.
	currentBlock := self Label.
	jump7 jmpTarget: currentBlock.
	self CmpCq: 1 R: Extra2Reg.
	jump7 := self JumpNonZero: 0.
	self MoveMw: 8 r: SPReg R: Extra3Reg.
	self AddR: TempReg R: Extra3Reg.
	self MoveR: Extra3Reg Mw: 8 r: SPReg.
	self CmpCq: 5 R: SendNumArgsReg.
	jump4 := self JumpAbove: 0.
	self MoveMw: 8 r: SPReg R: Extra3Reg.
	self SubCq: 1 R: Extra3Reg.
	self MoveR: Extra3Reg Mw: 8 r: SPReg.
	self MoveMw: 8 r: SPReg R: Extra3Reg.
	self LogicalShiftLeftCq: 3 R: Extra3Reg.
	self MoveR: Extra3Reg Mw: 8 r: SPReg.
	self MoveMw: 0 r: SPReg R: Extra3Reg.
	self MoveMw: 8 r: SPReg R: Extra4Reg.
	self AddR: Extra4Reg R: Extra3Reg.
	self MoveR: Extra3Reg Mw: 0 r: SPReg.
	self MoveMw: 0 r: SPReg R: Extra3Reg.
	self MoveM64: 8 r: Extra3Reg R: Extra2Reg.
	self MoveR: Extra2Reg R: ReceiverResultReg.
	jump5 := self Jump: 0.
	currentBlock := self Label.
	jump4 jmpTarget: currentBlock.
	self CmpCq: 16 R: SendNumArgsReg.
	jump4 := self JumpBelow: 0.
	self MoveMw: 8 r: SPReg R: Extra3Reg.
	self MoveMw: 0 r: SPReg R: Extra4Reg.
	self AddR: Extra4Reg R: Extra3Reg.
	self MoveR: Extra3Reg Mw: 8 r: SPReg.
	self MoveMw: 8 r: SPReg R: Extra3Reg.
	self AddCq:  -1 R: Extra3Reg.
	self MoveR: Extra3Reg Mw: 8 r: SPReg.
	self MoveMw: 8 r: SPReg R: Extra3Reg.
	self MoveMb: 8 r: Extra3Reg R: Extra2Reg.
	self AndCq: 255 R: Extra2Reg.
	self LogicalShiftLeftCq: 3 R: Extra2Reg.
	self AddCq: 1 R: Extra2Reg.
	self MoveR: Extra2Reg R: ReceiverResultReg.
	jump6 := self Jump: 0.
	currentBlock := self Label.
	jump4 jmpTarget: currentBlock.
	self CmpCq: 12 R: SendNumArgsReg.
	jump4 := self JumpBelow: 0.
	self MoveMw: 8 r: SPReg R: Extra3Reg.
	self SubCq: 1 R: Extra3Reg.
	self MoveR: Extra3Reg Mw: 8 r: SPReg.
	self MoveMw: 8 r: SPReg R: Extra3Reg.
	self LogicalShiftLeftCq: 1 R: Extra3Reg.
	self MoveR: Extra3Reg Mw: 8 r: SPReg.
	self MoveMw: 0 r: SPReg R: Extra3Reg.
	self MoveMw: 8 r: SPReg R: Extra4Reg.
	self AddR: Extra4Reg R: Extra3Reg.
	self MoveR: Extra3Reg Mw: 0 r: SPReg.
	self MoveMw: 0 r: SPReg R: Extra3Reg.
	self MoveM16: 8 r: Extra3Reg R: Extra2Reg.
	self AndCq: 16rFFFF R: Extra2Reg.
	self LogicalShiftLeftCq: 3 R: Extra2Reg.
	self AddCq: 1 R: Extra2Reg.
	self MoveR: Extra2Reg R: ReceiverResultReg.
	jump9 := self Jump: 0.
	currentBlock := self Label.
	jump4 jmpTarget: currentBlock.
	self CmpCq: 9 R: SendNumArgsReg.
	jump4 := self JumpZero: 0.
	self MoveCq: 0 R: ReceiverResultReg.
	currentBlock := self Label.
	jump5 jmpTarget: currentBlock.
	jump6 jmpTarget: currentBlock.
	jump9 jmpTarget: currentBlock.
	self AddCq: 16 R: SPReg.
	self genPrimReturn.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	jump3 jmpTarget: currentBlock.
	jump2 jmpTarget: currentBlock.
	jump8 jmpTarget: currentBlock.
	jump7 jmpTarget: currentBlock.
	jump4 jmpTarget: currentBlock.
	self AddCq: 16 R: SPReg.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveBitShift [
	"AutoGenerated by Druid"

	| jump1 jump2 currentBlock |
	self MoveR: ReceiverResultReg R: TempReg.
	self MoveR: Arg0Reg R: ClassReg.
	self CmpCq: 0 R: ClassReg.
	jump1 := self JumpLessOrEqual: 0.
	self LogicalShiftLeftR: ClassReg R: TempReg.
	self MoveR: TempReg R: ReceiverResultReg.
	jump2 := self Jump: 0.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	self MoveR: ClassReg R: ClassReg.
	self NegateR: ClassReg.
	self ArithmeticShiftRightR: ClassReg R: TempReg.
	self MoveR: TempReg R: ReceiverResultReg.
	currentBlock := self Label.
	jump2 jmpTarget: currentBlock.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveBitXor [
	"AutoGenerated by Druid"

	| currentBlock |
	self MoveR: ReceiverResultReg R: TempReg.
	self MoveR: Arg0Reg R: ClassReg.
	self XorR: TempReg R: ClassReg.
	self MoveR: ClassReg R: ReceiverResultReg.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveBranchingWithAssigments [
	"AutoGenerated by Druid"

	| jump1 jump2 currentBlock |
	self MoveR: ReceiverResultReg R: TempReg.
	self CmpCq: 0 R: TempReg.
	jump1 := self JumpLessOrEqual: 0.
	self MoveCq: 17 R: ReceiverResultReg.
	jump2 := self Jump: 0.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	self MoveCq: 42 R: ReceiverResultReg.
	currentBlock := self Label.
	jump2 jmpTarget: currentBlock.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveByteAt [

	| currentBlock |
	self MoveCq: 0 R: TempReg.
	self MoveMb: 0 r: ReceiverResultReg R: TempReg.
	self MoveR: TempReg R: ReceiverResultReg.
	self RetN: 1 * objectMemory wordSize.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveCallingBlockReadingExternalTemp [
	"AutoGenerated by Druid"

	| currentBlock |
	self MoveCq: 17 R: ReceiverResultReg.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveCallingBlockReturningArgument [
	"AutoGenerated by Druid"

	| currentBlock |
	self MoveCq: 17 R: ReceiverResultReg.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveCallingBlockReturningConstant [
	"AutoGenerated by Druid"

	| currentBlock |
	self MoveCq: 17 R: ReceiverResultReg.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveCallingBlockWithNonLocalReturn [
	"AutoGenerated by Druid"

	| currentBlock |
	self MoveCq: 17 R: ReceiverResultReg.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveCallingBlockWritingExternalTemp [
	"AutoGenerated by Druid"

	| currentBlock |
	self MoveCq: 17 R: ReceiverResultReg.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveCallingEmptyBlock [
	"AutoGenerated by Druid"

	| currentBlock |
	self MoveCq: 18 R: ReceiverResultReg.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveCallingMethodReturningConstant [
	"AutoGenerated by Druid"

	| currentBlock |
	self MoveCq: 73 R: ReceiverResultReg.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveCallingMethodWithEarlyReturn [
	"AutoGenerated by Druid"

	| jump1 jump2 currentBlock |
	self MoveR: ReceiverResultReg R: TempReg.
	self CmpCq: 0 R: TempReg.
	jump1 := self JumpNonZero: 0.
	self MoveCq: 42 R: ReceiverResultReg.
	jump2 := self Jump: 0.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	self MoveCq: 57 R: ReceiverResultReg.
	currentBlock := self Label.
	jump2 jmpTarget: currentBlock.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveCascadedUint16AtPut [
	"AutoGenerated by Druid"

	| currentBlock |
	self MoveR: ReceiverResultReg R: TempReg.
	self MoveCq: 1 R: ClassReg.
	self MoveR: ClassReg M16: 0 r: TempReg.
	self MoveCq: 2 R: ClassReg.
	self MoveR: ClassReg M16: 2 r: TempReg.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveCaseOfOtherwiseValue [
	"AutoGenerated by Druid"

	| jump1 jump2 jump3 currentBlock |
	self MoveR: ReceiverResultReg R: TempReg.
	self CmpCq: 0 R: TempReg.
	jump1 := self JumpNonZero: 0.
	self MoveCq: 57 R: ReceiverResultReg.
	jump2 := self Jump: 0.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	self CmpCq: 1 R: TempReg.
	jump1 := self JumpNonZero: 0.
	self MoveCq: 42 R: ReceiverResultReg.
	jump3 := self Jump: 0.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	self MoveCq: 77 R: ReceiverResultReg.
	currentBlock := self Label.
	jump2 jmpTarget: currentBlock.
	jump3 jmpTarget: currentBlock.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveClass [
	"AutoGenerated by Druid"

	| s27 jump5 jump3 jump1 s2 currentBlock jump4 jump2 s3 |
	s2 := self methodNumArgs.
	s2 > 0 ifTrue: [ ^ CompletePrimitive ].
	self MoveR: ReceiverResultReg R: TempReg.
	self MoveR: TempReg R: ClassReg.
	self AndCq: 7 R: ClassReg.
	self CmpCq: 0 R: ClassReg.
	jump1 := self JumpZero: 0.
	self MoveAw: objectMemory hiddenRootsObject + 8 R: TempReg.
	self LogicalShiftLeftCq: 3 R: ClassReg.
	self AddR: ClassReg R: TempReg.
	self MoveM64: 8 r: TempReg R: TempReg.
	self MoveR: TempReg R: ReceiverResultReg.
	jump2 := self Jump: 0.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	self MoveM64: 0 r: TempReg R: ClassReg.
	self AndCq: 16r3FFFFF R: ClassReg.
	self CmpCq: 31 R: ClassReg.
	jump1 := self JumpAbove: 0.
	self CmpCq: 31 R: ClassReg.
	jump3 := self JumpNonZero: 0.
	self MoveR: TempReg R: ClassReg.
	jump4 := self Jump: 0.
	currentBlock := self Label.
	jump3 jmpTarget: currentBlock.
	self CmpCq: 8 R: ClassReg.
	jump3 := self JumpNonZero: 0.
	self genMoveConstant: objectMemory nilObject R: ClassReg.
	jump5 := self Jump: 0.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	jump3 jmpTarget: currentBlock.
	self MoveR: ClassReg R: TempReg.
	self ArithmeticShiftRightCq: 10 R: TempReg.
	s27 := objectMemory hiddenRootsObject.
	self LogicalShiftLeftCq: 3 R: TempReg.
	self MoveCq: s27 R: SendNumArgsReg.
	self AddR: TempReg R: SendNumArgsReg.
	self MoveM64: 8 r: SendNumArgsReg R: SendNumArgsReg.
	self genMoveConstant: objectMemory nilObject R: TempReg.
	self CmpR: TempReg R: SendNumArgsReg.
	jump3 := self JumpNonZero: 0.
	self genMoveConstant: objectMemory nilObject R: TempReg.
	jump1 := self Jump: 0.
	currentBlock := self Label.
	jump3 jmpTarget: currentBlock.
	self AndCq: 1023 R: ClassReg.
	self LogicalShiftLeftCq: 3 R: ClassReg.
	self AddR: ClassReg R: SendNumArgsReg.
	self MoveM64: 8 r: SendNumArgsReg R: TempReg.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	self MoveR: TempReg R: ClassReg.
	currentBlock := self Label.
	jump4 jmpTarget: currentBlock.
	jump5 jmpTarget: currentBlock.
	self MoveR: ClassReg R: ReceiverResultReg.
	currentBlock := self Label.
	jump2 jmpTarget: currentBlock.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveClassVariable [
	"AutoGenerated by Druid"

	| currentBlock |
	self MoveCq: 34 R: ReceiverResultReg.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveClassVariableWithBranch [
	"AutoGenerated by Druid"

	| jump1 jump2 currentBlock |
	self MoveR: ReceiverResultReg R: TempReg.
	self CmpCq: 0 R: TempReg.
	jump1 := self JumpNonZero: 0.
	self MoveCq: 35 R: ReceiverResultReg.
	jump2 := self Jump: 0.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	self MoveCq: 36 R: ReceiverResultReg.
	currentBlock := self Label.
	jump2 jmpTarget: currentBlock.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveConditionWithAnyMask [
	"AutoGenerated by Druid"

	| jump1 jump2 currentBlock |
	self MoveR: ReceiverResultReg R: TempReg.
	self TstCq: 1 R: TempReg.
	jump1 := self JumpZero: 0.
	self MoveCq: 1 R: ReceiverResultReg.
	jump2 := self Jump: 0.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	self MoveCq: 2 R: ReceiverResultReg.
	currentBlock := self Label.
	jump2 jmpTarget: currentBlock.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveConditionWithAnyMaskInverted [
	"AutoGenerated by Druid"

	| jump1 jump2 currentBlock |
	self MoveR: ReceiverResultReg R: TempReg.
	self TstCq: 1 R: TempReg.
	jump1 := self JumpZero: 0.
	self MoveCq: 1 R: ReceiverResultReg.
	jump2 := self Jump: 0.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	self MoveCq: 2 R: ReceiverResultReg.
	currentBlock := self Label.
	jump2 jmpTarget: currentBlock.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveConditionWithObjectReference [
	"AutoGenerated by Druid"

	| jump1 jump2 currentBlock s3 |
	self MoveR: ReceiverResultReg R: TempReg.
	s3 := objectMemory trueObject.
	self CmpCq: s3 R: TempReg.
	jump1 := self JumpAboveOrEqual: 0.
	self MoveCq: 1 R: ReceiverResultReg.
	jump2 := self Jump: 0.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	self MoveCq: 2 R: ReceiverResultReg.
	currentBlock := self Label.
	jump2 jmpTarget: currentBlock.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveDNA [
	"AutoGenerated by Druid"

	| jump1 jump2 jump3 currentBlock |
	self MoveR: ReceiverResultReg R: TempReg.
	self CmpCq: 10 R: TempReg.
	jump1 := self JumpLessOrEqual: 0.
	self MoveCq: 1 R: TempReg.
	self MoveCq: 5 R: ClassReg.
	jump2 := self Jump: 0.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	self MoveCq: 99 R: ClassReg.
	self CmpCq: 0 R: TempReg.
	jump1 := self JumpLessOrEqual: 0.
	self MoveCq: 5 R: SendNumArgsReg.
	self CmpCq: 7 R: TempReg.
	jump3 := self JumpLessOrEqual: 0.
	self MoveR: ClassReg R: TempReg.
	self MoveR: SendNumArgsReg R: ClassReg.
	currentBlock := self Label.
	jump2 jmpTarget: currentBlock.
	self AddCq: 20 R: TempReg.
	self MoveR: TempReg R: ReceiverResultReg.
	jump2 := self Jump: 0.
	currentBlock := self Label.
	jump3 jmpTarget: currentBlock.
	jump3 := self Jump: 0.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	self MoveCq: 99 R: SendNumArgsReg.
	self MoveCq: 17 R: TempReg.
	self MoveR: SendNumArgsReg R: ClassReg.
	self MoveR: TempReg R: SendNumArgsReg.
	currentBlock := self Label.
	jump3 jmpTarget: currentBlock.
	self AddR: SendNumArgsReg R: ClassReg.
	self AddCq: 42 R: ClassReg.
	self MoveR: ClassReg R: ReceiverResultReg.
	currentBlock := self Label.
	jump2 jmpTarget: currentBlock.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveDeadBranchWithError [
	"AutoGenerated by Druid"

	| currentBlock |
	self MoveCq: 17 R: ReceiverResultReg.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveDecrement [

	| currentBlock |
	self MoveR: ReceiverResultReg R: TempReg.
	self SubCq: 1 R: TempReg.
	self MoveR: TempReg R: ReceiverResultReg.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveDecrementConstantArgument [
	"AutoGenerated by Druid"

	| currentBlock |
	self MoveR: ReceiverResultReg R: TempReg.
	self SubCq: 1 R: TempReg.
	self MoveR: TempReg R: ReceiverResultReg.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveDecrementConstantReceiver [
	"AutoGenerated by Druid"

	| currentBlock |
	self MoveR: ReceiverResultReg R: TempReg.
	self MoveCq: 42 R: ClassReg.
	self SubR: TempReg R: ClassReg.
	self MoveR: ClassReg R: ReceiverResultReg.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveDivide [
	"AutoGenerated by Druid"

	| currentBlock |
	self MoveR: ReceiverResultReg R: TempReg.
	self MoveR: Arg0Reg R: ClassReg.
	self
		DivR: ClassReg
		R: TempReg
		Quo: ClassReg
		Rem: TempReg.
	self MoveR: ClassReg R: ReceiverResultReg.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveDivideByConstant [
	"AutoGenerated by Druid"

	| currentBlock s3 |
	self MoveR: ReceiverResultReg R: TempReg.
	s3 := 2.
	self MoveCq: s3 R: ClassReg.
	self
		DivR: ClassReg
		R: TempReg
		Quo: ClassReg
		Rem: TempReg.
	self MoveR: ClassReg R: ReceiverResultReg.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveDoubleDeferredInline [
	"AutoGenerated by Druid"

	| jump1 currentBlock |
	self MoveR: ReceiverResultReg R: TempReg.
	self MoveCq: 0 R: ClassReg.
	self MoveR: ClassReg Aw: coInterpreter primitiveFailureCodeAddress.
	self MoveAw: coInterpreter primitiveFailureCodeAddress R: ClassReg.
	self MoveR: Arg0Reg R: SendNumArgsReg.
	self MoveCq: 2 R: SendNumArgsReg.
	self MulR: TempReg R: SendNumArgsReg.
	self MoveR: ClassReg Aw: coInterpreter primitiveFailureCodeAddress.
	self MoveAw: coInterpreter primitiveFailureCodeAddress R: ClassReg.
	self MoveR: SendNumArgsReg R: ReceiverResultReg.
	self CmpCq: 0 R: ClassReg.
	jump1 := self JumpNonZero: 0.
	self genPrimReturn.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveEqualsThan [
	"AutoGenerated by Druid"

	| jump1 jump2 currentBlock |
	self MoveR: ReceiverResultReg R: TempReg.
	self CmpCq: 10 R: TempReg.
	jump1 := self JumpNonZero: 0.
	self MoveCq: 5 R: ReceiverResultReg.
	jump2 := self Jump: 0.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	self MoveCq: 11 R: ReceiverResultReg.
	currentBlock := self Label.
	jump2 jmpTarget: currentBlock.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveEqualsThanFloats [
	"AutoGenerated by Druid"

	| jumpNext currentBlock jumpTrue |
	self MoveR: ReceiverResultReg R: TempReg.
	self MoveR: Arg0Reg R: ClassReg.
	self ConvertR: ClassReg Rd: DPFPReg0.
	self ConvertR: TempReg Rd: DPFPReg1.
	self CmpRd: DPFPReg1 Rd: DPFPReg0.
	jumpTrue := self JumpFPEqual: 0.
	self MoveCq: 0 R: TempReg.
	jumpNext := self Jump: 0.
	jumpTrue jmpTarget: self Label.
	self MoveCq: 1 R: TempReg.
	jumpNext jmpTarget: self Label.
	self MoveR: TempReg R: ReceiverResultReg.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveEqualsThanInverted [
	"AutoGenerated by Druid"

	| jump1 jump2 currentBlock |
	self MoveR: ReceiverResultReg R: TempReg.
	self CmpCq: 10 R: TempReg.
	jump1 := self JumpNonZero: 0.
	self MoveCq: 5 R: ReceiverResultReg.
	jump2 := self Jump: 0.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	self MoveCq: 11 R: ReceiverResultReg.
	currentBlock := self Label.
	jump2 jmpTarget: currentBlock.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveEqualsThanReferenceValue [

	| jumpNext currentBlock jumpTrue |
	self MoveR: ReceiverResultReg R: TempReg.
	self CmpCw: objectMemory trueObject R: TempReg.
	jumpTrue := self JumpZero: 0.
	self MoveCq: 0 R: TempReg.
	jumpNext := self Jump: 0.
	jumpTrue jmpTarget: self Label.
	self MoveCq: 1 R: TempReg.
	jumpNext jmpTarget: self Label.
	self MoveR: TempReg R: ReceiverResultReg.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveEqualsThanValue [
	"AutoGenerated by Druid"

	| jumpNext currentBlock jumpTrue |
	self MoveR: ReceiverResultReg R: TempReg.
	self CmpCq: 0 R: TempReg.
	jumpTrue := self JumpZero: 0.
	self MoveCq: 0 R: TempReg.
	jumpNext := self Jump: 0.
	jumpTrue jmpTarget: self Label.
	self MoveCq: 1 R: TempReg.
	jumpNext jmpTarget: self Label.
	self MoveR: TempReg R: ReceiverResultReg.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveFalseAsInteger [
	"AutoGenerated by Druid"

	| currentBlock |
	self MoveCq: 0 R: ReceiverResultReg.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveFalseAssignmentAsInteger [
	"AutoGenerated by Druid"

	| currentBlock |
	self MoveCq: 0 R: ReceiverResultReg.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveFalseNot [
	"AutoGenerated by Druid"

	| currentBlock |
	self MoveCq: 1 R: ReceiverResultReg.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveFloat64At [
	"AutoGenerated by Druid"

	| currentBlock |
	self MoveR: ReceiverResultReg R: TempReg.
	self MoveM64: 0 r: TempReg Rd: DPFPReg0.
	self MoveRd: DPFPReg0 R: TempReg.
	self MoveR: TempReg R: ReceiverResultReg.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveFloat64AtPut [
	"AutoGenerated by Druid"

	| currentBlock |
	self MoveR: ReceiverResultReg R: TempReg.
	self MoveR: Arg0Reg R: ClassReg.
	self ConvertR: ClassReg Rd: DPFPReg0.
	self MoveRd: DPFPReg0 M64: 0 r: TempReg.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveFloatAdd [
	"AutoGenerated by Druid"

	| currentBlock |
	self MoveR: ReceiverResultReg R: TempReg.
	self MoveR: Arg0Reg R: ClassReg.
	self ConvertR: ClassReg Rd: DPFPReg0.
	self ConvertR: TempReg Rd: DPFPReg1.
	self AddRd: DPFPReg1 Rd: DPFPReg0.
	self MoveRd: DPFPReg0 R: TempReg.
	self MoveR: TempReg R: ReceiverResultReg.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveFloatDivide [
	"AutoGenerated by Druid"

	| currentBlock |
	self MoveR: ReceiverResultReg R: TempReg.
	self MoveR: Arg0Reg R: ClassReg.
	self ConvertR: ClassReg Rd: DPFPReg0.
	self ConvertR: TempReg Rd: DPFPReg1.
	self DivR: DPFPReg1 R: DPFPReg0.
	self MoveR: DPFPReg0 R: TempReg.
	self MoveR: TempReg R: ReceiverResultReg.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveFloatMultiply [
	"AutoGenerated by Druid"

	| currentBlock |
	self MoveR: ReceiverResultReg R: TempReg.
	self MoveR: Arg0Reg R: ClassReg.
	self ConvertR: ClassReg Rd: DPFPReg0.
	self ConvertR: TempReg Rd: DPFPReg1.
	self MulRd: DPFPReg0 Rd: DPFPReg1.
	self MoveRd: DPFPReg1 R: TempReg.
	self MoveR: TempReg R: ReceiverResultReg.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveFloatSubtract [
	"AutoGenerated by Druid"

	| currentBlock |
	self MoveR: ReceiverResultReg R: TempReg.
	self MoveR: Arg0Reg R: ClassReg.
	self ConvertR: ClassReg Rd: DPFPReg0.
	self ConvertR: TempReg Rd: DPFPReg1.
	self SubRd: DPFPReg1 Rd: DPFPReg0.
	self MoveRd: DPFPReg0 R: TempReg.
	self MoveR: TempReg R: ReceiverResultReg.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveFullClosureValue [
	"AutoGenerated by Druid"

	| jump3 jump1 currentBlock jump4 jump2 |
	self MoveR: ReceiverResultReg R: TempReg.
	self MoveM64: 24 r: TempReg R: ClassReg.
	self ArithmeticShiftRightCq: 3 R: ClassReg.
	self CmpCq: 0 R: ClassReg.
	jump1 := self JumpNonZero: 0.
	self MoveM64: 16 r: TempReg R: ClassReg.
	self MoveR: ClassReg R: TempReg.
	self AndCq: 7 R: TempReg.
	self CmpCq: 0 R: TempReg.
	jump2 := self JumpNonZero: 0.
	self MoveM64: 0 r: ClassReg R: TempReg.
	self ArithmeticShiftRightCq: 24 R: TempReg.
	self AndCq: 31 R: TempReg.
	self CmpCq: 24 R: TempReg.
	jump3 := self JumpBelow: 0.
	self MoveM64: 8 r: ClassReg R: TempReg.
	self AndCq: 1 R: TempReg.
	self CmpCq: 0 R: TempReg.
	jump4 := self JumpNonZero: 0.
	self MoveM64: 8 r: ClassReg R: TempReg.
	self AddCq: self fullBlockEntryOffset R: TempReg.
	self JumpR: TempReg.
	self genPrimReturn.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	jump2 jmpTarget: currentBlock.
	jump3 jmpTarget: currentBlock.
	jump4 jmpTarget: currentBlock.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveGreaterOrEqualThanArgument [
	"AutoGenerated by Druid"

	| jumpNext currentBlock jumpTrue |
	self MoveR: Arg0Reg R: TempReg.
	self CmpCq: 0 R: TempReg.
	jumpTrue := self JumpGreaterOrEqual: 0.
	self MoveCq: 0 R: TempReg.
	jumpNext := self Jump: 0.
	jumpTrue jmpTarget: self Label.
	self MoveCq: 1 R: TempReg.
	jumpNext jmpTarget: self Label.
	self MoveR: TempReg R: ReceiverResultReg.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveGreaterOrEqualThanValue [
	"AutoGenerated by Druid"

	| jumpNext currentBlock jumpTrue |
	self MoveR: ReceiverResultReg R: TempReg.
	self CmpCq: 0 R: TempReg.
	jumpTrue := self JumpGreaterOrEqual: 0.
	self MoveCq: 0 R: TempReg.
	jumpNext := self Jump: 0.
	jumpTrue jmpTarget: self Label.
	self MoveCq: 1 R: TempReg.
	jumpNext jmpTarget: self Label.
	self MoveR: TempReg R: ReceiverResultReg.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveGreaterOrEqualsThan [
	"AutoGenerated by Druid"

	| jump1 jump2 currentBlock |
	self MoveR: ReceiverResultReg R: TempReg.
	self CmpCq: 10 R: TempReg.
	jump1 := self JumpLess: 0.
	self MoveCq: 5 R: ReceiverResultReg.
	jump2 := self Jump: 0.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	self MoveCq: 11 R: ReceiverResultReg.
	currentBlock := self Label.
	jump2 jmpTarget: currentBlock.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveGreaterOrEqualsThanFloats [
	"AutoGenerated by Druid"

	| jumpNext currentBlock jumpTrue |
	self MoveR: ReceiverResultReg R: TempReg.
	self MoveR: Arg0Reg R: ClassReg.
	self ConvertR: ClassReg Rd: DPFPReg0.
	self ConvertR: TempReg Rd: DPFPReg1.
	self CmpRd: DPFPReg1 Rd: DPFPReg0.
	jumpTrue := self JumpFPGreaterOrEqual: 0.
	self MoveCq: 0 R: TempReg.
	jumpNext := self Jump: 0.
	jumpTrue jmpTarget: self Label.
	self MoveCq: 1 R: TempReg.
	jumpNext jmpTarget: self Label.
	self MoveR: TempReg R: ReceiverResultReg.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveGreaterOrEqualsThanInverted [
	"AutoGenerated by Druid"

	| jump1 jump2 currentBlock |
	self MoveR: ReceiverResultReg R: TempReg.
	self MoveCq: 10 R: ClassReg.
	self CmpR: TempReg R: ClassReg.
	jump1 := self JumpLess: 0.
	self MoveCq: 5 R: ReceiverResultReg.
	jump2 := self Jump: 0.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	self MoveCq: 11 R: ReceiverResultReg.
	currentBlock := self Label.
	jump2 jmpTarget: currentBlock.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveGreaterThan [
	"AutoGenerated by Druid"

	| jump1 jump2 currentBlock |
	self MoveR: ReceiverResultReg R: TempReg.
	self CmpCq: 10 R: TempReg.
	jump1 := self JumpLessOrEqual: 0.
	self MoveCq: 5 R: ReceiverResultReg.
	jump2 := self Jump: 0.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	self MoveCq: 11 R: ReceiverResultReg.
	currentBlock := self Label.
	jump2 jmpTarget: currentBlock.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveGreaterThanArgument [
	"AutoGenerated by Druid"

	| jumpNext currentBlock jumpTrue |
	self MoveR: Arg0Reg R: TempReg.
	self CmpCq: 0 R: TempReg.
	jumpTrue := self JumpGreater: 0.
	self MoveCq: 0 R: TempReg.
	jumpNext := self Jump: 0.
	jumpTrue jmpTarget: self Label.
	self MoveCq: 1 R: TempReg.
	jumpNext jmpTarget: self Label.
	self MoveR: TempReg R: ReceiverResultReg.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveGreaterThanFloats [
	"AutoGenerated by Druid"

	| jumpNext currentBlock jumpTrue |
	self MoveR: ReceiverResultReg R: TempReg.
	self MoveR: Arg0Reg R: ClassReg.
	self ConvertR: ClassReg Rd: DPFPReg0.
	self ConvertR: TempReg Rd: DPFPReg1.
	self CmpRd: DPFPReg1 Rd: DPFPReg0.
	jumpTrue := self JumpFPGreater: 0.
	self MoveCq: 0 R: TempReg.
	jumpNext := self Jump: 0.
	jumpTrue jmpTarget: self Label.
	self MoveCq: 1 R: TempReg.
	jumpNext jmpTarget: self Label.
	self MoveR: TempReg R: ReceiverResultReg.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveGreaterThanInverted [
	"AutoGenerated by Druid"

	| jump1 jump2 currentBlock |
	self MoveR: ReceiverResultReg R: TempReg.
	self MoveCq: 10 R: ClassReg.
	self CmpR: TempReg R: ClassReg.
	jump1 := self JumpLessOrEqual: 0.
	self MoveCq: 5 R: ReceiverResultReg.
	jump2 := self Jump: 0.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	self MoveCq: 11 R: ReceiverResultReg.
	currentBlock := self Label.
	jump2 jmpTarget: currentBlock.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveGreaterThanReferenceValue [
	"AutoGenerated by Druid"

	| jumpTrue jumpNext currentBlock s3 |
	self MoveR: ReceiverResultReg R: TempReg.
	s3 := objectMemory trueObject.
	self MoveCq: s3 R: ClassReg.
	self CmpR: ClassReg R: TempReg.
	jumpTrue := self JumpAbove: 0.
	self MoveCq: 0 R: TempReg.
	jumpNext := self Jump: 0.
	jumpTrue jmpTarget: self Label.
	self MoveCq: 1 R: TempReg.
	jumpNext jmpTarget: self Label.
	self MoveR: TempReg R: ReceiverResultReg.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveIfFalseIfTrueReturningValue [
	"AutoGenerated by Druid"

	| jump1 jump2 currentBlock |
	self MoveR: ReceiverResultReg R: TempReg.
	self CmpCq: 0 R: TempReg.
	jump1 := self JumpNonZero: 0.
	self MoveCq: 42 R: ReceiverResultReg.
	jump2 := self Jump: 0.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	self MoveCq: 57 R: ReceiverResultReg.
	currentBlock := self Label.
	jump2 jmpTarget: currentBlock.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveIfTrueIfFalseAssigningValue [
	"AutoGenerated by Druid"

	| jump1 jump2 currentBlock |
	self MoveR: ReceiverResultReg R: TempReg.
	self CmpCq: 0 R: TempReg.
	jump1 := self JumpNonZero: 0.
	self MoveCq: 42 R: ReceiverResultReg.
	jump2 := self Jump: 0.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	self MoveCq: 57 R: ReceiverResultReg.
	currentBlock := self Label.
	jump2 jmpTarget: currentBlock.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveIfTrueIfFalseReturningValue [
	"AutoGenerated by Druid"

	| jump1 jump2 currentBlock |
	self MoveR: ReceiverResultReg R: TempReg.
	self CmpCq: 0 R: TempReg.
	jump1 := self JumpNonZero: 0.
	self MoveCq: 42 R: ReceiverResultReg.
	jump2 := self Jump: 0.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	self MoveCq: 57 R: ReceiverResultReg.
	currentBlock := self Label.
	jump2 jmpTarget: currentBlock.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveIfTrueStatement [
	"AutoGenerated by Druid"

	| jump1 jump2 currentBlock |
	self MoveR: ReceiverResultReg R: TempReg.
	self CmpCq: 0 R: TempReg.
	jump1 := self JumpNonZero: 0.
	self MoveCq: 42 R: ReceiverResultReg.
	jump2 := self Jump: 0.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	self MoveCq: 10 R: ReceiverResultReg.
	currentBlock := self Label.
	jump2 jmpTarget: currentBlock.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveImplicitArgumentBitShiftLeft [
	"AutoGenerated by Druid"

	| jump1 jump2 currentBlock |
	self MoveR: ReceiverResultReg R: TempReg.
	self CmpCq: 0 R: TempReg.
	jump1 := self JumpLessOrEqual: 0.
	self MoveCq: 1 R: ClassReg.
	self LogicalShiftLeftR: TempReg R: ClassReg.
	self MoveR: ClassReg R: ReceiverResultReg.
	jump2 := self Jump: 0.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	self MoveR: TempReg R: ClassReg.
	self NegateR: ClassReg.
	self MoveCq: 1 R: TempReg.
	self ArithmeticShiftRightR: ClassReg R: TempReg.
	self MoveR: TempReg R: ReceiverResultReg.
	currentBlock := self Label.
	jump2 jmpTarget: currentBlock.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveImplicitBitShiftLeft [
	"AutoGenerated by Druid"

	| currentBlock |
	self MoveR: ReceiverResultReg R: TempReg.
	self LogicalShiftLeftCq: 1 R: TempReg.
	self MoveR: TempReg R: ReceiverResultReg.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveImplicitBitShiftRight [
	"AutoGenerated by Druid"

	| currentBlock |
	self MoveR: ReceiverResultReg R: TempReg.
	self ArithmeticShiftRightCq: 1 R: TempReg.
	self MoveR: TempReg R: ReceiverResultReg.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveIncrement [

	| currentBlock |
	self MoveR: ReceiverResultReg R: TempReg.
	self AddCq: 1 R: TempReg.
	self MoveR: TempReg R: ReceiverResultReg.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveIncrementConstantArgument [
	"AutoGenerated by Druid"

	| currentBlock |
	self MoveR: ReceiverResultReg R: TempReg.
	self AddCq: 1 R: TempReg.
	self MoveR: TempReg R: ReceiverResultReg.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveIncrementConstantReceiver [
	"AutoGenerated by Druid"

	| currentBlock |
	self MoveR: ReceiverResultReg R: TempReg.
	self AddCq: 1 R: TempReg.
	self MoveR: TempReg R: ReceiverResultReg.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveIntegerAsFloat [
	"AutoGenerated by Druid"

	| currentBlock |
	self MoveR: ReceiverResultReg R: TempReg.
	self ConvertR: TempReg Rd: DPFPReg0.
	self MoveRd: DPFPReg0 R: TempReg.
	self MoveR: TempReg R: ReceiverResultReg.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveIntegerDivide [
	"AutoGenerated by Druid"

	| currentBlock |
	self MoveR: ReceiverResultReg R: TempReg.
	self MoveR: Arg0Reg R: ClassReg.
	self
		DivR: ClassReg
		R: TempReg
		Quo: TempReg
		Rem: ClassReg.
	self MoveR: TempReg R: ReceiverResultReg.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveIntegerDivideByConstant [
	"AutoGenerated by Druid"

	| currentBlock |
	self MoveR: ReceiverResultReg R: TempReg.
	self MoveCq: 2 R: ClassReg.
	self
		DivR: ClassReg
		R: TempReg
		Quo: ClassReg
		Rem: TempReg.
	self MoveR: ClassReg R: ReceiverResultReg.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveIntegerRawBitsAsFloat [
	"AutoGenerated by Druid"

	| currentBlock |
	self MoveR: ReceiverResultReg R: TempReg.
	self MoveR: TempReg Rd: DPFPReg0.
	self ConvertRd: DPFPReg0 R: TempReg.
	self MoveR: TempReg R: ReceiverResultReg.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveIsIntegerObject [
	"AutoGenerated by Druid"

	| jump1 jump2 currentBlock |
	self MoveR: ReceiverResultReg R: TempReg.
	self TstCq: 1 R: TempReg.
	jump1 := self JumpZero: 0.
	self genMoveConstant: objectMemory trueObject R: TempReg.
	self MoveR: TempReg R: ReceiverResultReg.
	jump2 := self Jump: 0.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	self genMoveConstant: objectMemory falseObject R: TempReg.
	self MoveR: TempReg R: ReceiverResultReg.
	currentBlock := self Label.
	jump2 jmpTarget: currentBlock.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveJITCompileTimeExpression [
	"AutoGenerated by Druid"

	| currentBlock |
	self MoveCq: objectMemory trueObject R: TempReg.
	self AddCq: 5 R: TempReg.
	self MoveR: TempReg R: ReceiverResultReg.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveLessOrEqualThanArgument [
	"AutoGenerated by Druid"

	| jumpNext currentBlock jumpTrue |
	self MoveR: Arg0Reg R: TempReg.
	self CmpCq: 0 R: TempReg.
	jumpTrue := self JumpLessOrEqual: 0.
	self MoveCq: 0 R: TempReg.
	jumpNext := self Jump: 0.
	jumpTrue jmpTarget: self Label.
	self MoveCq: 1 R: TempReg.
	jumpNext jmpTarget: self Label.
	self MoveR: TempReg R: ReceiverResultReg.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveLessOrEqualThanValue [
	"AutoGenerated by Druid"

	| jumpNext currentBlock jumpTrue |
	self MoveR: ReceiverResultReg R: TempReg.
	self CmpCq: 0 R: TempReg.
	jumpTrue := self JumpLessOrEqual: 0.
	self MoveCq: 0 R: TempReg.
	jumpNext := self Jump: 0.
	jumpTrue jmpTarget: self Label.
	self MoveCq: 1 R: TempReg.
	jumpNext jmpTarget: self Label.
	self MoveR: TempReg R: ReceiverResultReg.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveLessOrEqualsThan [
	"AutoGenerated by Druid"

	| jump1 jump2 currentBlock |
	self MoveR: ReceiverResultReg R: TempReg.
	self CmpCq: 10 R: TempReg.
	jump1 := self JumpGreater: 0.
	self MoveCq: 5 R: ReceiverResultReg.
	jump2 := self Jump: 0.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	self MoveCq: 11 R: ReceiverResultReg.
	currentBlock := self Label.
	jump2 jmpTarget: currentBlock.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveLessOrEqualsThanFloats [
	"AutoGenerated by Druid"

	| jumpNext currentBlock jumpTrue |
	self MoveR: ReceiverResultReg R: TempReg.
	self MoveR: Arg0Reg R: ClassReg.
	self ConvertR: ClassReg Rd: DPFPReg0.
	self ConvertR: TempReg Rd: DPFPReg1.
	self CmpRd: DPFPReg1 Rd: DPFPReg0.
	jumpTrue := self JumpFPLessOrEqual: 0.
	self MoveCq: 0 R: TempReg.
	jumpNext := self Jump: 0.
	jumpTrue jmpTarget: self Label.
	self MoveCq: 1 R: TempReg.
	jumpNext jmpTarget: self Label.
	self MoveR: TempReg R: ReceiverResultReg.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveLessOrEqualsThanInverted [
	"AutoGenerated by Druid"

	| jump1 jump2 currentBlock |
	self MoveR: ReceiverResultReg R: TempReg.
	self MoveCq: 10 R: ClassReg.
	self CmpR: TempReg R: ClassReg.
	jump1 := self JumpGreater: 0.
	self MoveCq: 5 R: ReceiverResultReg.
	jump2 := self Jump: 0.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	self MoveCq: 11 R: ReceiverResultReg.
	currentBlock := self Label.
	jump2 jmpTarget: currentBlock.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveLessThan [
	"AutoGenerated by Druid"

	| jump1 jump2 currentBlock |
	self MoveR: ReceiverResultReg R: TempReg.
	self CmpCq: 10 R: TempReg.
	jump1 := self JumpGreaterOrEqual: 0.
	self MoveCq: 5 R: ReceiverResultReg.
	jump2 := self Jump: 0.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	self MoveCq: 11 R: ReceiverResultReg.
	currentBlock := self Label.
	jump2 jmpTarget: currentBlock.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveLessThanArgument [
	"AutoGenerated by Druid"

	| jumpNext currentBlock jumpTrue |
	self MoveR: Arg0Reg R: TempReg.
	self CmpCq: 0 R: TempReg.
	jumpTrue := self JumpLess: 0.
	self MoveCq: 0 R: TempReg.
	jumpNext := self Jump: 0.
	jumpTrue jmpTarget: self Label.
	self MoveCq: 1 R: TempReg.
	jumpNext jmpTarget: self Label.
	self MoveR: TempReg R: ReceiverResultReg.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveLessThanFloats [
	"AutoGenerated by Druid"

	| jumpNext currentBlock jumpTrue |
	self MoveR: ReceiverResultReg R: TempReg.
	self MoveR: Arg0Reg R: ClassReg.
	self ConvertR: ClassReg Rd: DPFPReg0.
	self ConvertR: TempReg Rd: DPFPReg1.
	self CmpRd: DPFPReg1 Rd: DPFPReg0.
	jumpTrue := self JumpFPLess: 0.
	self MoveCq: 0 R: TempReg.
	jumpNext := self Jump: 0.
	jumpTrue jmpTarget: self Label.
	self MoveCq: 1 R: TempReg.
	jumpNext jmpTarget: self Label.
	self MoveR: TempReg R: ReceiverResultReg.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveLessThanInverted [
	"AutoGenerated by Druid"

	| jump1 jump2 currentBlock |
	self MoveR: ReceiverResultReg R: TempReg.
	self MoveCq: 10 R: ClassReg.
	self CmpR: TempReg R: ClassReg.
	jump1 := self JumpGreaterOrEqual: 0.
	self MoveCq: 5 R: ReceiverResultReg.
	jump2 := self Jump: 0.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	self MoveCq: 11 R: ReceiverResultReg.
	currentBlock := self Label.
	jump2 jmpTarget: currentBlock.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveLessThanThanInverted [

	| currentBlock jump0 jump1 |
	self MoveCq: true asBit R: TempReg.
	self MoveCq: 10 R: ClassReg.
	self CmpCq: 10 R: ReceiverResultReg.
	jump0 := self JumpLess: 0.
	self MoveCq: 5 R: Extra0Reg.
	self MoveCq: 5 R: Extra1Reg.
	self MoveR: Extra1Reg R: ClassReg.
	self MoveR: ReceiverResultReg R: SendNumArgsReg.
	jump1 := self Jump: 0.
	currentBlock := self Label.
	jump0 jmpTarget: currentBlock.
	self MoveCq: 11 R: Extra2Reg.
	self MoveCq: 11 R: TempReg.
	self MoveR: TempReg R: ClassReg.
	self MoveR: ReceiverResultReg R: SendNumArgsReg.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	self MoveCq: 1 R: Extra0Reg.
	self MoveR: ClassReg R: ReceiverResultReg.
	self RetN: 1 * objectMemory wordSize.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveLessThanValue [
	"AutoGenerated by Druid"

	| jumpNext currentBlock jumpTrue |
	self MoveR: ReceiverResultReg R: TempReg.
	self CmpCq: 0 R: TempReg.
	jumpTrue := self JumpLess: 0.
	self MoveCq: 0 R: TempReg.
	jumpNext := self Jump: 0.
	jumpTrue jmpTarget: self Label.
	self MoveCq: 1 R: TempReg.
	jumpNext jmpTarget: self Label.
	self MoveR: TempReg R: ReceiverResultReg.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveLoopIncrementing [
	"AutoGenerated by Druid"

	| jump1 jump2 b21 currentBlock |
	self MoveCq: 10 R: TempReg.
	b21 := self Label.
	self MoveR: TempReg R: ClassReg.
	self AddCq: 1 R: ClassReg.
	self CmpCq: 15 R: ClassReg.
	jump1 := self JumpGreaterOrEqual: 0.
	self MoveR: ClassReg R: TempReg.
	jump2 := self Jump: b21.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	self MoveR: ClassReg R: ReceiverResultReg.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveLoopIncrementingGlobalState [
	"AutoGenerated by Druid"

	| jump1 jump2 b21 currentBlock |
	self MoveCq: 10 R: TempReg.
	b21 := self Label.
	self MoveR: TempReg R: ClassReg.
	self AddCq: 1 R: ClassReg.
	self CmpCq: 15 R: ClassReg.
	jump1 := self JumpGreaterOrEqual: 0.
	self MoveR: ClassReg R: TempReg.
	jump2 := self Jump: b21.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	self MoveR: ClassReg R: ReceiverResultReg.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveLoopWithInvariant [

	| jump1 currentBlock b14 |
	self MoveCq: 0 R: TempReg.
	self MoveR: ReceiverResultReg R: ClassReg.
	b14 := self Label.
	self MoveCq: 1 R: SendNumArgsReg.
	self MoveR: ClassReg R: Extra0Reg.
	self MulR: SendNumArgsReg R: Extra0Reg.
	self MoveR: TempReg R: SendNumArgsReg.
	self AddR: Extra0Reg R: SendNumArgsReg.
	self CmpCq: 15 R: SendNumArgsReg.
	jump1 := self JumpLess: 0.
	self MoveR: SendNumArgsReg R: ReceiverResultReg.
	self genPrimReturn.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	self MoveR: SendNumArgsReg R: TempReg.
	jump1 := self Jump: b14.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveMod [
	"AutoGenerated by Druid"

	| currentBlock |
	self MoveR: ReceiverResultReg R: TempReg.
	self MoveR: Arg0Reg R: ClassReg.
	self
		DivR: ClassReg
		R: TempReg
		Quo: ClassReg
		Rem: TempReg.
	self MoveR: TempReg R: ReceiverResultReg.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveModByConstant [
	"AutoGenerated by Druid"

	| currentBlock |
	self MoveR: ReceiverResultReg R: TempReg.
	self MoveCq: 2 R: ClassReg.
	self
		DivR: ClassReg
		R: TempReg
		Quo: ClassReg
		Rem: TempReg.
	self MoveR: TempReg R: ReceiverResultReg.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveMultiply [

	| currentBlock |
	self MoveR: ReceiverResultReg R: TempReg.
	self MoveR: TempReg R: ReceiverResultReg.
	self MulR: ReceiverResultReg R: TempReg.
	self MoveR: TempReg R: ReceiverResultReg.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveMultiplyConstantArgument [
	"AutoGenerated by Druid"

	| currentBlock |
	self MoveR: ReceiverResultReg R: TempReg.
	self MoveCq: 2 R: ClassReg.
	self MulR: TempReg R: ClassReg.
	self MoveR: ClassReg R: ReceiverResultReg.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveMultiplyConstantReceiver [
	"AutoGenerated by Druid"

	| currentBlock |
	self MoveR: ReceiverResultReg R: TempReg.
	self MoveCq: 2 R: ClassReg.
	self MulR: ClassReg R: TempReg.
	self MoveR: TempReg R: ReceiverResultReg.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveMultiplyInverted [

	| currentBlock |
	self MoveCq: 2 R: TempReg.
	self MoveR: TempReg Cq: 2.
	self MulCq: 2 R: TempReg.
	self MoveR: TempReg R: ReceiverResultReg.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveMultiplyWithOverflow [
	"AutoGenerated by Druid"

	| jump1 jump2 currentBlock |
	self MoveR: ReceiverResultReg R: TempReg.
	self MoveR: Arg0Reg R: ClassReg.
	self ArithmeticShiftRightCq: 3 R: TempReg.
	self SubCq: 1 R: ClassReg.
	self MulR: ClassReg R: TempReg.
	jump1 := self JumpMultiplyNoOverflow: 0.
	self MoveCq: 99 R: ReceiverResultReg.
	jump2 := self Jump: 0.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	self AddCq: 1 R: TempReg.
	self MoveR: TempReg R: ReceiverResultReg.
	currentBlock := self Label.
	jump2 jmpTarget: currentBlock.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveNegated [
	"AutoGenerated by Druid"

	| currentBlock |
	self MoveR: ReceiverResultReg R: TempReg.
	self MoveR: TempReg R: TempReg.
	self NegateR: TempReg.
	self MoveR: TempReg R: ReceiverResultReg.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveNew [
	"AutoGenerated by Druid"

	| jump1 jumpNext s39 s48 jump3 s71 jump6 currentBlock b349 jump5 jumpTrue s35 jump2 s29 s26 jump7 jump4 |
	self SubCq: 16 R: SPReg.
	self MoveR: ReceiverResultReg R: Extra3Reg.
	self MoveR: Extra3Reg Mw: 0 r: SPReg.
	self MoveMw: 0 r: SPReg R: Extra3Reg.
	self MoveM64: 24 r: Extra3Reg R: Extra3Reg.
	self MoveR: Extra3Reg Mw: 8 r: SPReg.
	self MoveMw: 8 r: SPReg R: Extra3Reg.
	self ArithmeticShiftRightCq: 3 R: Extra3Reg.
	self MoveR: Extra3Reg Mw: 8 r: SPReg.
	self MoveMw: 8 r: SPReg R: Extra3Reg.
	self MoveR: Extra3Reg R: SendNumArgsReg.
	self ArithmeticShiftRightCq: 16 R: SendNumArgsReg.
	self AndCq: 31 R: SendNumArgsReg.
	self MoveR: SendNumArgsReg R: Extra0Reg.
	self CmpCq: 1 R: Extra0Reg.
	jumpTrue := self JumpBelowOrEqual: 0.
	self MoveCq: 0 R: Extra0Reg.
	jumpNext := self Jump: 0.
	jumpTrue jmpTarget: self Label.
	self MoveCq: 1 R: Extra0Reg.
	jumpNext jmpTarget: self Label.
	self CmpCq: 1 R: SendNumArgsReg.
	jump1 := self JumpAbove: 0.
	jump2 := self Jump: 0.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	self MoveR: SendNumArgsReg R: Extra0Reg.
	self CmpCq: 5 R: Extra0Reg.
	jumpTrue := self JumpZero: 0.
	self MoveCq: 0 R: Extra0Reg.
	jumpNext := self Jump: 0.
	jumpTrue jmpTarget: self Label.
	self MoveCq: 1 R: Extra0Reg.
	jumpNext jmpTarget: self Label.
	currentBlock := self Label.
	jump2 jmpTarget: currentBlock.
	self CmpCq: 1 R: Extra0Reg.
	jump2 := self JumpNonZero: 0.
	self MoveMw: 0 r: SPReg R: Extra3Reg.
	self MoveM32: 4 r: Extra3Reg R: Extra0Reg.
	self AndCq: 16rFFFFFFFF R: Extra0Reg.
	self AndCq: 16r3FFFFF R: Extra0Reg.
	self CmpCq: 0 R: Extra0Reg.
	jump1 := self JumpZero: 0.
	self CmpCq: 0 R: Extra0Reg.
	jump3 := self JumpBelow: 0.
	self MoveMw: 8 r: SPReg R: Extra3Reg.
	self AndCq: 16rFFFF R: Extra3Reg.
	self MoveR: Extra3Reg Mw: 8 r: SPReg.
	self MoveMw: 8 r: SPReg R: Extra3Reg.
	self CmpCq: 255 R: Extra3Reg.
	jump4 := self JumpAboveOrEqual: 0.
	self MoveMw: 8 r: SPReg R: Extra3Reg.
	self CmpCq: 1 R: Extra3Reg.
	jump5 := self JumpAboveOrEqual: 0.
	s26 := 8.
	self MoveCq: s26 R: Extra1Reg.
	jump6 := self Jump: 0.
	currentBlock := self Label.
	jump5 jmpTarget: currentBlock.
	s29 := 8.
	self MoveCq: s29 R: Extra1Reg.
	self MoveMw: 8 r: SPReg R: Extra3Reg.
	self MulR: Extra3Reg R: Extra1Reg.
	currentBlock := self Label.
	jump6 jmpTarget: currentBlock.
	s35 := 0.
	self AddCq: 8 R: Extra1Reg.
	self MoveAw: objectMemory freeStartAddress R: Extra2Reg.
	self AddR: Extra1Reg R: Extra2Reg.
	s39 := objectMemory getScavengeThreshold.
	self MoveCq: s39 R: TempReg.
	self MoveR: Extra2Reg R: ClassReg.
	self CmpR: TempReg R: ClassReg.
	jumpTrue := self JumpAbove: 0.
	self MoveCq: 0 R: ClassReg.
	jumpNext := self Jump: 0.
	jumpTrue jmpTarget: self Label.
	self MoveCq: 1 R: ClassReg.
	jumpNext jmpTarget: self Label.
	self CmpCq: s39 R: Extra2Reg.
	jump6 := self JumpBelowOrEqual: 0.
	self CmpCq: 1 R: ClassReg.
	jump5 := self JumpNonZero: 0.
	jump7 := self Jump: 0.
	currentBlock := self Label.
	jump6 jmpTarget: currentBlock.
	s48 := s35.
	currentBlock := self Label.
	jump5 jmpTarget: currentBlock.
	self MoveAw: objectMemory freeStartAddress R: ClassReg.
	self MoveMw: 8 r: SPReg R: Extra3Reg.
	self MoveR: Extra3Reg R: TempReg.
	self LogicalShiftLeftCq: 56 R: TempReg.
	self LogicalShiftLeftCq: 24 R: SendNumArgsReg.
	self AddR: SendNumArgsReg R: TempReg.
	self AddR: Extra0Reg R: TempReg.
	self OrCq: 0 R: TempReg.
	self MoveR: TempReg M64: 0 r: ClassReg.
	self MoveAw: objectMemory freeStartAddress R: TempReg.
	self AddR: Extra1Reg R: TempReg.
	self MoveR: TempReg Aw: objectMemory freeStartAddress.
	self CmpCq: 0 R: ClassReg.
	jump5 := self JumpNonZero: 0.
	currentBlock := self Label.
	jump2 jmpTarget: currentBlock.
	self MoveMw: 0 r: SPReg R: Extra3Reg.
	self MoveR: Extra3Reg R: TempReg.
	self MoveR: TempReg R: ReceiverResultReg.
	jump2 := self Jump: 0.
	currentBlock := self Label.
	jump5 jmpTarget: currentBlock.
	self genMoveConstant: objectMemory nilObject R: TempReg.
	self MoveR: ClassReg R: Extra1Reg.
	self AddCq: 8 R: Extra1Reg.
	s71 := 8.
	self MoveCq: s71 R: Extra0Reg.
	self MoveMw: 8 r: SPReg R: Extra3Reg.
	self MulR: Extra3Reg R: Extra0Reg.
	self MoveR: ClassReg R: SendNumArgsReg.
	self AddR: Extra0Reg R: SendNumArgsReg.
	self AddCq: 8 R: SendNumArgsReg.
	self SubCq: 1 R: SendNumArgsReg.
	b349 := self Label.
	self CmpR: Extra1Reg R: SendNumArgsReg.
	jump5 := self JumpLess: 0.
	self MoveR: TempReg M64: 0 r: Extra1Reg.
	self MoveR: Extra1Reg R: Extra0Reg.
	self AddCq: 8 R: Extra0Reg.
	self MoveR: Extra0Reg R: Extra1Reg.
	jump6 := self Jump: b349.
	currentBlock := self Label.
	jump5 jmpTarget: currentBlock.
	self MoveR: ClassReg R: ReceiverResultReg.
	self AddCq: 16 R: SPReg.
	self genPrimReturn.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	jump3 jmpTarget: currentBlock.
	jump4 jmpTarget: currentBlock.
	jump7 jmpTarget: currentBlock.
	jump2 jmpTarget: currentBlock.
	self AddCq: 16 R: SPReg.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveNewWithArg [
	"AutoGenerated by Druid"

	| jump5 s199 jump10 s64 jump3 s121 s53 jump8 jump1 s14 currentBlock s195 jump13 jumpNext s187 jump6 jump11 s56 jump4 b944 s168 jumpTrue jump9 jump2 jump7 jump12 s66 |
	self SubCq: 24 R: SPReg.
	self MoveR: ReceiverResultReg R: TempReg.
	self MoveR: Arg0Reg R: ClassReg.
	self TstCq: 1 R: ClassReg.
	jump1 := self JumpZero: 0.
	self ArithmeticShiftRightCq: 3 R: ClassReg.
	self CmpCq: 0 R: ClassReg.
	jump2 := self JumpLess: 0.
	self MoveM64: 24 r: TempReg R: SendNumArgsReg.
	self ArithmeticShiftRightCq: 3 R: SendNumArgsReg.
	self MoveR: SendNumArgsReg R: Extra0Reg.
	self ArithmeticShiftRightCq: 16 R: Extra0Reg.
	self AndCq: 31 R: Extra0Reg.
	self MoveM32: 4 r: TempReg R: Extra1Reg.
	self AndCq: 16rFFFFFFFF R: Extra1Reg.
	self AndCq: 16r3FFFFF R: Extra1Reg.
	s14 := 0.
	self CmpCq: 2 R: Extra0Reg.
	jump3 := self JumpNonZero: 0.
	self genMoveConstant: objectMemory nilObject R: SendNumArgsReg.
	jump4 := self Jump: 0.
	currentBlock := self Label.
	jump3 jmpTarget: currentBlock.
	self CmpCq: 3 R: Extra0Reg.
	jump3 := self JumpNonZero: 0.
	self AndCq: 16rFFFF R: SendNumArgsReg.
	self AddR: ClassReg R: SendNumArgsReg.
	self genMoveConstant: objectMemory nilObject R: Extra2Reg.
	self MoveR: SendNumArgsReg R: ClassReg.
	self MoveR: Extra2Reg R: SendNumArgsReg.
	jump5 := self Jump: 0.
	currentBlock := self Label.
	jump3 jmpTarget: currentBlock.
	self CmpCq: 4 R: Extra0Reg.
	jump3 := self JumpNonZero: 0.
	self AndCq: 16rFFFF R: SendNumArgsReg.
	self AddR: ClassReg R: SendNumArgsReg.
	self genMoveConstant: objectMemory nilObject R: Extra2Reg.
	self MoveR: SendNumArgsReg R: ClassReg.
	self MoveR: Extra2Reg R: SendNumArgsReg.
	jump6 := self Jump: 0.
	currentBlock := self Label.
	jump3 jmpTarget: currentBlock.
	self CmpCq: 9 R: Extra0Reg.
	jump3 := self JumpNonZero: 0.
	self MoveCq: s14 R: SendNumArgsReg.
	jump7 := self Jump: 0.
	currentBlock := self Label.
	jump3 jmpTarget: currentBlock.
	self CmpCq: 10 R: Extra0Reg.
	jump3 := self JumpNonZero: 0.
	self CmpCq: 34 R: Extra1Reg.
	jump8 := self JumpNonZero: 0.
	self MoveR: ClassReg R: Extra2Reg.
	self CmpCq: 2 R: Extra2Reg.
	jumpTrue := self JumpNonZero: 0.
	self MoveCq: 0 R: Extra2Reg.
	jumpNext := self Jump: 0.
	jumpTrue jmpTarget: self Label.
	self MoveCq: 1 R: Extra2Reg.
	jumpNext jmpTarget: self Label.
	self CmpCq: 2 R: ClassReg.
	jump9 := self JumpNonZero: 0.
	self MoveR: ClassReg R: Extra2Reg.
	self AddCq: 1 R: Extra2Reg.
	self MoveCq: 2 R: SendNumArgsReg.
	self
		DivR: SendNumArgsReg
		R: Extra2Reg
		Quo: Extra2Reg
		Rem: SendNumArgsReg.
	self AndCq: 1 R: ClassReg.
	self AddR: ClassReg R: Extra0Reg.
	s53 := 0.
	s56 := s53.
	jump10 := self Jump: 0.
	currentBlock := self Label.
	jump8 jmpTarget: currentBlock.
	self MoveR: ClassReg R: Extra2Reg.
	self AddCq: 1 R: Extra2Reg.
	self MoveCq: 2 R: SendNumArgsReg.
	self
		DivR: SendNumArgsReg
		R: Extra2Reg
		Quo: Extra2Reg
		Rem: SendNumArgsReg.
	self AndCq: 1 R: ClassReg.
	self AddR: ClassReg R: Extra0Reg.
	s64 := 0.
	self CmpCq: 0 R: Extra1Reg.
	jump8 := self JumpNonZero: 0.
	s66 := s64.
	self MoveR: Extra0Reg R: SendNumArgsReg.
	self MoveR: SendNumArgsReg R: Extra0Reg.
	self MoveCq: s66 R: SendNumArgsReg.
	jump11 := self Jump: 0.
	currentBlock := self Label.
	jump8 jmpTarget: currentBlock.
	s56 := s64.
	currentBlock := self Label.
	jump10 jmpTarget: currentBlock.
	self MoveCq: s56 R: SendNumArgsReg.
	jump10 := self Jump: 0.
	currentBlock := self Label.
	jump3 jmpTarget: currentBlock.
	self CmpCq: 12 R: Extra0Reg.
	jump3 := self JumpNonZero: 0.
	self MoveR: ClassReg R: SendNumArgsReg.
	self AddCq: 3 R: SendNumArgsReg.
	self MoveCq: 4 R: Extra2Reg.
	self
		DivR: Extra2Reg
		R: SendNumArgsReg
		Quo: Extra2Reg
		Rem: SendNumArgsReg.
	self MoveCq: 4 R: SendNumArgsReg.
	self SubR: ClassReg R: SendNumArgsReg.
	self AndCq: 3 R: SendNumArgsReg.
	self AddR: SendNumArgsReg R: Extra0Reg.
	self MoveR: Extra2Reg R: ClassReg.
	self MoveCq: s14 R: SendNumArgsReg.
	jump8 := self Jump: 0.
	currentBlock := self Label.
	jump3 jmpTarget: currentBlock.
	self CmpCq: 16 R: Extra0Reg.
	jump3 := self JumpNonZero: 0.
	self MoveR: ClassReg R: SendNumArgsReg.
	self AddCq: 7 R: SendNumArgsReg.
	self MoveCq: 8 R: Extra2Reg.
	self
		DivR: Extra2Reg
		R: SendNumArgsReg
		Quo: SendNumArgsReg
		Rem: Extra2Reg.
	self MoveCq: 8 R: Extra2Reg.
	self SubR: ClassReg R: Extra2Reg.
	self AndCq: 7 R: Extra2Reg.
	self AddR: Extra2Reg R: Extra0Reg.
	self MoveR: SendNumArgsReg R: ClassReg.
	self MoveCq: s14 R: SendNumArgsReg.
	jump12 := self Jump: 0.
	currentBlock := self Label.
	jump3 jmpTarget: currentBlock.
	self MoveR: ClassReg R: Extra2Reg.
	self CmpCq: 0 R: Extra2Reg.
	jumpTrue := self JumpNonZero: 0.
	self MoveCq: 0 R: Extra2Reg.
	jumpNext := self Jump: 0.
	jumpTrue jmpTarget: self Label.
	self MoveCq: 1 R: Extra2Reg.
	jumpNext jmpTarget: self Label.
	self CmpCq: 0 R: ClassReg.
	jump3 := self JumpZero: 0.
	jump13 := self Jump: 0.
	currentBlock := self Label.
	jump3 jmpTarget: currentBlock.
	self MoveR: Extra0Reg R: Extra2Reg.
	self CmpCq: 5 R: Extra2Reg.
	jumpTrue := self JumpAbove: 0.
	self MoveCq: 0 R: Extra2Reg.
	jumpNext := self Jump: 0.
	jumpTrue jmpTarget: self Label.
	self MoveCq: 1 R: Extra2Reg.
	jumpNext jmpTarget: self Label.
	currentBlock := self Label.
	jump13 jmpTarget: currentBlock.
	self CmpCq: 1 R: Extra2Reg.
	jump13 := self JumpNonZero: 0.
	s121 := 0.
	self MoveCq: s121 R: Extra2Reg.
	jump3 := self Jump: 0.
	currentBlock := self Label.
	jump13 jmpTarget: currentBlock.
	self AndCq: 16rFFFF R: SendNumArgsReg.
	self genMoveConstant: objectMemory nilObject R: Extra2Reg.
	self MoveR: SendNumArgsReg R: ClassReg.
	self MoveR: Extra2Reg R: SendNumArgsReg.
	currentBlock := self Label.
	jump4 jmpTarget: currentBlock.
	jump5 jmpTarget: currentBlock.
	jump6 jmpTarget: currentBlock.
	jump7 jmpTarget: currentBlock.
	jump8 jmpTarget: currentBlock.
	jump12 jmpTarget: currentBlock.
	self CmpCq: 0 R: Extra1Reg.
	jump12 := self JumpNonZero: 0.
	self MoveR: ClassReg R: Extra2Reg.
	currentBlock := self Label.
	jump11 jmpTarget: currentBlock.
	self MoveM32: 4 r: TempReg R: Extra1Reg.
	self AndCq: 16rFFFFFFFF R: Extra1Reg.
	self AndCq: 16r3FFFFF R: Extra1Reg.
	self CmpCq: 0 R: Extra1Reg.
	jump11 := self JumpZero: 0.
	self CmpCq: 0 R: Extra1Reg.
	jump8 := self JumpBelow: 0.
	self MoveR: Extra2Reg R: Extra3Reg.
	self MoveR: Extra3Reg Mw: 0 r: SPReg.
	self MoveR: Extra0Reg R: Extra3Reg.
	self MoveR: Extra3Reg Mw: 8 r: SPReg.
	self MoveR: SendNumArgsReg R: Extra3Reg.
	self MoveR: Extra3Reg Mw: 16 r: SPReg.
	jump7 := self Jump: 0.
	currentBlock := self Label.
	jump12 jmpTarget: currentBlock.
	self MoveR: ClassReg R: Extra2Reg.
	currentBlock := self Label.
	jump10 jmpTarget: currentBlock.
	self MoveR: Extra2Reg R: Extra3Reg.
	self MoveR: Extra3Reg Mw: 0 r: SPReg.
	self MoveR: Extra0Reg R: Extra3Reg.
	self MoveR: Extra3Reg Mw: 8 r: SPReg.
	self MoveR: SendNumArgsReg R: Extra3Reg.
	self MoveR: Extra3Reg Mw: 16 r: SPReg.
	currentBlock := self Label.
	jump7 jmpTarget: currentBlock.
	s168 := 0.
	self MoveMw: 0 r: SPReg R: Extra3Reg.
	self MoveR: Extra3Reg R: ClassReg.
	self CmpCq: 16rFFFF R: ClassReg.
	jumpTrue := self JumpAbove: 0.
	self MoveCq: 0 R: ClassReg.
	jumpNext := self Jump: 0.
	jumpTrue jmpTarget: self Label.
	self MoveCq: 1 R: ClassReg.
	jumpNext jmpTarget: self Label.
	self MoveMw: 0 r: SPReg R: Extra3Reg.
	self CmpCq: 16rFFFF R: Extra3Reg.
	jump7 := self JumpBelowOrEqual: 0.
	jump10 := self Jump: 0.
	currentBlock := self Label.
	jump7 jmpTarget: currentBlock.
	self MoveCq: s168 R: ClassReg.
	currentBlock := self Label.
	jump10 jmpTarget: currentBlock.
	self CmpCq: 1 R: ClassReg.
	jump10 := self JumpNonZero: 0.
	self MoveMw: 0 r: SPReg R: Extra3Reg.
	self CmpCq: 16r10000000000 R: Extra3Reg.
	jump7 := self JumpBelowOrEqual: 0.
	self MoveR: TempReg R: ReceiverResultReg.
	jump12 := self Jump: 0.
	currentBlock := self Label.
	jump7 jmpTarget: currentBlock.
	self MoveR: TempReg R: ReceiverResultReg.
	jump7 := self Jump: 0.
	currentBlock := self Label.
	jump10 jmpTarget: currentBlock.
	self MoveMw: 0 r: SPReg R: Extra3Reg.
	self CmpCq: 255 R: Extra3Reg.
	jump10 := self JumpBelow: 0.
	self MoveR: TempReg R: ReceiverResultReg.
	jump6 := self Jump: 0.
	currentBlock := self Label.
	jump10 jmpTarget: currentBlock.
	self MoveMw: 0 r: SPReg R: Extra3Reg.
	self CmpCq: 1 R: Extra3Reg.
	jump10 := self JumpAboveOrEqual: 0.
	s187 := 8.
	self MoveCq: s187 R: ClassReg.
	jump5 := self Jump: 0.
	currentBlock := self Label.
	jump10 jmpTarget: currentBlock.
	self MoveCq: 8 R: ClassReg.
	self MoveMw: 0 r: SPReg R: Extra3Reg.
	self MulR: Extra3Reg R: ClassReg.
	currentBlock := self Label.
	jump5 jmpTarget: currentBlock.
	s195 := 0.
	self AddCq: 8 R: ClassReg.
	self MoveAw: objectMemory freeStartAddress R: Extra2Reg.
	self AddR: ClassReg R: Extra2Reg.
	s199 := objectMemory getScavengeThreshold.
	self MoveCq: s199 R: Extra0Reg.
	self MoveR: Extra2Reg R: SendNumArgsReg.
	self CmpR: Extra0Reg R: SendNumArgsReg.
	jumpTrue := self JumpAbove: 0.
	self MoveCq: 0 R: SendNumArgsReg.
	jumpNext := self Jump: 0.
	jumpTrue jmpTarget: self Label.
	self MoveCq: 1 R: SendNumArgsReg.
	jumpNext jmpTarget: self Label.
	self CmpCq: s199 R: Extra2Reg.
	jump5 := self JumpBelowOrEqual: 0.
	jump10 := self Jump: 0.
	currentBlock := self Label.
	jump5 jmpTarget: currentBlock.
	self MoveCq: s195 R: SendNumArgsReg.
	currentBlock := self Label.
	jump10 jmpTarget: currentBlock.
	self CmpCq: 1 R: SendNumArgsReg.
	jump10 := self JumpNonZero: 0.
	self MoveR: TempReg R: ReceiverResultReg.
	jump5 := self Jump: 0.
	currentBlock := self Label.
	jump10 jmpTarget: currentBlock.
	self MoveAw: objectMemory freeStartAddress R: SendNumArgsReg.
	self MoveMw: 0 r: SPReg R: Extra3Reg.
	self MoveR: Extra3Reg R: Extra0Reg.
	self LogicalShiftLeftCq: 56 R: Extra0Reg.
	self MoveMw: 8 r: SPReg R: Extra3Reg.
	self LogicalShiftLeftCq: 24 R: Extra3Reg.
	self MoveR: Extra3Reg Mw: 8 r: SPReg.
	self MoveMw: 8 r: SPReg R: Extra3Reg.
	self AddR: Extra3Reg R: Extra0Reg.
	self AddR: Extra1Reg R: Extra0Reg.
	self OrCq: 0 R: Extra0Reg.
	self MoveR: Extra0Reg M64: 0 r: SendNumArgsReg.
	self MoveAw: objectMemory freeStartAddress R: Extra0Reg.
	self AddR: ClassReg R: Extra0Reg.
	self MoveR: Extra0Reg Aw: objectMemory freeStartAddress.
	self CmpCq: 0 R: SendNumArgsReg.
	jump10 := self JumpNonZero: 0.
	self MoveR: TempReg R: Extra0Reg.
	jump4 := self Jump: 0.
	currentBlock := self Label.
	jump10 jmpTarget: currentBlock.
	self MoveR: SendNumArgsReg R: Extra0Reg.
	self AddCq: 8 R: Extra0Reg.
	self MoveCq: 8 R: ClassReg.
	self MoveMw: 0 r: SPReg R: Extra3Reg.
	self MulR: Extra3Reg R: ClassReg.
	self MoveR: SendNumArgsReg R: Extra1Reg.
	self AddR: ClassReg R: Extra1Reg.
	self AddCq: 8 R: Extra1Reg.
	self SubCq: 1 R: Extra1Reg.
	b944 := self Label.
	self CmpR: Extra0Reg R: Extra1Reg.
	jump10 := self JumpLess: 0.
	self MoveMw: 16 r: SPReg R: Extra3Reg.
	self MoveR: Extra3Reg M64: 0 r: Extra0Reg.
	self MoveR: Extra0Reg R: ClassReg.
	self AddCq: 8 R: ClassReg.
	self MoveR: ClassReg R: Extra0Reg.
	jump13 := self Jump: b944.
	currentBlock := self Label.
	jump10 jmpTarget: currentBlock.
	self MoveR: TempReg R: Extra0Reg.
	currentBlock := self Label.
	jump4 jmpTarget: currentBlock.
	self MoveR: SendNumArgsReg R: Extra2Reg.
	self MoveR: Extra0Reg R: TempReg.
	currentBlock := self Label.
	jump3 jmpTarget: currentBlock.
	self CmpCq: 0 R: Extra2Reg.
	jump3 := self JumpNonZero: 0.
	self MoveR: TempReg R: ReceiverResultReg.
	jump4 := self Jump: 0.
	currentBlock := self Label.
	jump3 jmpTarget: currentBlock.
	self MoveR: Extra2Reg R: ReceiverResultReg.
	self AddCq: 24 R: SPReg.
	self genPrimReturn.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	jump2 jmpTarget: currentBlock.
	jump9 jmpTarget: currentBlock.
	jump11 jmpTarget: currentBlock.
	jump8 jmpTarget: currentBlock.
	jump12 jmpTarget: currentBlock.
	jump7 jmpTarget: currentBlock.
	jump6 jmpTarget: currentBlock.
	jump5 jmpTarget: currentBlock.
	jump4 jmpTarget: currentBlock.
	self AddCq: 24 R: SPReg.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveNextUint16At [
	"AutoGenerated by Druid"

	| currentBlock |
	self MoveM16: 1 r: ReceiverResultReg R: TempReg.
	self AndCq: 16rFFFF R: TempReg.
	self MoveR: TempReg R: ReceiverResultReg.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveNoopLoopWithInvariant [
	"AutoGenerated by Druid"

	| jump3 jump1 b22 currentBlock jump2 |
	self MoveR: ReceiverResultReg R: TempReg.
	self CmpCq: 10 R: TempReg.
	jump1 := self JumpGreaterOrEqual: 0.
	b22 := self Label.
	self MoveR: TempReg R: ClassReg.
	self AddCq: 1 R: ClassReg.
	self CmpCq: 10 R: ClassReg.
	jump2 := self JumpGreaterOrEqual: 0.
	self MoveR: ClassReg R: TempReg.
	jump3 := self Jump: b22.
	currentBlock := self Label.
	jump2 jmpTarget: currentBlock.
	self MoveCq: 5 R: ReceiverResultReg.
	jump2 := self Jump: 0.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	self MoveCq: 3 R: ReceiverResultReg.
	currentBlock := self Label.
	jump2 jmpTarget: currentBlock.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveNotEqualsThan [
	"AutoGenerated by Druid"

	| jump1 jump2 currentBlock |
	self MoveR: ReceiverResultReg R: TempReg.
	self CmpCq: 10 R: TempReg.
	jump1 := self JumpZero: 0.
	self MoveCq: 5 R: ReceiverResultReg.
	jump2 := self Jump: 0.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	self MoveCq: 11 R: ReceiverResultReg.
	currentBlock := self Label.
	jump2 jmpTarget: currentBlock.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveNotEqualsThanFloats [
	"AutoGenerated by Druid"

	| jumpNext currentBlock jumpTrue |
	self MoveR: ReceiverResultReg R: TempReg.
	self MoveR: Arg0Reg R: ClassReg.
	self ConvertR: ClassReg Rd: DPFPReg0.
	self ConvertR: TempReg Rd: DPFPReg1.
	self CmpRd: DPFPReg1 Rd: DPFPReg0.
	jumpTrue := self JumpFPNotEqual: 0.
	self MoveCq: 0 R: TempReg.
	jumpNext := self Jump: 0.
	jumpTrue jmpTarget: self Label.
	self MoveCq: 1 R: TempReg.
	jumpNext jmpTarget: self Label.
	self MoveR: TempReg R: ReceiverResultReg.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveNotEqualsThanInverted [
	"AutoGenerated by Druid"

	| jump1 jump2 currentBlock |
	self MoveR: ReceiverResultReg R: TempReg.
	self MoveCq: 10 R: ClassReg.
	self CmpR: TempReg R: ClassReg.
	jump1 := self JumpZero: 0.
	self MoveCq: 5 R: ReceiverResultReg.
	jump2 := self Jump: 0.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	self MoveCq: 11 R: ReceiverResultReg.
	currentBlock := self Label.
	jump2 jmpTarget: currentBlock.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveOr [
	"AutoGenerated by Druid"

	| jumpNext jumpTrue jump1 currentBlock jump2 |
	self MoveR: ReceiverResultReg R: TempReg.
	self MoveR: TempReg R: ClassReg.
	self CmpCq: 5 R: ClassReg.
	jumpTrue := self JumpLess: 0.
	self MoveCq: 0 R: ClassReg.
	jumpNext := self Jump: 0.
	jumpTrue jmpTarget: self Label.
	self MoveCq: 1 R: ClassReg.
	jumpNext jmpTarget: self Label.
	self CmpCq: 5 R: TempReg.
	jump1 := self JumpGreaterOrEqual: 0.
	jump2 := self Jump: 0.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	self CmpCq: 10 R: TempReg.
	jumpTrue := self JumpGreater: 0.
	self MoveCq: 0 R: TempReg.
	jumpNext := self Jump: 0.
	jumpTrue jmpTarget: self Label.
	self MoveCq: 1 R: TempReg.
	jumpNext jmpTarget: self Label.
	self MoveR: TempReg R: ClassReg.
	currentBlock := self Label.
	jump2 jmpTarget: currentBlock.
	self CmpCq: 1 R: ClassReg.
	jump2 := self JumpNonZero: 0.
	self MoveCq: 42 R: ReceiverResultReg.
	jump1 := self Jump: 0.
	currentBlock := self Label.
	jump2 jmpTarget: currentBlock.
	self MoveCq: 10 R: ReceiverResultReg.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitivePushFirstArgument [
	"AutoGenerated by Druid"

	| currentBlock |
	self MoveR: Arg0Reg R: TempReg.
	self MoveR: TempReg R: ReceiverResultReg.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitivePushReceiverOf0ArgSelector [
	"AutoGenerated by Druid"

	| currentBlock |
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitivePushReceiverOf1ArgSelector [
	"AutoGenerated by Druid"

	| currentBlock |
	self MoveR: Arg0Reg R: TempReg.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitivePushStackValue0 [
	"AutoGenerated by Druid"

	| currentBlock |
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitivePushStackValue0WithOneArgument [
	"AutoGenerated by Druid"

	| currentBlock |
	self MoveR: Arg0Reg R: ReceiverResultReg.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitivePushStackValue1 [
	"AutoGenerated by Druid"

	| currentBlock |
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveReturnFalse [
	"AutoGenerated by Druid"

	| currentBlock |
	self genMoveConstant: objectMemory falseObject R: TempReg.
	self MoveR: TempReg R: ReceiverResultReg.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveReturnOne [
	"AutoGenerated by Druid"

	| currentBlock |
	self MoveCq: 1 R: ReceiverResultReg.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveReturnOneWithArguments [
	"AutoGenerated by Druid"

	| currentBlock |
	self MoveR: Arg1Reg R: TempReg.
	self MoveR: Arg0Reg R: TempReg.
	self MoveCq: 1 R: ReceiverResultReg.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveReturnTrue [
	"AutoGenerated by Druid"

	| currentBlock |
	self genMoveConstant: objectMemory trueObject R: TempReg.
	self MoveR: TempReg R: ReceiverResultReg.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveSandclock [
	"AutoGenerated by Druid"

	| jump1 jump2 currentBlock |
	self MoveR: ReceiverResultReg R: TempReg.
	self CmpCq: 10 R: TempReg.
	jump1 := self JumpLessOrEqual: 0.
	self MoveCq: 1 R: TempReg.
	jump2 := self Jump: 0.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	self MoveCq: 99 R: ClassReg.
	self CmpCq: 0 R: TempReg.
	jump1 := self JumpLessOrEqual: 0.
	self MoveR: ClassReg R: TempReg.
	currentBlock := self Label.
	jump2 jmpTarget: currentBlock.
	self AddCq: 5 R: TempReg.
	self MoveR: TempReg R: ReceiverResultReg.
	jump2 := self Jump: 0.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	self MoveCq: 116 R: ReceiverResultReg.
	currentBlock := self Label.
	jump2 jmpTarget: currentBlock.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveSize [
	"AutoGenerated by Druid"

	| jump1 jumpNext jump6 jump3 currentBlock jump8 jump5 jumpTrue jump2 s101 s141 jump7 jump4 |
	self MoveR: ReceiverResultReg R: TempReg.
	self MoveR: TempReg R: Extra0Reg.
	self CmpCq: 7 R: Extra0Reg.
	jumpTrue := self JumpNonZero: 0.
	self MoveCq: 0 R: Extra0Reg.
	jumpNext := self Jump: 0.
	jumpTrue jmpTarget: self Label.
	self MoveCq: 1 R: Extra0Reg.
	jumpNext jmpTarget: self Label.
	self TstCq: 7 R: TempReg.
	jump1 := self JumpZero: 0.
	jump2 := self Jump: 0.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	self MoveM64: 0 r: TempReg R: Extra0Reg.
	self AndCq: 16r3FFFF7 R: Extra0Reg.
	self MoveR: Extra0Reg R: Extra1Reg.
	self CmpCq: 0 R: Extra1Reg.
	jumpTrue := self JumpZero: 0.
	self MoveCq: 0 R: Extra1Reg.
	jumpNext := self Jump: 0.
	jumpTrue jmpTarget: self Label.
	self MoveCq: 1 R: Extra1Reg.
	jumpNext jmpTarget: self Label.
	self CmpCq: 0 R: Extra0Reg.
	jump1 := self JumpNonZero: 0.
	jump3 := self Jump: 0.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	self MoveM64: 0 r: TempReg R: ClassReg.
	self MoveR: ClassReg R: SendNumArgsReg.
	self ArithmeticShiftRightCq: 24 R: SendNumArgsReg.
	self AndCq: 31 R: SendNumArgsReg.
	self MoveR: SendNumArgsReg R: Extra1Reg.
	self CmpCq: 2 R: Extra1Reg.
	jumpTrue := self JumpBelow: 0.
	self MoveCq: 0 R: Extra1Reg.
	jumpNext := self Jump: 0.
	jumpTrue jmpTarget: self Label.
	self MoveCq: 1 R: Extra1Reg.
	jumpNext jmpTarget: self Label.
	currentBlock := self Label.
	jump3 jmpTarget: currentBlock.
	self MoveR: Extra1Reg R: Extra0Reg.
	currentBlock := self Label.
	jump2 jmpTarget: currentBlock.
	self CmpCq: 1 R: Extra0Reg.
	jump2 := self JumpZero: 0.
	self CmpCq: 3 R: SendNumArgsReg.
	jump3 := self JumpNonZero: 0.
	self AndCq: 16r3FFFFF R: ClassReg.
	self MoveR: ClassReg R: Extra1Reg.
	self CmpCq: 36 R: Extra1Reg.
	jumpTrue := self JumpZero: 0.
	self MoveCq: 0 R: Extra1Reg.
	jumpNext := self Jump: 0.
	jumpTrue jmpTarget: self Label.
	self MoveCq: 1 R: Extra1Reg.
	jumpNext jmpTarget: self Label.
	self CmpCq: 36 R: ClassReg.
	jump1 := self JumpZero: 0.
	self MoveMb: 7 r: TempReg R: Extra1Reg.
	self AndCq: 255 R: Extra1Reg.
	self CmpCq: 255 R: Extra1Reg.
	jump4 := self JumpNonZero: 0.
	jump5 := self Jump: 0.
	currentBlock := self Label.
	jump4 jmpTarget: currentBlock.
	jump4 := self Jump: 0.
	currentBlock := self Label.
	jump3 jmpTarget: currentBlock.
	self MoveMb: 7 r: TempReg R: Extra1Reg.
	self AndCq: 255 R: Extra1Reg.
	self CmpCq: 255 R: Extra1Reg.
	jump3 := self JumpNonZero: 0.
	currentBlock := self Label.
	jump5 jmpTarget: currentBlock.
	self MoveM64: -8 r: TempReg R: Extra1Reg.
	self LogicalShiftLeftCq: 8 R: Extra1Reg.
	self ArithmeticShiftRightCq: 8 R: Extra1Reg.
	self CmpCq: 5 R: SendNumArgsReg.
	jump5 := self JumpBelowOrEqual: 0.
	jump6 := self Jump: 0.
	currentBlock := self Label.
	jump3 jmpTarget: currentBlock.
	currentBlock := self Label.
	jump4 jmpTarget: currentBlock.
	self CmpCq: 5 R: SendNumArgsReg.
	jump4 := self JumpAbove: 0.
	currentBlock := self Label.
	jump5 jmpTarget: currentBlock.
	jump5 := self Jump: 0.
	currentBlock := self Label.
	jump4 jmpTarget: currentBlock.
	currentBlock := self Label.
	jump6 jmpTarget: currentBlock.
	self CmpCq: 16 R: SendNumArgsReg.
	jump6 := self JumpBelow: 0.
	self LogicalShiftLeftCq: 3 R: Extra1Reg.
	self MoveR: SendNumArgsReg R: ClassReg.
	self AndCq: 7 R: ClassReg.
	self SubR: ClassReg R: Extra1Reg.
	jump4 := self Jump: 0.
	currentBlock := self Label.
	jump6 jmpTarget: currentBlock.
	self CmpCq: 12 R: SendNumArgsReg.
	jump6 := self JumpBelow: 0.
	self LogicalShiftLeftCq: 2 R: Extra1Reg.
	self MoveR: SendNumArgsReg R: ClassReg.
	self AndCq: 3 R: ClassReg.
	self SubR: ClassReg R: Extra1Reg.
	jump3 := self Jump: 0.
	currentBlock := self Label.
	jump6 jmpTarget: currentBlock.
	self CmpCq: 10 R: SendNumArgsReg.
	jump6 := self JumpBelow: 0.
	self LogicalShiftLeftCq: 1 R: Extra1Reg.
	self MoveR: SendNumArgsReg R: ClassReg.
	self AndCq: 1 R: ClassReg.
	self SubR: ClassReg R: Extra1Reg.
	jump7 := self Jump: 0.
	currentBlock := self Label.
	jump6 jmpTarget: currentBlock.
	self CmpCq: 9 R: SendNumArgsReg.
	jump6 := self JumpNonZero: 0.
	jump8 := self Jump: 0.
	currentBlock := self Label.
	jump6 jmpTarget: currentBlock.
	s101 := 0.
	self MoveCq: s101 R: Extra1Reg.
	currentBlock := self Label.
	jump5 jmpTarget: currentBlock.
	jump4 jmpTarget: currentBlock.
	jump3 jmpTarget: currentBlock.
	jump7 jmpTarget: currentBlock.
	jump8 jmpTarget: currentBlock.
	self MoveR: SendNumArgsReg R: ClassReg.
	self CmpCq: 9 R: ClassReg.
	jumpTrue := self JumpAboveOrEqual: 0.
	self MoveCq: 0 R: ClassReg.
	jumpNext := self Jump: 0.
	jumpTrue jmpTarget: self Label.
	self MoveCq: 1 R: ClassReg.
	jumpNext jmpTarget: self Label.
	self CmpCq: 9 R: SendNumArgsReg.
	jump8 := self JumpBelow: 0.
	jump7 := self Jump: 0.
	currentBlock := self Label.
	jump8 jmpTarget: currentBlock.
	self MoveR: SendNumArgsReg R: ClassReg.
	self CmpCq: 2 R: ClassReg.
	jumpTrue := self JumpZero: 0.
	self MoveCq: 0 R: ClassReg.
	jumpNext := self Jump: 0.
	jumpTrue jmpTarget: self Label.
	self MoveCq: 1 R: ClassReg.
	jumpNext jmpTarget: self Label.
	currentBlock := self Label.
	jump7 jmpTarget: currentBlock.
	self CmpCq: 1 R: ClassReg.
	jump7 := self JumpNonZero: 0.
	self SubCq: 0 R: Extra1Reg.
	self MoveR: Extra1Reg R: ClassReg.
	self LogicalShiftLeftCq: 3 R: ClassReg.
	self AddCq: 1 R: ClassReg.
	self MoveR: ClassReg R: ReceiverResultReg.
	jump8 := self Jump: 0.
	currentBlock := self Label.
	jump7 jmpTarget: currentBlock.
	self CmpCq: 2 R: SendNumArgsReg.
	jump7 := self JumpAboveOrEqual: 0.
	self SubR: Extra1Reg R: Extra1Reg.
	self MoveR: Extra1Reg R: ClassReg.
	self LogicalShiftLeftCq: 3 R: ClassReg.
	self AddCq: 1 R: ClassReg.
	self MoveR: ClassReg R: ReceiverResultReg.
	jump3 := self Jump: 0.
	currentBlock := self Label.
	jump7 jmpTarget: currentBlock.
	self MoveM64: 0 r: TempReg R: ClassReg.
	self AndCq: 16r3FFFFF R: ClassReg.
	self CmpCq: 31 R: ClassReg.
	jump7 := self JumpAbove: 0.
	self CmpCq: 31 R: ClassReg.
	jump4 := self JumpNonZero: 0.
	self MoveR: TempReg R: ClassReg.
	jump5 := self Jump: 0.
	currentBlock := self Label.
	jump4 jmpTarget: currentBlock.
	self CmpCq: 8 R: ClassReg.
	jump4 := self JumpNonZero: 0.
	self genMoveConstant: objectMemory nilObject R: ClassReg.
	jump6 := self Jump: 0.
	currentBlock := self Label.
	jump7 jmpTarget: currentBlock.
	jump4 jmpTarget: currentBlock.
	self MoveR: ClassReg R: TempReg.
	self ArithmeticShiftRightCq: 10 R: TempReg.
	s141 := objectMemory hiddenRootsObject.
	self LogicalShiftLeftCq: 3 R: TempReg.
	self MoveCq: s141 R: SendNumArgsReg.
	self AddR: TempReg R: SendNumArgsReg.
	self MoveM64: 8 r: SendNumArgsReg R: SendNumArgsReg.
	self genMoveConstant: objectMemory nilObject R: TempReg.
	self CmpR: TempReg R: SendNumArgsReg.
	jump4 := self JumpNonZero: 0.
	self genMoveConstant: objectMemory nilObject R: TempReg.
	jump7 := self Jump: 0.
	currentBlock := self Label.
	jump4 jmpTarget: currentBlock.
	self AndCq: 1023 R: ClassReg.
	self LogicalShiftLeftCq: 3 R: ClassReg.
	self AddR: ClassReg R: SendNumArgsReg.
	self MoveM64: 8 r: SendNumArgsReg R: TempReg.
	currentBlock := self Label.
	jump7 jmpTarget: currentBlock.
	self MoveR: TempReg R: ClassReg.
	currentBlock := self Label.
	jump5 jmpTarget: currentBlock.
	jump6 jmpTarget: currentBlock.
	self MoveM64: 24 r: ClassReg R: TempReg.
	self ArithmeticShiftRightCq: 3 R: TempReg.
	self AndCq: 16rFFFF R: TempReg.
	self SubR: TempReg R: Extra1Reg.
	self MoveR: Extra1Reg R: TempReg.
	self LogicalShiftLeftCq: 3 R: TempReg.
	self AddCq: 1 R: TempReg.
	self MoveR: TempReg R: ReceiverResultReg.
	currentBlock := self Label.
	jump8 jmpTarget: currentBlock.
	jump3 jmpTarget: currentBlock.
	self genPrimReturn.
	currentBlock := self Label.
	jump2 jmpTarget: currentBlock.
	jump1 jmpTarget: currentBlock.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveSizeofusqInt [
	"AutoGenerated by Druid"

	| currentBlock |
	self MoveCq: 8 R: ReceiverResultReg.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveSmallOrEqualsThan [

	| currentBlock jump0 jump1 |
	self MoveCq: true asBit R: TempReg.
	self MoveCq: 10 R: ClassReg.
	self CmpCq: 10 R: ReceiverResultReg.
	jump0 := self JumpGreater: 0.
	self MoveCq: 5 R: Extra0Reg.
	self MoveCq: 5 R: Extra1Reg.
	self MoveR: Extra1Reg R: ClassReg.
	self MoveR: ReceiverResultReg R: SendNumArgsReg.
	jump1 := self Jump: 0.
	currentBlock := self Label.
	jump0 jmpTarget: currentBlock.
	self MoveCq: 11 R: Extra2Reg.
	self MoveCq: 11 R: TempReg.
	self MoveR: TempReg R: ClassReg.
	self MoveR: ReceiverResultReg R: SendNumArgsReg.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	self MoveCq: 1 R: Extra0Reg.
	self MoveR: ClassReg R: ReceiverResultReg.
	self RetN: 1 * objectMemory wordSize.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveSmallThan [

	| currentBlock jump0 jump1 |
	self MoveCq: true asBit R: TempReg.
	self MoveCq: 10 R: ClassReg.
	self CmpCq: 10 R: ReceiverResultReg.
	jump0 := self JumpGreaterOrEqual: 0.
	self MoveCq: 5 R: Extra0Reg.
	self MoveCq: 5 R: Extra1Reg.
	self MoveR: Extra1Reg R: ClassReg.
	self MoveR: ReceiverResultReg R: SendNumArgsReg.
	jump1 := self Jump: 0.
	currentBlock := self Label.
	jump0 jmpTarget: currentBlock.
	self MoveCq: 11 R: Extra2Reg.
	self MoveCq: 11 R: TempReg.
	self MoveR: TempReg R: ClassReg.
	self MoveR: ReceiverResultReg R: SendNumArgsReg.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	self MoveCq: 1 R: Extra0Reg.
	self MoveR: ClassReg R: ReceiverResultReg.
	self RetN: 1 * objectMemory wordSize.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveSubWithOverflow [
	"AutoGenerated by Druid"

	| jump1 jump2 currentBlock |
	self MoveR: ReceiverResultReg R: TempReg.
	self MoveR: Arg0Reg R: ClassReg.
	self AddCq:  -1 R: ClassReg.
	self SubR: ClassReg R: TempReg.
	jump1 := self JumpNoOverflow: 0.
	self MoveCq: 99 R: ReceiverResultReg.
	jump2 := self Jump: 0.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	self MoveR: TempReg R: ReceiverResultReg.
	currentBlock := self Label.
	jump2 jmpTarget: currentBlock.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveSumWithOverflow [
	"AutoGenerated by Druid"

	| jump1 jump2 currentBlock |
	self MoveR: ReceiverResultReg R: TempReg.
	self MoveR: Arg0Reg R: ClassReg.
	self AddCq:  -1 R: TempReg.
	self AddR: ClassReg R: TempReg.
	jump1 := self JumpNoOverflow: 0.
	self MoveCq: 99 R: ReceiverResultReg.
	jump2 := self Jump: 0.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	self MoveR: TempReg R: ReceiverResultReg.
	currentBlock := self Label.
	jump2 jmpTarget: currentBlock.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveTrueAssignmentAsInteger [
	"AutoGenerated by Druid"

	| currentBlock |
	self MoveCq: 1 R: ReceiverResultReg.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveTrueAssignmentAsIntegerShifted [
	"AutoGenerated by Druid"

	| currentBlock |
	self MoveCq: 2 R: ReceiverResultReg.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveTrueNot [
	"AutoGenerated by Druid"

	| currentBlock |
	self MoveCq: 0 R: ReceiverResultReg.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveUint16At [
	"AutoGenerated by Druid"

	| currentBlock |
	self MoveR: ReceiverResultReg R: TempReg.
	self MoveM16: 0 r: TempReg R: TempReg.
	self AndCq: 16rFFFF R: TempReg.
	self MoveR: TempReg R: ReceiverResultReg.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveUint16AtPut [
	"AutoGenerated by Druid"

	| currentBlock |
	self MoveR: ReceiverResultReg R: TempReg.
	self MoveR: Arg0Reg R: ClassReg.
	self MoveR: ClassReg M16: 0 r: TempReg.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveUint32At [
	"AutoGenerated by Druid"

	| currentBlock |
	self MoveR: ReceiverResultReg R: TempReg.
	self MoveM32: 0 r: TempReg R: TempReg.
	self AndCq: 16rFFFFFFFF R: TempReg.
	self MoveR: TempReg R: ReceiverResultReg.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveUint32AtPut [
	"AutoGenerated by Druid"

	| currentBlock |
	self MoveR: ReceiverResultReg R: TempReg.
	self MoveR: Arg0Reg R: ClassReg.
	self MoveR: ClassReg M32: 0 r: TempReg.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveUint64At [
	"AutoGenerated by Druid"

	| currentBlock |
	self MoveR: ReceiverResultReg R: TempReg.
	self MoveM64: 0 r: TempReg R: TempReg.
	self MoveR: TempReg R: ReceiverResultReg.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveUint64AtPut [
	"AutoGenerated by Druid"

	| currentBlock |
	self MoveR: ReceiverResultReg R: TempReg.
	self MoveR: Arg0Reg R: ClassReg.
	self MoveR: ClassReg M64: 0 r: TempReg.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveUint8At [
	"AutoGenerated by Druid"

	| currentBlock |
	self MoveR: ReceiverResultReg R: TempReg.
	self MoveMb: 0 r: TempReg R: TempReg.
	self AndCq: 255 R: TempReg.
	self MoveR: TempReg R: ReceiverResultReg.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveUint8AtPut [
	"AutoGenerated by Druid"

	| currentBlock |
	self MoveR: ReceiverResultReg R: TempReg.
	self MoveR: Arg0Reg R: ClassReg.
	self MoveR: ClassReg Mb: 0 r: TempReg.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveWithDeadCode [
	"AutoGenerated by Druid"

	| jump1 jump2 currentBlock |
	self MoveR: ReceiverResultReg R: TempReg.
	self CmpCq: 0 R: TempReg.
	jump1 := self JumpNonZero: 0.
	self MoveCq: 42 R: ReceiverResultReg.
	jump2 := self Jump: 0.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	self MoveCq: 55 R: ReceiverResultReg.
	currentBlock := self Label.
	jump2 jmpTarget: currentBlock.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveWithIfAssigningValue [

	| currentBlock jump0 jump1 |
	self CmpCq: 0 R: ReceiverResultReg.
	jump0 := self JumpZero: 0.
	self MoveCq: 57 R: ReceiverResultReg.
	jump1 := self Jump: 0.
	
	currentBlock := self Label.
	jump0 jmpTarget: currentBlock.
	self MoveCq: 42 R: ReceiverResultReg.
	
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	self RetN: 1 * objectMemory wordSize.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveWithIfNilIfNotNilStatement [
	"AutoGenerated by Druid"

	| jump1 jump2 currentBlock |
	self MoveR: ReceiverResultReg R: TempReg.
	self CmpCq: 0 R: TempReg.
	jump1 := self JumpLessOrEqual: 0.
	self MoveCq: 17 R: ReceiverResultReg.
	jump2 := self Jump: 0.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	self MoveCq: 42 R: ReceiverResultReg.
	currentBlock := self Label.
	jump2 jmpTarget: currentBlock.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveWithIfNotNilIfNilStatement [
	"AutoGenerated by Druid"

	| jump1 jump2 currentBlock |
	self MoveR: ReceiverResultReg R: TempReg.
	self CmpCq: 0 R: TempReg.
	jump1 := self JumpLessOrEqual: 0.
	self MoveCq: 17 R: ReceiverResultReg.
	jump2 := self Jump: 0.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	self MoveCq: 42 R: ReceiverResultReg.
	currentBlock := self Label.
	jump2 jmpTarget: currentBlock.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveWithIfNotNilIfNilStatementWithArgument [
	"AutoGenerated by Druid"

	| jump1 jump2 currentBlock |
	self MoveR: ReceiverResultReg R: TempReg.
	self CmpCq: 0 R: TempReg.
	jump1 := self JumpLessOrEqual: 0.
	self MoveCq: 17 R: ReceiverResultReg.
	jump2 := self Jump: 0.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	self MoveCq: 42 R: ReceiverResultReg.
	currentBlock := self Label.
	jump2 jmpTarget: currentBlock.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveWithIfNotNilStatement [
	"AutoGenerated by Druid"

	| jump1 jump2 currentBlock |
	self MoveR: ReceiverResultReg R: TempReg.
	self CmpCq: 0 R: TempReg.
	jump1 := self JumpLessOrEqual: 0.
	self MoveCq: 17 R: ReceiverResultReg.
	jump2 := self Jump: 0.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	self MoveCq: 42 R: ReceiverResultReg.
	currentBlock := self Label.
	jump2 jmpTarget: currentBlock.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveWithIfReturningValue [

	| currentBlock jump0 jump1 |
	self CmpCq: 0 R: ReceiverResultReg.
	jump0 := self JumpZero: 0.
	self MoveCq: 57 R: ReceiverResultReg.
	jump1 := self Jump: 0.
	
	currentBlock := self Label.
	jump0 jmpTarget: currentBlock.
	self MoveCq: 42 R: ReceiverResultReg.
	
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveWithNonCompilableBranch [
	"AutoGenerated by Druid"

	| jump1 currentBlock |
	self MoveR: ReceiverResultReg R: TempReg.
	self CmpCq: 0 R: TempReg.
	jump1 := self JumpLessOrEqual: 0.
	self MoveCq: 11 R: ReceiverResultReg.
	self genPrimReturn.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_primitiveWithSequentialExitPoint [
	"AutoGenerated by Druid"

	| currentBlock |
	^ CompletePrimitive
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_pushConstantOneBytecode [
	"AutoGenerated by Druid"

	| live currentBlock s2 |
	live := 0.
	s2 := ConstOne.
	self ssPushConstant: s2.
	^ 0
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_pushConstantTrueBytecode [
	"AutoGenerated by Druid"

	| live currentBlock s2 |
	live := 0.
	s2 := objectMemory trueObject.
	self ssPushConstant: s2.
	^ 0
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_pushConstantZeroBytecode [
	"AutoGenerated by Druid"

	| live currentBlock s2 |
	live := 0.
	s2 := ConstZero.
	self ssPushConstant: s2.
	^ 0
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_pushLiteralConstantBytecode [
	"AutoGenerated by Druid"

	| s3 t0 s4 t1 currentBlock live s5 |
	live := 0.
	t0 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t0).
	self genMoveConstant: methodObj R: t0.
	s3 := LiteralStart.
	s4 := s3 + 1.
	s5 := s4 << 3.
	t1 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t1).
	self MoveCq: s5 R: t1.
	self AddR: t1 R: t0.
	self ssPushBase: t0 offset: 8.
	^ 0
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_pushLiteralVariable16CasesBytecode [
	"AutoGenerated by Druid"

	| jump1 s31 s3 jumpNext t1 jump3 currentBlock t0 jump2 s32 s4 b233 jumpTrue live t2 jump4 |
	live := 0.
	t0 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t0).
	self genMoveConstant: methodObj R: t0.
	s3 := LiteralStart.
	s4 := s3 << 3.
	t1 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t1).
	self MoveCq: s4 R: t1.
	self AddR: t1 R: t0.
	self MoveM64: 8 r: t0 R: t1.
	self MoveM64: 0 r: t1 R: t0.
	self AndCq: 16r3FFFF7 R: t0.
	self CmpCq: 0 R: t0.
	jump1 := self JumpNonZero: 0.
	self MoveM64: 8 r: t1 R: t0.
	b233 := self Label.
	self MoveR: t0 R: t1.
	self AndCq: 7 R: t1.
	self CmpCq: 0 R: t1.
	jump2 := self JumpNonZero: 0.
	self MoveM64: 0 r: t0 R: t1.
	self AndCq: 16r3FFFF7 R: t1.
	t2 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t2).
	self MoveR: t1 R: t2.
	self CmpCq: 0 R: t2.
	jumpTrue := self JumpZero: 0.
	self MoveCq: 0 R: t2.
	jumpNext := self Jump: 0.
	jumpTrue jmpTarget: self Label.
	self MoveCq: 1 R: t2.
	jumpNext jmpTarget: self Label.
	self CmpCq: 0 R: t1.
	jump3 := self JumpNonZero: 0.
	self MoveM64: 8 r: t0 R: t2.
	self MoveR: t2 R: t0.
	jump4 := self Jump: b233.
	currentBlock := self Label.
	jump2 jmpTarget: currentBlock.
	jump3 jmpTarget: currentBlock.
	self MoveR: t0 R: t2.
	jump3 := self Jump: 0.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	self MoveR: t1 R: t2.
	currentBlock := self Label.
	jump3 jmpTarget: currentBlock.
	s31 := ValueIndex.
	s32 := s31 << 3.
	self MoveCq: s32 R: t0.
	self AddR: t0 R: t2.
	self ssPushBase: t2 offset: 8.
	^ 0
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_pushReceiverBytecode [
	"AutoGenerated by Druid"

	| live currentBlock t0 |
	live := 0.
	self ensureReceiverResultRegContainsSelf.
	t0 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t0).
	self MoveR: ReceiverResultReg R: t0.
	self ssPushRegister: t0.
	^ 0
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_pushReceiverVariableBytecode [
	"AutoGenerated by Druid"

	| live currentBlock t0 |
	live := 0.
	self ensureReceiverResultRegContainsSelf.
	t0 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t0).
	self MoveR: ReceiverResultReg R: t0.
	self ssPushBase: t0 offset: 16.
	^ 0
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_pushTemporaryVariableBytecode [
	"AutoGenerated by Druid"

	| live currentBlock t0 |
	live := 0.
	t0 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t0).
	(self simStackTempAt: 0) copyToReg: t0.
	self ssPushRegister: t0.
	^ 0
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_returnFalse [
	"AutoGenerated by Druid"

	| live currentBlock s2 |
	live := 0.
	s2 := objectMemory falseObject.
	self MoveCq: s2 R: ReceiverResultReg.
	self genUpArrowReturn.
	^ 0
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_returnNil [
	"AutoGenerated by Druid"

	| live currentBlock s2 |
	live := 0.
	s2 := objectMemory nilObject.
	self MoveCq: s2 R: ReceiverResultReg.
	self genUpArrowReturn.
	^ 0
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_returnReceiver [
	"AutoGenerated by Druid"

	| live currentBlock t0 |
	live := 0.
	self ensureReceiverResultRegContainsSelf.
	t0 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t0).
	self MoveR: ReceiverResultReg R: t0.
	self MoveR: t0 R: ReceiverResultReg.
	self genUpArrowReturn.
	^ 0
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_returnTopFromMethod [
	"AutoGenerated by Druid"

	| live currentBlock t0 |
	live := 0.
	t0 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t0).
	(self ssValue: 0) copyToReg: t0.
	self ssPop: 1.
	self MoveR: t0 R: ReceiverResultReg.
	self genUpArrowReturn.
	^ 0
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_returnTrue [
	"AutoGenerated by Druid"

	| live currentBlock s2 |
	live := 0.
	s2 := objectMemory trueObject.
	self MoveCq: s2 R: ReceiverResultReg.
	self genUpArrowReturn.
	^ 0
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_sendLiteralSelector0ArgsBytecode [
	"AutoGenerated by Druid"

	| live currentBlock |
	live := 0.
	self marshallSendArguments: 0.
	self
		genMarshalledSend: 1
		numArgs: 0
		sendTable: ordinarySendTrampolines.
	^ 0
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_shortConditionalJumpFalse [
	"AutoGenerated by Druid"

	| jump1 s8 s5 s2 currentBlock s12 t0 jump2 live s9 |
	live := 0.
	self annotateBytecode: self Label.
	t0 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t0).
	(self ssValue: 0) copyToReg: t0.
	self ssPop: 1.
	s5 := objectMemory falseObject.
	self ssFlushStack.
	self CmpCq: s5 R: t0.
	jump1 := self JumpNonZero: 0.
	s8 := bytecodePC.
	s9 := s8 + 2.
	self Jump: (self ensureFixupAt: s9).
	deadCode := true.
	jump2 := self Jump: 0.
	deadCode := false.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	s12 := objectMemory trueObject.
	self CmpCq: s12 R: t0.
	jump1 := self JumpZero: 0.
	self MoveR: t0 R: TempReg.
	self CallRT: ceSendMustBeBooleanTrampoline.
	currentBlock := self Label.
	jump2 jmpTarget: currentBlock.
	jump1 jmpTarget: currentBlock.
	^ 0
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_shortConditionalJumpTrue [
	"AutoGenerated by Druid"

	| jump1 s8 s5 s2 currentBlock s12 t0 jump2 live s9 |
	live := 0.
	self annotateBytecode: self Label.
	t0 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t0).
	(self ssValue: 0) copyToReg: t0.
	self ssPop: 1.
	s5 := objectMemory trueObject.
	self ssFlushStack.
	self CmpCq: s5 R: t0.
	jump1 := self JumpNonZero: 0.
	s8 := bytecodePC.
	s9 := s8 + 2.
	self Jump: (self ensureFixupAt: s9).
	deadCode := true.
	jump2 := self Jump: 0.
	deadCode := false.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	s12 := objectMemory falseObject.
	self CmpCq: s12 R: t0.
	jump1 := self JumpZero: 0.
	self MoveR: t0 R: TempReg.
	self CallRT: ceSendMustBeBooleanTrampoline.
	currentBlock := self Label.
	jump2 jmpTarget: currentBlock.
	jump1 jmpTarget: currentBlock.
	^ 0
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_shortUnconditionalJump [
	"AutoGenerated by Druid"

	| s5 s2 currentBlock live s3 |
	live := 0.
	s2 := bytecodePC.
	s3 := s2 + 2.
	self ssFlushStack.
	self Jump: (self ensureFixupAt: s3).
	deadCode := true.
	^ 0
]

{ #category : #generated }
DruidTestRTLCompiler >> gen_storeAndPopReceiverVariableBytecode [
	"AutoGenerated by Druid"

	| jump5 s16 s64 s29 s77 s31 t3 jump3 s53 jump8 s2 s20 currentBlock t1 jump1 s51 jumpNext s25 s73 s82 s47 jump6 live jump4 s87 jumpTrue s45 jump9 jump2 t2 s59 s91 jump7 t0 |
	live := 0.
	self annotateBytecode: self Label.
	self ensureReceiverResultRegContainsSelf.
	t0 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t0).
	self MoveR: ReceiverResultReg R: t0.
	t1 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t1).
	(self ssValue: 0) copyToReg: t1.
	t2 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t2).
	self MoveM64: 0 r: t0 R: t2.
	self ArithmeticShiftRightCq: 23 R: t2.
	self AndCq: 1 R: t2.
	self ssFlushStack.
	self CmpCq: 0 R: t2.
	jump1 := self JumpZero: 0.
	self deoptimize.
	jump2 := self Jump: 0.
	deadCode := false.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	self ssPop: 1.
	self MoveR: t0 R: t2.
	self AndCq: 7 R: t2.
	self CmpCq: 0 R: t2.
	jump1 := self JumpNonZero: 0.
	s16 := objectMemory getMemoryMap getSpaceMaskToUse.
	self MoveCq: s16 R: t2.
	t3 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t3).
	self MoveR: t0 R: t3.
	self AndR: t2 R: t3.
	s20 := objectMemory getMemoryMap getOldSpaceMask.
	self CmpCq: s20 R: t3.
	jump3 := self JumpNonZero: 0.
	self MoveR: t1 R: t3.
	self AndCq: 7 R: t3.
	self CmpCq: 0 R: t3.
	jump4 := self JumpNonZero: 0.
	s25 := objectMemory getMemoryMap getSpaceMaskToUse.
	self MoveCq: s25 R: t3.
	self MoveR: t1 R: t2.
	self AndR: t3 R: t2.
	s29 := objectMemory getMemoryMap getNewSpaceMask.
	self CmpCq: s29 R: t2.
	jump5 := self JumpNonZero: 0.
	s31 := objectMemory getMemoryMap getNewSpaceStart.
	self MoveCq: s31 R: t2.
	self MoveR: t1 R: t3.
	self CmpR: t2 R: t3.
	jumpTrue := self JumpAboveOrEqual: 0.
	self MoveCq: 0 R: t3.
	jumpNext := self Jump: 0.
	jumpTrue jmpTarget: self Label.
	self MoveCq: 1 R: t3.
	jumpNext jmpTarget: self Label.
	self CmpCq: 1 R: t3.
	jump6 := self JumpNonZero: 0.
	self MoveM64: 0 r: t0 R: t3.
	self ArithmeticShiftRightCq: 29 R: t3.
	self AndCq: 1 R: t3.
	self CmpCq: 0 R: t3.
	jump7 := self JumpNonZero: 0.
	self MoveR: t0 R: TempReg.
	backEnd saveAndRestoreLinkRegAround: [
		self CallRT: ceStoreCheckTrampoline ].
	self TstCq: 7 R: t1.
	jump8 := self JumpNonZero: 0.
	jump9 := self JumpZero: 0.
	currentBlock := self Label.
	jump5 jmpTarget: currentBlock.
	s45 := 0.
	s47 := s45.
	currentBlock := self Label.
	jump6 jmpTarget: currentBlock.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	jump3 jmpTarget: currentBlock.
	jump4 jmpTarget: currentBlock.
	jump7 jmpTarget: currentBlock.
	self TstCq: 7 R: t1.
	jump7 := self JumpNonZero: 0.
	currentBlock := self Label.
	jump9 jmpTarget: currentBlock.
	s51 := objectMemory nilObject.
	self CmpCq: s51 R: t1.
	jump9 := self JumpBelow: 0.
	s53 := objectMemory trueObject.
	self MoveCq: s53 R: t3.
	self MoveR: t1 R: t2.
	self CmpR: t3 R: t2.
	jumpTrue := self JumpBelowOrEqual: 0.
	self MoveCq: 0 R: t2.
	jumpNext := self Jump: 0.
	jumpTrue jmpTarget: self Label.
	self MoveCq: 1 R: t2.
	jumpNext jmpTarget: self Label.
	jump4 := self Jump: 0.
	currentBlock := self Label.
	jump9 jmpTarget: currentBlock.
	s59 := 0.
	self MoveCq: s59 R: t2.
	currentBlock := self Label.
	jump4 jmpTarget: currentBlock.
	self CmpCq: 1 R: t2.
	jump4 := self JumpZero: 0.
	s64 := objectMemory getMemoryMap getNewSpaceStart.
	self CmpCq: s64 R: t1.
	jump9 := self JumpBelow: 0.
	self MoveM64: 0 r: t0 R: t2.
	self ArithmeticShiftRightCq: 29 R: t2.
	self AndCq: 1 R: t2.
	self CmpCq: 0 R: t2.
	jump3 := self JumpNonZero: 0.
	self MoveR: t0 R: t2.
	self AndCq: 7 R: t2.
	self CmpCq: 0 R: t2.
	jump1 := self JumpNonZero: 0.
	s73 := objectMemory getMemoryMap getSpaceMaskToUse.
	self MoveCq: s73 R: t2.
	self MoveR: t0 R: t3.
	self AndR: t2 R: t3.
	s77 := objectMemory getMemoryMap getPermSpaceMask.
	self MoveCq: s77 R: t2.
	self CmpR: t2 R: t3.
	jumpTrue := self JumpZero: 0.
	self MoveCq: 0 R: t3.
	jumpNext := self Jump: 0.
	jumpTrue jmpTarget: self Label.
	self MoveCq: 1 R: t3.
	jumpNext jmpTarget: self Label.
	self MoveR: t3 R: t2.
	jump6 := self Jump: 0.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	s82 := 0.
	self MoveCq: s82 R: t2.
	currentBlock := self Label.
	jump6 jmpTarget: currentBlock.
	self CmpCq: 1 R: t2.
	jump6 := self JumpNonZero: 0.
	s87 := objectMemory getMemoryMap getSpaceMaskToUse.
	self MoveCq: s87 R: t2.
	self MoveR: t1 R: t3.
	self AndR: t2 R: t3.
	s91 := objectMemory getMemoryMap getPermSpaceMask.
	self CmpCq: s91 R: t3.
	jump1 := self JumpZero: 0.
	self MoveR: t0 R: TempReg.
	backEnd saveAndRestoreLinkRegAround: [
		self CallRT: ceStoreCheckTrampoline ].
	currentBlock := self Label.
	jump8 jmpTarget: currentBlock.
	jump7 jmpTarget: currentBlock.
	jump4 jmpTarget: currentBlock.
	jump9 jmpTarget: currentBlock.
	jump3 jmpTarget: currentBlock.
	jump6 jmpTarget: currentBlock.
	jump1 jmpTarget: currentBlock.
	self MoveR: t1 M64: 8 r: t0.
	currentBlock := self Label.
	jump2 jmpTarget: currentBlock.
	^ 0
]

{ #category : #query }
DruidTestRTLCompiler >> hasAnnotatedAbstractInstructions: annotation [

	0 to: opcodeIndex - 1 do: [ :i |
		| instruction |
		instruction := self abstractInstructionAt: i.
		instruction annotation = annotation ifTrue: [ ^ true ] ].
	^ false
]

{ #category : #'trait candidates' }
DruidTestRTLCompiler >> initialize [

	super initialize.
	deadCode := false
]

{ #category : #generated }
DruidTestRTLCompiler >> numRegArgs [

	^ 2 "Hardcoded?"
]

{ #category : #compatibility }
DruidTestRTLCompiler >> shouldAnnotateObjectReference: anOop [
	"Objects in newSpace or oldSpace except nil, true, false & classTableRootObj need to be annotated."
	^(objectMemory isNonImmediate: anOop)
	  and: [(self oop: anOop isGreaterThan: objectMemory classTableRootObj)
		or: [self oop: anOop isLessThan: objectMemory nilObject]]
]

{ #category : #generated }
DruidTestRTLCompiler >> smallIntegerSpecialisedPreamble [ 

	self mclassIsSmallInteger ifFalse:
		[^UnimplementedPrimitive].
]
