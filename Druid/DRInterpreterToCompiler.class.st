"
Implements a basic interpreter to compiler.

- All the generated bytecodes or primitives are unimplemented.
- No error handling.

This enables to build a VM which includes the JIT, but does not know how to JIT any method. Then the primitives or bytecodes could be added incrementally, and provides a baseline to compare performance between implementations.



"
Class {
	#name : #DRInterpreterToCompiler,
	#superclass : #DRAbstractCompilerBuilder,
	#instVars : [
		'memory',
		'compilerCompilerClass',
		'interpreter',
		'compilerCompiler',
		'interpreterBuilder',
		'interpreterClass'
	],
	#category : #'Druid-InterpreterBuilder'
}

{ #category : #examples }
DRInterpreterToCompiler class >> examplePrimitivesCollector [
	<example>

	| primCollector |

	StackInterpreter initializePrimitiveTable.
	primCollector := (DRInterpreterToCompiler
			fromInterpreter: (DRDummyInterpreter new primitives: StackInterpreter primitiveTable)
			compilerClass: DRPrimitiveCompilerCompilerCollector)
				collectPrimitives.
	primCollector failedPrimitives inspect
]

{ #category : #examples }
DRInterpreterToCompiler class >> examplePrimitivesFromCollection [
	<example>
	
	^ (DRInterpreterToCompiler 
			fromInterpreterBuilder: (DRInterpreterBuilder new primitives: #(#primitiveAdd)))
				primitives inspect
]

{ #category : #examples }
DRInterpreterToCompiler class >> examplePrimitivesFromInterpreterBuilderClass [
	<example>
	
	^ (DRInterpreterToCompiler 
			fromInterpreterBuilder: DRInterpreterBuilder new)
				primitives inspect
]

{ #category : #'instance creation' }
DRInterpreterToCompiler class >> fromInterpreter: anInterpreterBuilder compilerClass: aCompilerClass [

	^ self basicNew
		compilerCompilerClass: aCompilerClass;
		interpreterBuilder: anInterpreterBuilder;
		initialize;
		yourself
]

{ #category : #'instance creation' }
DRInterpreterToCompiler class >> fromInterpreterBuilder: anInterpreterBuilder [

	^  self basicNew
		interpreterBuilder: anInterpreterBuilder;
		initialize;
		yourself
]

{ #category : #'instance creation' }
DRInterpreterToCompiler class >> fromInterpreterClass: anInterpreterClass [

	^  self basicNew
		interpreterClass: anInterpreterClass;
		yourself
]

{ #category : #'accessing - primitives' }
DRInterpreterToCompiler >> collectPrimitives [
	"Trace receiver's interpreter primitives and collect compilation results.
	See implementors of #handlePrimitiveCompilationFor: "

	self generateBuildModel primitives.
	^ self compilerCompiler
]

{ #category : #accessing }
DRInterpreterToCompiler >> compilationUnitClass [

	^ DRJITCompilationUnit 
]

{ #category : #'accessing - compiler' }
DRInterpreterToCompiler >> compilerCompiler [
	"Answer a Druid compiler configured for the receiver's interpreter builder"

	^ compilerCompiler
		ifNil: [ compilerCompiler := self compilerCompilerClass forInterpreter: interpreter ]
]

{ #category : #'accessing - compiler' }
DRInterpreterToCompiler >> compilerCompilerClass [

	^ compilerCompilerClass
		ifNil: [ compilerCompilerClass := self defaultCompilerCompilerClass ]
]

{ #category : #'accessing - compiler' }
DRInterpreterToCompiler >> compilerCompilerClass: aClass [

	compilerCompilerClass := aClass
]

{ #category : #'accessing - compiler' }
DRInterpreterToCompiler >> defaultCompilerCompilerClass [

	^ DRPrimitiveCompilerCompiler
]

{ #category : #accessing }
DRInterpreterToCompiler >> defaultTargetSuperclass [

	^ StackToRegisterMappingCogit
]

{ #category : #'accessing - model' }
DRInterpreterToCompiler >> generateBuildModelAndCompileIn: aClass [
	"Generate and install the receiver's primitives into JIT compiler aClass"

	self generateBuildModel
		interpreter: interpreter;
		targetClass: (self environmentAt: aClass);
		compileAll
]

{ #category : #'accessing - model' }
DRInterpreterToCompiler >> generateBuildModelAndCompileIn: aClass superclass: aSuperclass [
	"Generate and install the receiver's primitives into JIT compiler aClass"

	self generateBuildModel
		interpreter: interpreter;
		targetSuperclass: aSuperclass;
		targetClass: (self environmentAt: aClass);
		compileAll
]

{ #category : #accessing }
DRInterpreterToCompiler >> generateIRAndCompileIn: aClass [
	"Generate and install the receiver's primitives into JIT compiler aClass"

	self addPrimitives.
	self compilationUnit
		interpreter: interpreter;
		targetClass: (self environmentAt: aClass);
		compileAll
]

{ #category : #helpers }
DRInterpreterToCompiler >> initPrimitiveTable [
	"Answer a <Collection> with the JITed primitives"

	^ compilationUnit initPrimitiveTable
]

{ #category : #'accessing - object memory' }
DRInterpreterToCompiler >> initializationOptions [

	^ {
		#BytesPerWord . 8 .
		#ObjectMemory .  memory class name
		}
]

{ #category : #initialization }
DRInterpreterToCompiler >> initialize [

	super initialize.
	interpreter := self newInterpreter
]

{ #category : #accessing }
DRInterpreterToCompiler >> interpreterBuilder [

	^ interpreterBuilder
]

{ #category : #accessing }
DRInterpreterToCompiler >> interpreterBuilder: aClass [ 

	interpreterBuilder := aClass
]

{ #category : #accessing }
DRInterpreterToCompiler >> interpreterClass [

	^ interpreterClass
]

{ #category : #accessing }
DRInterpreterToCompiler >> interpreterClass: anObject [

	interpreterClass := anObject
]

{ #category : #accessing }
DRInterpreterToCompiler >> interpreterPrimitiveTable [
	"Answer a <Collection> of <Symbol> each one representing a selector (e.g. #primitiveEqual) of the receiver's primitive table"

	^ interpreterBuilder primitiveTable
]

{ #category : #accessing }
DRInterpreterToCompiler >> newInterpreter [
	" Answer an <AbstractInterpreter|StackInterpreter> from the receiver's interpreter builder "
	memory := self newMemory.

	interpreterBuilder 
		initializeWithOptions: self initializationOptions
		objectMemoryClass: memory class.

	^ interpreterBuilder basicNew
		  objectMemory: memory;
		  basicInitialize
]

{ #category : #'accessing - object memory' }
DRInterpreterToCompiler >> newMemory [
	" Answer a memory manager instance. Currently a subclass of <SpurMemoryManager> "

	^ Spur64BitCoMemoryManager simulatorClass new
]

{ #category : #accessing }
DRInterpreterToCompiler >> newPrimitive: aString [
	" Answer a new primitive object with its metadata and CFG generated "

	^ DRPrimitiveObject new
		primitiveNumber: (self primitiveNumberOf: aString);
		sourceSelector: aString;
		cfg: (self compilerCompiler buildIR: aString);
		argumentCount: (self compilerCompiler numberOfArgumentsForSelector: aString);
		mayCallback: (self primitiveMayCallback: aString);
		yourself
]

{ #category : #accessing }
DRInterpreterToCompiler >> primitiveMayCallback: aString [
	"Answer <true> if primitive aString is marked as maycallback"
	" #maycallback "

	^ aString = #genNonImplementedPrimitive
]

{ #category : #'accessing - primitives' }
DRInterpreterToCompiler >> primitiveNumberOf: aSelector [
	" Answer a <Number> representing the primitive number of aSelector "

	| primNumber |

	primNumber := self interpreterPrimitiveTable indexOf: aSelector.
	^ self interpreterPrimitiveTable first = 0
		ifTrue: [ primNumber - 1 ]
		ifFalse: [ primNumber ]
]

{ #category : #'accessing - primitives' }
DRInterpreterToCompiler >> primitiveTable [
	"Answer a <Collection> of primitive selectors"

	^ interpreter class basicPrimitiveTable
]

{ #category : #'accessing - primitives' }
DRInterpreterToCompiler >> primitives [

	^ self compilationUnit primitives
		ifEmpty: [ self generateBuildModel primitives ]
		ifNotEmpty: [ : p | p ]
]
