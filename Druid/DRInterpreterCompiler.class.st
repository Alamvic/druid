"
Implements a basic interpreter to compiler.

- All the generated bytecodes or primitives are unimplemented.
- No error handling.

This enables to build a VM which includes the JIT, but does not know how to JIT any method. Then the primitives or bytecodes could be added incrementally, and provides a baseline to compare performance between implementations.



"
Class {
	#name : #DRInterpreterCompiler,
	#superclass : #Object,
	#instVars : [
		'memory',
		'compilerCompilerClass',
		'interpreter',
		'compilerCompiler',
		'interpreterBuilder',
		'compilationUnit'
	],
	#category : #'Druid-InterpreterBuilder'
}

{ #category : #examples }
DRInterpreterCompiler class >> examplePrimitivesCollector [
	<example>

	| primCollector |

	StackInterpreter initializePrimitiveTable.
	primCollector := (DRInterpreterCompiler
			fromInterpreter: (DRDummyInterpreter new primitives: StackInterpreter primitiveTable)
			compilerClass: DRPrimitiveCompilerCompilerCollector)
				collectPrimitives.
	primCollector failedPrimitives inspect
]

{ #category : #examples }
DRInterpreterCompiler class >> examplePrimitivesFromCollection [
	<example>
	
	^ (DRInterpreterCompiler 
			fromInterpreter: (DRDummyInterpreter new primitives: #(#primitiveAdd)))
				primitives inspect
]

{ #category : #examples }
DRInterpreterCompiler class >> examplePrimitivesFromInterpreterBuilderClass [
	<example>
	
	^ (DRInterpreterCompiler 
			fromInterpreter: DRInterpreterBuilder new)
				primitives inspect
]

{ #category : #'instance creation' }
DRInterpreterCompiler class >> fromInterpreter: anInterpreterBuilder [ 

	^  self basicNew
		interpreterBuilder: anInterpreterBuilder;
		initialize;
		yourself
]

{ #category : #'instance creation' }
DRInterpreterCompiler class >> fromInterpreter: anInterpreterBuilder compilerClass: aCompilerClass [

	^ self basicNew
		compilerCompilerClass: aCompilerClass;
		interpreterBuilder: anInterpreterBuilder;
		initialize;
		yourself
]

{ #category : #'code generation' }
DRInterpreterCompiler class >> generateDruidJITModel [

	<script>
	| compilerClassName interpreterCompiler compilationUnit primitives |
	compilerClassName := #DruidJIT.
	primitives := #( #primitiveAdd #primitiveSubtract #primitiveLessThan
	                 #primitiveGreaterThan #primitiveLessOrEqual
	                 #primitiveGreaterOrEqual #primitiveEqual #primitiveNotEqual
	                 #primitiveMultiply #primitiveDivide ).

	interpreterCompiler := DRInterpreterCompiler
		                       fromInterpreter:
		                       (DRDummyInterpreter new primitives: primitives)
		                       compilerClass: DRPrimitiveCompilerCompilerCollector.

	compilationUnit := interpreterCompiler generateIR.
	interpreterCompiler generateBuildModelAndCompileIn: compilerClassName
]

{ #category : #'accessing - primitives' }
DRInterpreterCompiler >> addPrimitive: primitiveSelector to: aDRCompilationUnit [

	| primitiveMethod |
	primitiveSelector isInteger ifTrue: [ ^ self assert: primitiveSelector = 0 ].

	primitiveMethod := interpreter class lookupSelector: primitiveSelector.

	(primitiveMethod hasPragmaNamed: #numberOfArguments:) ifFalse: [
		self error: 'Primitive number of arguments is missing in ' , primitiveSelector ].

	aDRCompilationUnit addPrimitive: (self newPrimitive: primitiveMethod)
]

{ #category : #'accessing - primitives' }
DRInterpreterCompiler >> addPrimitivesTo: aCompilationUnit [
	"Iterate over the receiver's interpreter (assumed to contain primitive methods) and add them to compilationUnit"

	self interpreterPrimitiveTable
		do: [ :selector | self addPrimitive: selector to: aCompilationUnit ]
		displayingProgress: [ :selector | 'Adding primitive: ' , selector asString ].

	self flag: #TOFIX.
	interpreter class primitiveTable
		do: [ :selector |
			(selector isNumber or: [ self interpreterPrimitiveTable includes: selector ])
				ifFalse: [
					| method |
					method := interpreter class lookupSelector: selector.
					(self isMaycallbackPrimitive: method) ifTrue: [
						aCompilationUnit addPrimitive: (self newNonImplementedPrimitive: method) ] ] ]
		displayingProgress: [ :selector | 'Adding mandatory non implemented primitive: ' , selector asString ]
]

{ #category : #'accessing - primitives' }
DRInterpreterCompiler >> collectPrimitives [
	"Trace receiver's interpreter primitives and collect compilation results.
	See implementors of #handlePrimitiveCompilationFor: "

	self generateIR primitives.
	^ self compilerCompiler
]

{ #category : #'accessing - compiler' }
DRInterpreterCompiler >> compilationUnit [

	^ compilationUnit
]

{ #category : #'accessing - compiler' }
DRInterpreterCompiler >> compilationUnit: anObject [

	compilationUnit := anObject
]

{ #category : #'accessing - compiler' }
DRInterpreterCompiler >> compilerCompiler [
	"Answer a Druid compiler configured for the receiver's interpreter builder"

	^ compilerCompiler
		ifNil: [
			compilerCompiler := self compilerCompilerClass 	forInterpreter: interpreter ]
]

{ #category : #'accessing - compiler' }
DRInterpreterCompiler >> compilerCompilerClass [

	^ compilerCompilerClass
		ifNil: [ compilerCompilerClass := self defaultCompilerCompilerClass ]
]

{ #category : #'accessing - compiler' }
DRInterpreterCompiler >> compilerCompilerClass: aClass [

	compilerCompilerClass := aClass
]

{ #category : #'accessing - compiler' }
DRInterpreterCompiler >> defaultCompilerCompilerClass [

	^ DRPrimitiveCompilerCompiler
]

{ #category : #accessing }
DRInterpreterCompiler >> environmentAt: aClass [
	"Answer the class named aClass. Create if it doesn't exist"

	^ self class environment
		at: aClass
		ifAbsent: [ self newJitCompilerClassNamed: aClass ]
]

{ #category : #'accessing - model' }
DRInterpreterCompiler >> generateBuildModel [
	"Answer a <DRCompilationBuildUnit>, useful for model manipulation before code dumping"

	compilationUnit := DRCompilationUnitBuilder new.
	self addPrimitivesTo: compilationUnit.
	^ compilationUnit
]

{ #category : #'accessing - model' }
DRInterpreterCompiler >> generateBuildModelAndCompileIn: aClass [
	"Generate and install the receiver's primitives into JIT compiler aClass"

	self generateBuildModel
		interpreter: interpreter;
		jitCompilerClass: (self environmentAt: aClass);
		compileAll
]

{ #category : #accessing }
DRInterpreterCompiler >> generateIR [

	compilationUnit := DRCompilationUnit new.
	self addPrimitivesTo: compilationUnit.
	^ compilationUnit
]

{ #category : #accessing }
DRInterpreterCompiler >> generateIRAndCompileIn: aClass [
	"Generate and install the receiver's primitives into JIT compiler aClass"

	self generateIR
		interpreter: interpreter;
		jitCompilerClass: (self environmentAt: aClass);
		compileAll
]

{ #category : #helpers }
DRInterpreterCompiler >> initPrimitiveTable [
	"Answer a <Collection> with the JITed primitives"

	^ compilationUnit initPrimitiveTable
]

{ #category : #'accessing - object memory' }
DRInterpreterCompiler >> initializationOptions [

	^ {
		  #BytesPerWord.
		  8 .
		  #ObjectMemory.
		  memory class name}
]

{ #category : #initialization }
DRInterpreterCompiler >> initialize [

	super initialize.
	interpreter := self newInterpreter
]

{ #category : #accessing }
DRInterpreterCompiler >> interpreterBuilder [

	^ interpreterBuilder
]

{ #category : #accessing }
DRInterpreterCompiler >> interpreterBuilder: aClass [ 

	interpreterBuilder := aClass
]

{ #category : #accessing }
DRInterpreterCompiler >> interpreterBuilderClass [

	^ self interpreterBuilder class
]

{ #category : #accessing }
DRInterpreterCompiler >> interpreterPrimitiveTable [
	"Answer a <Collection> of <Symbol> each one representing a selector (e.g. #primitiveEqual) of the receiver's primitive table"

	^ interpreterBuilder primitiveTable
]

{ #category : #accessing }
DRInterpreterCompiler >> isMaycallbackPrimitive: primitiveMethod [ 
	"Answer <true> if primitive aString is marked as maycallback"
	" #maycallback "
	
	^ primitiveMethod hasPragmaNamed: #maycallback

]

{ #category : #accessing }
DRInterpreterCompiler >> newInterpreter [

	memory := self newMemory.

	interpreterBuilder 
		initializeWithOptions: self initializationOptions
		objectMemoryClass: memory class.

	^ interpreterBuilder basicNew
		  objectMemory: memory;
		  basicInitialize
]

{ #category : #accessing }
DRInterpreterCompiler >> newJitCompilerClassNamed: aString [
	"Answer a new <StackToRegisterMappingCogit> subclass named aString"

	^ (StackToRegisterMappingCogit << aString asSymbol)
		  tag: 'JIT';
		  package: 'VMMaker';
		  install
]

{ #category : #'accessing - object memory' }
DRInterpreterCompiler >> newMemory [
	" Answer a memory manager instance. Currently a subclass of <SpurMemoryManager> "

	^ Spur64BitCoMemoryManager simulatorClass new
]

{ #category : #'instance creation' }
DRInterpreterCompiler >> newNonImplementedPrimitive: interpreterPrimitiveMethod [


	| selector |
	selector := interpreterPrimitiveMethod selector.

	self flag: #TODO. "Duplicated code with newPrimitive:"

	^ DRPrimitiveObject new
		  primitiveNumber: (self primitiveNumberOf: selector);
		  sourceSelector: selector;
		  genSelector: #genNonImplementedPrimitive;
		  argumentCount: -1;
		  mayCallback: (self isMaycallbackPrimitive: interpreterPrimitiveMethod);
		  yourself
]

{ #category : #'accessing - primitives' }
DRInterpreterCompiler >> newPrimitive: primitiveMethod [
	" Answer a new primitive object with its metadata and CFG generated "
	| selector |
	selector := primitiveMethod selector.

	^ DRPrimitiveObject new
		primitiveNumber: (self primitiveNumberOf: selector);
		sourceSelector: selector;
		cfg: (self compilerCompiler buildIR: selector);
		argumentCount: (self compilerCompiler numberOfArgumentsForMethod: primitiveMethod);
		mayCallback: (self isMaycallbackPrimitive: primitiveMethod);
		yourself
]

{ #category : #'accessing - primitives' }
DRInterpreterCompiler >> primitiveNumberOf: aSelector [
	" Answer a <Number> representing the primitive number of aSelector "
	
	| primNumber interpreterTable |
	interpreterTable := interpreter class primitiveTable.
	primNumber := interpreterTable indexOf: aSelector.
	^ interpreterTable first = 0
		ifTrue: [ primNumber - 1 ]
		ifFalse: [ primNumber ]
]

{ #category : #'accessing - primitives' }
DRInterpreterCompiler >> primitiveTable [
	"Answer a <Collection> of primitive selectors"

	^ interpreter class basicPrimitiveTable
]

{ #category : #'accessing - primitives' }
DRInterpreterCompiler >> primitives [

	^ self generateIR primitives
]
