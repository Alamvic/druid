"
Implements a basic interpreter to compiler.

- All the generated bytecodes or primitives are unimplemented.
- No error handling.

This enables to build a VM which includes the JIT, but does not know how to JIT any method. Then the primitives or bytecodes could be added incrementally, and provides a baseline to compare performance between implementations.



"
Class {
	#name : #DRInterpreterCompiler,
	#superclass : #Object,
	#instVars : [
		'interpreterClass',
		'memory',
		'compilerCompilerClass',
		'interpreter',
		'compilerCompiler'
	],
	#category : #'Druid-CompilerCompiler'
}

{ #category : #'instance creation' }
DRInterpreterCompiler class >> fromInterpreter: aClass [ 

	^  self basicNew
		interpreterClass: aClass;
		initialize;
		yourself
]

{ #category : #accessing }
DRInterpreterCompiler >> addPrimitive: anInteger to: aDRCompilationUnit [ 

	anInteger = 0 ifFalse: [
		aDRCompilationUnit addPrimitive: (self newPrimitive: anInteger) ]
]

{ #category : #accessing }
DRInterpreterCompiler >> addPrimitivesTo: compilationUnit [
	"Iterate over the receiver's interpreter (assumed to contain primitive methods) and add them to compilationUnit"

	self interpreterPrimitiveTable do: [ : prim |
		self addPrimitive: prim to: compilationUnit ]

]

{ #category : #accessing }
DRInterpreterCompiler >> compilerCompiler [
	"Answer a Druid compiler configured for the receiver's interpreter builder"

	^ compilerCompiler
		ifNil: [
			compilerCompiler := self compilerCompilerClass new
				interpreter: self interpreterBuilder;
				yourself ]
]

{ #category : #accessing }
DRInterpreterCompiler >> compilerCompilerClass [

	^ compilerCompilerClass
		ifNil: [ compilerCompilerClass := self defaultCompilerCompilerClass ]
]

{ #category : #accessing }
DRInterpreterCompiler >> compilerCompilerClass: aClass [

	compilerCompilerClass := aClass forInterpreter: self
]

{ #category : #accessing }
DRInterpreterCompiler >> defaultCompilerCompilerClass [

	^ DRPrimitiveCompilerCompiler
]

{ #category : #accessing }
DRInterpreterCompiler >> generateIR [

	| compilationUnit |
	compilationUnit := DRCompilationUnit new.
	self addPrimitivesTo: compilationUnit.
	^ compilationUnit
]

{ #category : #accessing }
DRInterpreterCompiler >> initializationOptions [

	^ {
		  #BytesPerWord.
		  8 .
		  #ObjectMemory.
		  memory class name}
]

{ #category : #initialization }
DRInterpreterCompiler >> initialize [

	super initialize.
	interpreter := self newInterpreter
]

{ #category : #accessing }
DRInterpreterCompiler >> interpreterBuilder [
	" Answer an <AnstractInterpreter> "

	^ interpreter
		ifNil: [ interpreter := self newInterpreter ]
]

{ #category : #accessing }
DRInterpreterCompiler >> interpreterBuilderClass [

	^ self interpreterBuilder class
]

{ #category : #accessing }
DRInterpreterCompiler >> interpreterClass [
	^ interpreterClass
]

{ #category : #accessing }
DRInterpreterCompiler >> interpreterClass: aClass [ 

	interpreterClass := aClass
]

{ #category : #accessing }
DRInterpreterCompiler >> interpreterPrimitiveTable [
	"Answer a <Collection> of <Symbol> each one representing a selector (e.g. #primitiveEqual) of the receiver's primitive table"

	^ self interpreterClass primitiveTable
]

{ #category : #accessing }
DRInterpreterCompiler >> newInterpreter [

	memory := self newMemory.

	self interpreterClass
		initializeWithOptions: self initializationOptions
		objectMemoryClass: memory class.

	^ self interpreterClass basicNew
		  objectMemory: memory;
		  basicInitialize
]

{ #category : #accessing }
DRInterpreterCompiler >> newMemory [
	" Answer a memory manager instance. Currently a subclass of <SpurMemoryManager> "

	^ Spur64BitCoMemoryManager simulatorClass new
]

{ #category : #accessimg }
DRInterpreterCompiler >> newPrimitive: aString [ 
	" Answer a new primitive object with its metadata and CFG generated"

	^ DRPrimitiveObject new
		primitiveNumber: (self primitiveNumberOf: aString);
		sourceSelector: aString;
		cfg: (self compilerCompiler buildIR: aString);
		yourself

]

{ #category : #accessing }
DRInterpreterCompiler >> primitiveArgumentCountOf: aSelector [ 
	"Answer a <Number> of arguments exepcted by aSelector in the receiver's primitive table"
	
	^ 0
	" ^ (self primitiveTable indexOf: aSelector) - 1. "
]

{ #category : #accessing }
DRInterpreterCompiler >> primitiveNumberOf: aSelector [
	" Answer a <Number> representing the primitive number of aSelector "
	
	^ (self primitiveTable indexOf: aSelector) - 1.
]

{ #category : #accessing }
DRInterpreterCompiler >> primitiveTable [
	"Answer a <Collection> of primitive selectors"

	^ self interpreterBuilderClass primitiveTable
]

{ #category : #accessing }
DRInterpreterCompiler >> primitives [

	^ self generateIR primitives
]
